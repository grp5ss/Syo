-- GridInventory.lua
-- LocalScript for grid-based inventory system with drag-and-drop
-- Place in StarterPlayerScripts

local player = game:GetService("Players").LocalPlayer
local Services = {
	Players = game:GetService("Players"),
	TweenService = game:GetService("TweenService"),
	UserInputService = game:GetService("UserInputService"),
	RunService = game:GetService("RunService"),
	ReplicatedStorage = game:GetService("ReplicatedStorage"),
	Lighting = game:GetService("Lighting"),
	playerGui = player:WaitForChild("PlayerGui"),
}

-- ============================================================================
-- CONFIGURATION & TABLES
-- ============================================================================

-- RigsBackpackConfig for shared grid dimensions with server
local RigsBackpackConfig = require(Services.ReplicatedStorage:WaitForChild("RigsBackpackConfig"))
local StateAndDataManager = require(script:WaitForChild("StateAndDataManager"))
local UIManager = require(script:WaitForChild("UIManager"))

local Config = StateAndDataManager.Config
local Data = StateAndDataManager.Data
local State = StateAndDataManager.State
local UI = UIManager.UI

-- Remote events (will be created by server)
local Remotes = Services.ReplicatedStorage:WaitForChild("Remotes", 10)
local Events = {
	CollectItem = Remotes and Remotes:WaitForChild("CollectItem", 5),
	SyncInventory = Remotes and Remotes:WaitForChild("SyncInventory", 5),
	InventoryFull = Remotes and Remotes:WaitForChild("InventoryFull", 5),
	DropItem = Remotes and Remotes:WaitForChild("DropItem", 5),
	OpenChest = Remotes and Remotes:WaitForChild("OpenChest", 5),
	SyncChestLoot = Remotes and Remotes:WaitForChild("SyncChestLoot", 5),
	ArmorEquip = Remotes and Remotes:WaitForChild("ArmorEquipEvent", 5),
	ArmorSync = Remotes and Remotes:WaitForChild("ArmorSyncEvent", 5),
	SyncStorage = Remotes and Remotes:WaitForChild("SyncStorage", 5),
	MoveToStorage = Remotes and Remotes:WaitForChild("MoveToStorage", 5),
	MoveToInventory = Remotes and Remotes:WaitForChild("MoveToInventory", 5),
}

-- Item Configuration (Shared Module)
local ItemConfig = require(Services.ReplicatedStorage:WaitForChild("ItemConfig"))

-- Chest Configuration (Shared Module) - needed for chest detection
local ChestConfig = require(Services.ReplicatedStorage:WaitForChild("ChestConfig", 5))

StateAndDataManager.initialize()

-- ============================================================================
-- CREATE MAIN UI (delegating to UIManager)
-- ============================================================================

UIManager.createBaseUI(Services.playerGui, Services)

UIManager.createInventoryButton(Config)
UIManager.createMainPanel(Config)

-- ============================================================================
-- ITEM ACTION BAR (delegating to UIManager)
-- ============================================================================

UIManager.createActionBar()
UIManager.setupButtonHoverEffects()

State.actionBarSelectedItem = nil

-- Item Info Modal (delegating to UIManager)
UIManager.createItemInfoModal()

local function showItemInfoModal(itemData)
	UIManager.showItemInfoModal(itemData)
end

local function hideItemInfoModal()
	UIManager.hideItemInfoModal()
end

UI.modalCloseBtn.MouseButton1Click:Connect(hideItemInfoModal)

local function updateActionBar(itemData)
	UIManager.updateActionBar(itemData, State)
	if not itemData then
		hideItemInfoModal()
	end
end

-- INFO button click handler
UI.infoButton.MouseButton1Click:Connect(function()
	-- Play button sound
	local soundService = game:GetService("SoundService")
	local buttonSound = soundService:FindFirstChild("Button")
	if buttonSound and buttonSound:IsA("Sound") then
		buttonSound:Play()
	end
	
	if State.actionBarSelectedItem then
		showItemInfoModal(State.actionBarSelectedItem)
	end
end)

-- Drop button click handler
UI.dropButton.MouseButton1Click:Connect(function()
	-- Play button sound
	local soundService = game:GetService("SoundService")
	local buttonSound = soundService:FindFirstChild("Button")
	if buttonSound and buttonSound:IsA("Sound") then
		buttonSound:Play()
	end
	
	if not State.actionBarSelectedItem then return end
	
	-- Check if in safezone
	if player:GetAttribute("InSafezone") == true then
		return
	end
	
	-- Get item info
	local itemId = State.actionBarSelectedItem.config.id
	
	-- Fire drop event to server
	if Events.DropItem then
		Events.DropItem:FireServer(itemId)
	end
	
	-- Hide action bar immediately (server will sync inventory)
	updateActionBar(nil)
end)

-- Hover effects for buttons
UI.infoButton.MouseEnter:Connect(function()
	Services.TweenService:Create(UI.infoStroke, TweenInfo.new(0.15), {Color = Color3.fromRGB(150, 200, 255)}):Play()
end)
UI.infoButton.MouseLeave:Connect(function()
	Services.TweenService:Create(UI.infoStroke, TweenInfo.new(0.15), {Color = Color3.new(1, 1, 1)}):Play()
end)
UI.dropButton.MouseEnter:Connect(function()
	Services.TweenService:Create(UI.dropStroke, TweenInfo.new(0.15), {Color = Color3.fromRGB(255, 150, 150)}):Play()
end)
UI.dropButton.MouseLeave:Connect(function()
	Services.TweenService:Create(UI.dropStroke, TweenInfo.new(0.15), {Color = Color3.new(1, 1, 1)}):Play()
end)

-- ============================================================================
-- MAIN CONTENT SCROLLING CONTAINER (delegating to UIManager)
-- ============================================================================

UIManager.createContentScroll()

-- ============================================================================
-- RIG CONTAINER (delegating to UIManager)
-- ============================================================================

UIManager.createRigContainer(Config, Data)

-- ============================================================================
-- BACKPACK CONTAINER (delegating to UIManager)
-- ============================================================================

UIManager.createBackpackContainer()

-- ============================================================================
-- LOOT INFO CONTAINER (delegating to UIManager)
-- ============================================================================

UIManager.createLootInfoContainer()

-- ============================================================================
-- ARMOR EQUIPMENT CONTAINER (delegating to UIManager)
-- ============================================================================

local canFitItemAnywhere

UIManager.createArmorContainer(Data)

local function setupArmorSlotHandlers()
	for slotName, slotData in pairs(Data.armorSlots) do
		slotData.frame.InputBegan:Connect(function(input)
			if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
				if State.selectedItem then
					local itemConfig = State.selectedItem.config
					if itemConfig and itemConfig.isArmor and itemConfig.slotType == slotName then
						if slotData and slotData.equipped then
							return
						end
						
						local armorItemId = itemConfig.itemId or itemConfig.name
						local instanceId = itemConfig.id
						
						if Events.ArmorEquip then
							Events.ArmorEquip:FireServer("equip", armorItemId, slotName, instanceId)
						end
						
						if slotData then
							slotData.equippedIcon.Image = itemConfig.icon
							slotData.equippedIcon.Visible = true
							slotData.icon.Visible = false
							slotData.equipped = armorItemId
							slotData.stroke.Color = Color3.fromRGB(100, 255, 100)
						end
						
						if State.selectedItem and State.selectedItem.frame then
							local itemStroke = State.selectedItem.frame:FindFirstChild("ItemStroke")
							if itemStroke then
								itemStroke.Thickness = 1
							end
						end
						State.selectedItem = nil
						UI.actionBar.Visible = false
						
						for name, data in pairs(Data.armorSlots) do
							if not data.equipped then
								data.stroke.Color = Color3.fromRGB(80, 80, 120)
								data.stroke.Thickness = 1
							end
						end
						
						local soundService = game:GetService("SoundService")
						local equipSound = soundService:FindFirstChild("Button")
						if equipSound then equipSound:Play() end
					end
				elseif slotData and slotData.equipped then
					local equippedItemId = slotData.equipped
					local armorConfig = ItemConfig[equippedItemId] or ItemConfig.GetItem(equippedItemId)
					
					if armorConfig then
						local itemWidth = armorConfig.width or 1
						local itemHeight = armorConfig.height or 1
						
						if not canFitItemAnywhere(itemWidth, itemHeight) then
							return
						end
					end
					
					if Events.ArmorEquip then
						Events.ArmorEquip:FireServer("unequip", slotName)
					end
					
					slotData.equippedIcon.Visible = false
					slotData.icon.Visible = true
					slotData.equipped = nil
					slotData.stroke.Color = Color3.fromRGB(80, 80, 120)
					
					local soundService = game:GetService("SoundService")
					local equipSound = soundService:FindFirstChild("Button")
					if equipSound then equipSound:Play() end
				end
			end
		end)
	end
end

setupArmorSlotHandlers()

-- ============================================================================
-- PLAYER AND CHEST CONTAINERS (delegating to UIManager)
-- ============================================================================

UIManager.createPlayerAndChestContainers(Data, Config)

-- ============================================================================
-- DYNAMIC CHEST GRID RECREATION (delegating to UIManager)
-- ============================================================================

local setupChestSlotInput

local function recreateChestGrid()
	UIManager.recreateChestGrid(Config, State, Data, setupChestSlotInput)
end

-- ============================================================================
-- CHARACTER VIEWPORT (delegating to UIManager)
-- ============================================================================

UIManager.createCharacterViewport(State)
UIManager.setupViewportRotation(State)

local function updateCharacterViewport()
	UIManager.updateCharacterViewport(player, State)
end

-- ============================================================================
-- STATUS CONTAINER (delegating to UIManager)
-- ============================================================================

UIManager.createStatusContainer()

local function updateHealthBar()
	UIManager.updateHealthBar(player)
end

local function connectHealthBar()
	UIManager.connectHealthBar(player, State)
end

player.CharacterAdded:Connect(function(char)
	task.wait(0.5)
	connectHealthBar()
end)

-- ============================================================================
-- GRID UTILITY FUNCTIONS (delegating to StateAndDataManager)
-- ============================================================================

local function canPlaceItem(width, height, startRow, startCol, excludeItemId)
	return StateAndDataManager.canPlaceItem(width, height, startRow, startCol, excludeItemId)
end

canFitItemAnywhere = function(width, height)
	return StateAndDataManager.canFitItemAnywhere(width, height)
end

local function placeItemInGrid(itemId, width, height, startRow, startCol)
	StateAndDataManager.placeItemInGrid(itemId, width, height, startRow, startCol)
end

local function removeItemFromGrid(itemId)
	StateAndDataManager.removeItemFromGrid(itemId)
end

-- ============================================================================
-- STORAGE GRID UTILITY FUNCTIONS (delegating to StateAndDataManager)
-- ============================================================================

local function initializeStorageGridData()
	StateAndDataManager.initializeStorageGridData()
end

local function removeItemFromStorageGrid(itemId)
	StateAndDataManager.removeItemFromStorageGrid(itemId)
end

local function placeItemInStorageGrid(itemId, width, height, startRow, startCol)
	StateAndDataManager.placeItemInStorageGrid(itemId, width, height, startRow, startCol)
end

local function canPlaceItemInStorage(width, height, startRow, startCol, excludeItemId)
	return StateAndDataManager.canPlaceItemInStorage(width, height, startRow, startCol, excludeItemId)
end

-- ============================================================================
-- CHEST GRID UTILITY FUNCTIONS (delegating to StateAndDataManager)
-- ============================================================================

local function initializeChestGridData()
	StateAndDataManager.initializeChestGridData()
end

local function canPlaceItemInChest(width, height, startRow, startCol, excludeItemId)
	return StateAndDataManager.canPlaceItemInChest(width, height, startRow, startCol, excludeItemId)
end

local function placeItemInChestGrid(itemId, width, height, startRow, startCol)
	StateAndDataManager.placeItemInChestGrid(itemId, width, height, startRow, startCol)
end

local function removeItemFromChestGrid(itemId)
	StateAndDataManager.removeItemFromChestGrid(itemId)
end

local function findBestChestPlacement(width, height, targetRow, targetCol, excludeItemId)
	return StateAndDataManager.findBestChestPlacement(width, height, targetRow, targetCol, excludeItemId)
end

local function getGridPositionFromAbsolute(absX, absY)
	local containerPos = UI.gridContainer.AbsolutePosition
	local containerScale = UI.uiScale.Scale
	
	-- Account for UIScale on container position and size
	local scaledCellSize = (Config.CELL_SIZE + Config.CELL_PADDING) * containerScale
	
	local relX = absX - containerPos.X
	local relY = absY - containerPos.Y
	
	-- Use center-based rounding: add half cell size before floor for symmetric behavior
	-- This makes the cell switch when cursor crosses the CENTER of cell boundary
	local col = math.floor((relX + scaledCellSize / 2) / scaledCellSize) + 1
	local row = math.floor((relY + scaledCellSize / 2) / scaledCellSize) + 1
	
	return row, col
end

-- ============================================================================
-- ITEM VISUAL CREATION
-- ============================================================================

local function createItemFrame(itemConfig, width, height, row, col)
	local itemFrame = Instance.new("Frame")
	itemFrame.Name = itemConfig.id
	itemFrame.Size = UDim2.new(0, width * Config.CELL_SIZE + (width - 1) * Config.CELL_PADDING, 0, height * Config.CELL_SIZE + (height - 1) * Config.CELL_PADDING)
	itemFrame.Position = UDim2.new(0, (col - 1) * (Config.CELL_SIZE + Config.CELL_PADDING), 0, (row - 1) * (Config.CELL_SIZE + Config.CELL_PADDING))
	
	-- Use RarityFrameColors for background
	local frameColor = ItemConfig.GetRarityFrameColor(itemConfig.rarity or "Common")
	local frameTransparency = ItemConfig.GetRarityFrameTransparency()
	itemFrame.BackgroundColor3 = frameColor
	itemFrame.BackgroundTransparency = frameTransparency
	itemFrame.BorderSizePixel = 0
	itemFrame.ZIndex = 15
	itemFrame.Parent = UI.gridContainer
	
	-- Stroke color (using RarityColors for stroke/border)
	local strokeColor = ItemConfig.GetRarityColor(itemConfig.rarity or "Common")
	
	-- Gradient (based on frame color for visual effect)
	local darkerColor = Color3.fromRGB(
		math.floor(frameColor.R * 255 * 0.6),
		math.floor(frameColor.G * 255 * 0.6),
		math.floor(frameColor.B * 255 * 0.6)
	)
	local gradient = Instance.new("UIGradient")
	gradient.Color = ColorSequence.new({
		ColorSequenceKeypoint.new(0, frameColor),
		ColorSequenceKeypoint.new(1, darkerColor),
	})
	gradient.Rotation = 45
	gradient.Parent = itemFrame
	
	-- Stroke (using RarityColors for stroke/border)
	local stroke = Instance.new("UIStroke")
	stroke.Name = "ItemStroke"
	stroke.Color = strokeColor
	stroke.Thickness = 1
	stroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
	stroke.Parent = itemFrame
	
	-- Item Icon (ImageLabel if icon available, else fallback Frame)
	if itemConfig.icon and itemConfig.icon ~= "" and itemConfig.icon ~= "rbxassetid://0" then
		local iconImage = Instance.new("ImageLabel")
		iconImage.Name = "Icon"
		iconImage.Size = UDim2.new(1, 0, 1, 0)  -- Full size (scale 1x1)
		iconImage.Position = UDim2.new(0, 0, 0, 0)
		iconImage.BackgroundTransparency = 1
		iconImage.Image = itemConfig.icon
		iconImage.ScaleType = Enum.ScaleType.Fit
		iconImage.ZIndex = 16
		iconImage.Parent = itemFrame
	else
		-- Fallback: Placeholder shape icon (if no image)
		local icon = Instance.new("Frame")
		icon.Name = "Icon"
		icon.Size = UDim2.new(0.6, 0, 0.6, 0)
		icon.Position = UDim2.new(0.2, 0, 0.2, 0)
		icon.BackgroundColor3 = itemConfig.color or Color3.fromRGB(200, 200, 200)
		icon.BackgroundTransparency = 0.3
		icon.BorderSizePixel = 0
		icon.ZIndex = 16
		icon.Parent = itemFrame
	end
	
	-- Name label removed - info shown via long-press popup
	
	return itemFrame
end

-- ============================================================================
-- HIGHLIGHT SYSTEM (delegating to UIManager)
-- ============================================================================

local function clearHighlights()
	UIManager.clearHighlights(State)
end

local function highlightSlots(startRow, startCol, width, height, isValid)
	UIManager.highlightSlots(startRow, startCol, width, height, isValid, Config, State)
end

local function highlightOriginalSlot(row, col, width, height)
	UIManager.highlightOriginalSlot(row, col, width, height, Config, State)
end

local function resetOriginalSlotHighlight(row, col, width, height)
	UIManager.resetOriginalSlotHighlight(State)
end

-- ============================================================================
-- CHEST HIGHLIGHT SYSTEM (delegating to UIManager)
-- ============================================================================

local function clearChestHighlights()
	UIManager.clearChestHighlights(State)
end

local function highlightChestSlots(startRow, startCol, width, height, isValid)
	UIManager.highlightChestSlots(startRow, startCol, width, height, isValid, Config, State)
end

local function highlightChestOriginalSlot(row, col, width, height)
	UIManager.highlightChestOriginalSlot(row, col, width, height, Config, State)
end

local function resetChestOriginalSlotHighlight()
	UIManager.resetChestOriginalSlotHighlight(State)
end

-- ============================================================================
-- STORAGE HIGHLIGHT SYSTEM (delegating to UIManager)
-- ============================================================================

local function clearStorageHighlights()
	UIManager.clearStorageHighlights(State)
end

local function highlightStorageSlots(startRow, startCol, width, height, isValid)
	UIManager.highlightStorageSlots(startRow, startCol, width, height, isValid, Config, State)
end

local function highlightStorageOriginalSlot(row, col, width, height)
	UIManager.highlightStorageOriginalSlot(row, col, width, height, Config, State)
end

local function resetStorageOriginalSlotHighlight()
	UIManager.resetStorageOriginalSlotHighlight(State)
end

-- ============================================================================
-- ITEM INFO POPUP SYSTEM (1.5s long press)
-- ============================================================================

State.itemInfoPopup = nil
State.longPressStartTime = nil
State.longPressItem = nil
Config.LONG_PRESS_DURATION = 0.4  -- seconds (increased for easier quick tap unselect)

local function closeItemInfoPopup()
	if State.itemInfoPopup and State.itemInfoPopup.Parent then
		State.itemInfoPopup:Destroy()
		State.itemInfoPopup = nil
	end
end

local function showItemInfoPopup(itemData)
	closeItemInfoPopup()
	
	local itemConfig = itemData.config
	local itemFrame = itemData.frame
	
	-- Calculate popup position using absolute position (to avoid ClipsDescendants)
	local itemAbsPos = itemFrame.AbsolutePosition
	local itemAbsSize = itemFrame.AbsoluteSize
	local mainPanelPos = UI.mainPanel.AbsolutePosition
	local scale = UI.uiScale.Scale
	
	-- Position popup to the right of item, relative to UI.mainPanel
	local popupX = (itemAbsPos.X + itemAbsSize.X + 10 - mainPanelPos.X) / scale
	local popupY = (itemAbsPos.Y - mainPanelPos.Y) / scale

	
	-- Create popup frame (horizontal layout, short height)
	State.itemInfoPopup = Instance.new("Frame")
	State.itemInfoPopup.Name = "ItemInfoPopup"
	State.itemInfoPopup.Size = UDim2.new(0, 220, 0, 100)
	State.itemInfoPopup.Position = UDim2.new(0, popupX, 0, popupY)  -- Right of item
	State.itemInfoPopup.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	State.itemInfoPopup.BorderSizePixel = 0
	State.itemInfoPopup.ZIndex = 100  -- Very high to be on top
	State.itemInfoPopup.Parent = UI.mainPanel  -- Parent to UI.mainPanel to avoid ClipsDescendants
	
	local popupStroke = Instance.new("UIStroke")
	popupStroke.Color = Color3.fromRGB(100, 80, 140)
	popupStroke.Thickness = 2
	popupStroke.Parent = State.itemInfoPopup
	
	-- Icon frame (top-left) - uses RarityFrameColors based on item rarity
	local iconFrame = Instance.new("Frame")
	iconFrame.Name = "IconFrame"
	iconFrame.Size = UDim2.new(0, 50, 0, 50)
	iconFrame.Position = UDim2.new(0, 10, 0, 10)
	iconFrame.BackgroundColor3 = ItemConfig.GetRarityFrameColor(itemConfig.rarity or "Common")
	iconFrame.BackgroundTransparency = ItemConfig.GetRarityFrameTransparency()
	iconFrame.BorderSizePixel = 0
	iconFrame.ZIndex = 51
	iconFrame.Parent = State.itemInfoPopup
	
	-- Stroke using RarityColors
	local iconStroke = Instance.new("UIStroke")
	iconStroke.Name = "IconStroke"
	iconStroke.Color = ItemConfig.GetRarityColor(itemConfig.rarity or "Common")
	iconStroke.Thickness = 1
	iconStroke.Parent = iconFrame
	
	-- Icon image (inside iconFrame) - full size to match frame
	if itemConfig.icon and itemConfig.icon ~= "" then
		local iconImage = Instance.new("ImageLabel")
		iconImage.Name = "IconImage"
		iconImage.Size = UDim2.new(1, 0, 1, 0)
		iconImage.BackgroundTransparency = 1
		iconImage.Image = itemConfig.icon
		iconImage.ScaleType = Enum.ScaleType.Fit
		iconImage.ZIndex = 52
		iconImage.Parent = iconFrame
	end
	
	-- Item name (white, next to icon)
	local nameLabel = Instance.new("TextLabel")
	nameLabel.Name = "ItemName"
	nameLabel.Size = UDim2.new(0, 180, 0, 22)
	nameLabel.Position = UDim2.new(0, 70, 0, 10)
	nameLabel.BackgroundTransparency = 1
	nameLabel.Text = itemConfig.name
	nameLabel.TextColor3 = Color3.new(1, 1, 1)
	nameLabel.TextSize = 16
	nameLabel.TextXAlignment = Enum.TextXAlignment.Left
	nameLabel.Font = Enum.Font.GothamBold
	nameLabel.ZIndex = 51
	nameLabel.Parent = State.itemInfoPopup
	
	-- Weight (below name)
	local weightLabel = Instance.new("TextLabel")
	weightLabel.Name = "WeightLabel"
	weightLabel.Size = UDim2.new(0, 180, 0, 16)
	weightLabel.Position = UDim2.new(0, 70, 0, 34)
	weightLabel.BackgroundTransparency = 1
	weightLabel.Text = "Weight: " .. (itemConfig.weight or "1.0") .. " kg"
	weightLabel.TextColor3 = Color3.fromRGB(150, 150, 180)
	weightLabel.TextSize = 12
	weightLabel.TextXAlignment = Enum.TextXAlignment.Left
	weightLabel.Font = Enum.Font.Gotham
	weightLabel.ZIndex = 51
	weightLabel.Parent = State.itemInfoPopup
	
	-- Divider
	local divider = Instance.new("Frame")
	divider.Name = "Divider"
	divider.Size = UDim2.new(1, -20, 0, 1)
	divider.Position = UDim2.new(0, 10, 0, 65)
	divider.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
	divider.BorderSizePixel = 0
	divider.ZIndex = 51
	divider.Parent = State.itemInfoPopup
	
	-- Description (below divider)
	local descLabel = Instance.new("TextLabel")
	descLabel.Name = "Description"
	descLabel.Size = UDim2.new(1, -20, 0, 25)
	descLabel.Position = UDim2.new(0, 10, 0, 70)
	descLabel.BackgroundTransparency = 1
	descLabel.Text = itemConfig.description or "No description available."
	descLabel.TextColor3 = Color3.fromRGB(180, 180, 200)
	descLabel.TextSize = 11
	descLabel.TextXAlignment = Enum.TextXAlignment.Left
	descLabel.TextWrapped = true
	descLabel.Font = Enum.Font.Gotham
	descLabel.ZIndex = 51
	descLabel.Parent = State.itemInfoPopup
	
	-- Close on click
	State.itemInfoPopup.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			closeItemInfoPopup()
		end
	end)
end

-- ============================================================================
-- SELECTION SYSTEM (Click-to-Select)
-- ============================================================================

local function clearSelection()
	if State.selectionHighlight and State.selectionHighlight.Parent then
		State.selectionHighlight:Destroy()
		State.selectionHighlight = nil
	end
	State.selectedItem = nil
	updateActionBar(nil)  -- Hide action bar
end

local function selectItem(itemData)
	-- Play selected sound
	local soundService = game:GetService("SoundService")
	local selectedSound = soundService:FindFirstChild("Selected")
	if selectedSound and selectedSound:IsA("Sound") then
		selectedSound:Play()
	end
	
	-- Clear previous selection
	clearSelection()
	
	State.selectedItem = itemData
	
	-- Create yellow selection highlight on the item frame
	State.selectionHighlight = Instance.new("Frame")
	State.selectionHighlight.Name = "SelectionHighlight"
	State.selectionHighlight.Size = UDim2.new(1, 0, 1, 0)  -- Same size as item frame
	State.selectionHighlight.Position = UDim2.new(0, 0, 0, 0)  -- Aligned with item frame
	State.selectionHighlight.BackgroundTransparency = 1
	State.selectionHighlight.BorderSizePixel = 0
	State.selectionHighlight.ZIndex = 20 -- Higher than icon (16)
	State.selectionHighlight.Parent = itemData.frame
	
	
	local highlightStroke = Instance.new("UIStroke")
	highlightStroke.Name = "SelectionStroke"
	highlightStroke.Color = Color3.fromRGB(255, 220, 100)  -- Yellow
	highlightStroke.Thickness = 1
	highlightStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
	highlightStroke.Parent = State.selectionHighlight
	
	-- Pulse animation for selection
	local function pulseAnimation()
		if not State.selectionHighlight or not State.selectionHighlight.Parent then return end
		local stroke = State.selectionHighlight:FindFirstChild("SelectionStroke")
		if stroke then
			Services.TweenService:Create(stroke, TweenInfo.new(0.5, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {
				Thickness = 4
			}):Play()
			task.delay(0.5, function()
				if stroke and stroke.Parent then
					Services.TweenService:Create(stroke, TweenInfo.new(0.5, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {
						Thickness = 2
					}):Play()
				end
			end)
		end
	end
	pulseAnimation()
	
	-- Update action bar with selected item
	updateActionBar(itemData)
	
	-- Highlight compatible armor slots if this is armor
	local itemConfig = itemData.config
	if itemConfig and itemConfig.isArmor and itemConfig.slotType then
		-- Highlight the compatible slot (only if not already equipped)
		for slotName, slotData in pairs(Data.armorSlots) do
			if slotName == itemConfig.slotType then
				-- This slot is compatible - but only highlight if NOT already equipped
				if not slotData.equipped then
					slotData.stroke.Color = Color3.fromRGB(100, 255, 100)
					Services.TweenService:Create(slotData.stroke, TweenInfo.new(0.3), {
						Thickness = 3
					}):Play()
				end
				-- If already equipped, don't highlight (keep current state)
			else
				-- Reset non-compatible slots
				if not slotData.equipped then
					slotData.stroke.Color = Color3.fromRGB(80, 80, 120)
					slotData.stroke.Thickness = 1
				end
			end
		end
	else
		-- Not armor - reset all slot highlights
		for slotName, slotData in pairs(Data.armorSlots) do
			if not slotData.equipped then
				slotData.stroke.Color = Color3.fromRGB(80, 80, 120)
				slotData.stroke.Thickness = 1
			end
		end
	end
end

-- SMART PLACEMENT: Find best position for item at target cell (with rotation)
-- Now searches UPWARD and LEFTWARD first, so clicking bottom of 1x4 space still works
local function findBestPlacement(itemData, targetRow, targetCol)
	local width = itemData.width
	local height = itemData.height
	local itemId = itemData.config.id
	
	-- Try 1: Current orientation at target (exact position)
	if canPlaceItem(width, height, targetRow, targetCol, itemId) then
		return targetRow, targetCol, width, height, false
	end
	
	-- Try 2: Rotated orientation at target (exact position)
	if canPlaceItem(height, width, targetRow, targetCol, itemId) then
		return targetRow, targetCol, height, width, true
	end
	
	-- Try 3: Search nearby with NEGATIVE offsets prioritized
	-- For 2x2 clicking cell 4 (row 2, col 2), we need to find (row 1, col 1)
	local maxOffset = math.max(width, height)
	
	-- Search all combinations: prioritize small offsets first
	for totalOffset = 1, maxOffset * 2 do
		for offsetR = 0, math.min(totalOffset, maxOffset) do
			local offsetC = totalOffset - offsetR
			if offsetC <= maxOffset then
				-- Try all sign combinations: (-,-), (-,+), (+,-), (+,+)
				for _, signR in ipairs({-1, 1}) do
					for _, signC in ipairs({-1, 1}) do
						local tryRow = targetRow + (offsetR * signR)
						local tryCol = targetCol + (offsetC * signC)
						
						-- Try current orientation
						if canPlaceItem(width, height, tryRow, tryCol, itemId) then
							return tryRow, tryCol, width, height, false
						end
						
						-- Try rotated
						if canPlaceItem(height, width, tryRow, tryCol, itemId) then
							return tryRow, tryCol, height, width, true
						end
					end
				end
			end
		end
	end
	
	return nil, nil, nil, nil, nil  -- No valid position found
end

-- Move selected item to target position (smart)
local function moveSelectedItemTo(targetRow, targetCol)
	if not State.selectedItem then return false end
	
	local itemData = State.selectedItem
	local itemId = itemData.config.id
	
	-- Remove from current position
	removeItemFromGrid(itemId)
	
	-- Find best placement
	local newRow, newCol, newWidth, newHeight, rotated = findBestPlacement(itemData, targetRow, targetCol)
	
	if newRow then
		-- Place at new position
		placeItemInGrid(itemId, newWidth, newHeight, newRow, newCol)
		
		-- Update item data
		itemData.row = newRow
		itemData.col = newCol
		itemData.width = newWidth
		itemData.height = newHeight
		if rotated then
			itemData.rotated = not itemData.rotated
		end
		
		-- Update visual
		itemData.frame.Size = UDim2.new(0, newWidth * Config.CELL_SIZE + (newWidth - 1) * Config.CELL_PADDING, 0, newHeight * Config.CELL_SIZE + (newHeight - 1) * Config.CELL_PADDING)
		itemData.frame.Position = UDim2.new(0, (newCol - 1) * (Config.CELL_SIZE + Config.CELL_PADDING), 0, (newRow - 1) * (Config.CELL_SIZE + Config.CELL_PADDING))
		
		-- Flash effect if rotated
		if rotated then
			local stroke = itemData.frame:FindFirstChild("ItemStroke")
			if stroke then
				local originalColor = stroke.Color
				stroke.Color = Color3.fromRGB(255, 255, 100)
				Services.TweenService:Create(stroke, TweenInfo.new(0.3), { Color = originalColor }):Play()
			end
		end
		
		-- Clear selection after successful move (deselect item)
		clearSelection()
		
		-- Fire Server Event to save position (Fixes Revert Bug)
		local updateEvent = Services.ReplicatedStorage:FindFirstChild("Remotes") and Services.ReplicatedStorage.Remotes:FindFirstChild("UpdateItemPosition")
		if updateEvent then
			updateEvent:FireServer(itemId, newRow, newCol, rotated)
		end
		
		return true
	else
		-- Couldn't place, restore original position
		placeItemInGrid(itemId, itemData.width, itemData.height, itemData.row, itemData.col)
		-- Clear any highlight that was shown
		clearHighlights()
		return false
	end
end

-- ============================================================================
-- DRAG AND DROP SYSTEM
-- ============================================================================

local function createDragGhost(itemData)
	local ghost = itemData.frame:Clone()
	ghost.Name = "DragGhost"
	ghost.ZIndex = 100
	ghost.BackgroundTransparency = 0.3
	ghost.Parent = UI.screenGui
	
	-- Add a UIScale to the ghost so we can control its size independently
	local ghostScale = Instance.new("UIScale")
	ghostScale.Name = "GhostScale"
	ghostScale.Scale = 1  -- Will be updated in startDrag
	ghostScale.Parent = ghost
	
	-- Make it follow cursor at absolute position
	ghost.AnchorPoint = Vector2.new(0.5, 0.5)
	
	return ghost
end

local function startDrag(itemId, inputPos)
	local itemData = Data.inventoryItems[itemId]
	if not itemData then return end
	
	-- Disable scrolling during drag (MOBILE TOUCH ONLY improvement)
	if UI.contentScroll and (State.activeTouchId or Services.UserInputService:GetLastInputType() == Enum.UserInputType.Touch) then
		UI.contentScroll.ScrollingEnabled = false
	end
	
	State.isDragging = true
	State.draggedItem = itemData
	State.dragSource = "inventory"
	State.dragSourceChestData = nil
	State.originalSlot = { row = itemData.row, col = itemData.col, width = itemData.width, height = itemData.height }
	
	selectItem(itemData)
	
	-- Create ghost (AnchorPoint 0.5, 0.5 in createDragGhost)
	State.dragGhost = createDragGhost(itemData)
	
	-- Position ghost CENTERED on mouse/touch using absolute location
	local scale = UI.uiScale.Scale
	local panelScale = UI.panelScale.Scale
	local mouseLoc = Services.UserInputService:GetMouseLocation()
	
	State.dragGhost.Position = UDim2.new(0, mouseLoc.X / scale, 0, mouseLoc.Y / scale)
	State.dragGhost.GhostScale.Scale = panelScale
	
	-- Hide original frame
	itemData.frame.Visible = false
	
	highlightOriginalSlot(State.originalSlot.row, State.originalSlot.col, State.originalSlot.width, State.originalSlot.height)
	removeItemFromGrid(itemId)
end

-- Start drag for a chest item
local function startChestDrag(chestItemData, itemFrame, inputPos)
	local tempItemData = {
		config = {
			id = chestItemData.id,
			name = chestItemData.name,
			icon = chestItemData.icon,
			weight = chestItemData.weight,
			price = chestItemData.price,
			rarity = chestItemData.rarity,
		},
		row = chestItemData.row,
		col = chestItemData.col,
		width = chestItemData.width,
		height = chestItemData.height,
		frame = itemFrame,
	}
	
	if UI.contentScroll and (State.activeTouchId or Services.UserInputService:GetLastInputType() == Enum.UserInputType.Touch) then
		UI.contentScroll.ScrollingEnabled = false
	end
	
	State.isDragging = true
	State.draggedItem = tempItemData
	State.dragSource = "chest"
	State.dragSourceChestData = chestItemData
	State.originalSlot = { row = chestItemData.row, col = chestItemData.col, width = chestItemData.width, height = chestItemData.height }
	
	State.dragGhost = createDragGhost(tempItemData)
	
	local scale = UI.uiScale.Scale
	local panelScale = UI.panelScale.Scale
	local mouseLoc = Services.UserInputService:GetMouseLocation()
	
	State.dragGhost.Position = UDim2.new(0, mouseLoc.X / scale, 0, mouseLoc.Y / scale)
	State.dragGhost.GhostScale.Scale = panelScale
	
	itemFrame.Visible = false
	highlightChestOriginalSlot(chestItemData.row, chestItemData.col, chestItemData.width, chestItemData.height)
	removeItemFromChestGrid(chestItemData.id)
end

local function startStorageDrag(storageItemData, itemFrame, inputPos)
	local tempItemData = {
		config = {
			id = storageItemData.id,
			name = storageItemData.name,
			icon = storageItemData.icon,
			weight = storageItemData.weight,
			price = storageItemData.price,
			rarity = storageItemData.rarity,
		},
		row = storageItemData.row,
		col = storageItemData.col,
		width = storageItemData.width,
		height = storageItemData.height,
		frame = itemFrame,
	}
	
	if UI.contentScroll and (State.activeTouchId or Services.UserInputService:GetLastInputType() == Enum.UserInputType.Touch) then
		UI.contentScroll.ScrollingEnabled = false
	end
	
	State.isDragging = true
	State.draggedItem = tempItemData
	State.dragSource = "storage"
	State.dragSourceChestData = nil -- Not chest
	State.originalSlot = { row = storageItemData.row, col = storageItemData.col, width = storageItemData.width, height = storageItemData.height }
	
	State.dragGhost = createDragGhost(tempItemData)
	
	local scale = UI.uiScale.Scale
	local panelScale = UI.panelScale.Scale
	local mouseLoc = Services.UserInputService:GetMouseLocation()
	
	State.dragGhost.Position = UDim2.new(0, mouseLoc.X / scale, 0, mouseLoc.Y / scale)
	State.dragGhost.GhostScale.Scale = panelScale
	
	itemFrame.Visible = false
	highlightStorageOriginalSlot(storageItemData.row, storageItemData.col, storageItemData.width, storageItemData.height)
	removeItemFromStorageGrid(storageItemData.id)
end

local function updateDrag()
	if not State.isDragging or not State.dragGhost then return end
	
	-- Use absolute mouse location for accuracy with IgnoreGuiInset
	local mousePos = Services.UserInputService:GetMouseLocation()
	local scale = UI.uiScale.Scale
	
	-- Position ghost CENTERED on cursor (Absolute scale)
	State.dragGhost.Position = UDim2.new(0, mousePos.X / scale, 0, mousePos.Y / scale)
	
	-- =====================================================
	-- AUTO-SCROLL DURING DRAG
	-- =====================================================
	local scrollAbsPos = UI.contentScroll.AbsolutePosition
	local scrollAbsSize = UI.contentScroll.AbsoluteSize
	local scrollTop = scrollAbsPos.Y
	local scrollBottom = scrollAbsPos.Y + scrollAbsSize.Y
	
	local dragY = mousePos.Y
	
	-- Calculate intensity and direction for auto-scroll
	local topEdge = scrollTop + Config.DRAG_SCROLL_EDGE_TOP
	local bottomEdge = scrollBottom - Config.DRAG_SCROLL_EDGE_BOTTOM
	
	if dragY < topEdge and dragY > (scrollTop - 50) then
		local intensity = math.clamp(1 - ((dragY - scrollTop) / Config.DRAG_SCROLL_EDGE_TOP), 0, 1)
		local scrollAmount = Config.DRAG_SCROLL_SPEED * intensity
		local newY = math.max(0, UI.contentScroll.CanvasPosition.Y - scrollAmount)
		UI.contentScroll.CanvasPosition = Vector2.new(UI.contentScroll.CanvasPosition.X, newY)
		State.isAutoScrolling = true
	elseif dragY > bottomEdge and dragY < (scrollBottom + 50) then
		local intensity = math.clamp((dragY - bottomEdge) / Config.DRAG_SCROLL_EDGE_BOTTOM, 0, 1)
		local scrollAmount = Config.DRAG_SCROLL_SPEED * intensity
		local maxY = math.max(0, UI.contentScroll.CanvasSize.Y.Offset - scrollAbsSize.Y)
		local newY = math.min(maxY, UI.contentScroll.CanvasPosition.Y + scrollAmount)
		UI.contentScroll.CanvasPosition = Vector2.new(UI.contentScroll.CanvasPosition.X, newY)
		State.isAutoScrolling = true
	else
		State.isAutoScrolling = false
	end
	
	State.lastDragPosition = mousePos
	
	-- Grid Logic: Use ghost's AbsolutePosition (Top-Left corner)
	local ghostAbsPos = State.dragGhost.AbsolutePosition
	local width = State.draggedItem.width
	local height = State.draggedItem.height
	local itemId = State.draggedItem.config.id
	
	local containerPos = UI.gridContainer.AbsolutePosition
	local containerSize = UI.gridContainer.AbsoluteSize
	local scaledCellSize = (Config.CELL_SIZE + Config.CELL_PADDING) * scale
	
	local relX = ghostAbsPos.X - containerPos.X
	local relY = ghostAbsPos.Y - containerPos.Y
	local col = math.floor(relX / scaledCellSize + 0.5) + 1
	local row = math.floor(relY / scaledCellSize + 0.5) + 1
	
	local isOverInventory = ghostAbsPos.X >= containerPos.X and ghostAbsPos.X <= (containerPos.X + containerSize.X)
		and ghostAbsPos.Y >= containerPos.Y and ghostAbsPos.Y <= (containerPos.Y + containerSize.Y)
	
	local isOverChest = false
	local chestRow, chestCol = 1, 1
	if UI.ChestContainer.Visible and UI.gridContainerChest then
		local chestContainerPos = UI.gridContainerChest.AbsolutePosition
		local chestContainerSize = UI.gridContainerChest.AbsoluteSize
		-- Use dynamic cell size (same as used in recreateChestGrid)
		local chestScaledCellSize = (Config.CHEST.CELL_SIZE + Config.CHEST.CELL_PADDING) * scale
		
		local chestRelX = ghostAbsPos.X - chestContainerPos.X
		local chestRelY = ghostAbsPos.Y - chestContainerPos.Y
		chestCol = math.floor(chestRelX / chestScaledCellSize + 0.5) + 1
		chestRow = math.floor(chestRelY / chestScaledCellSize + 0.5) + 1
		
		isOverChest = ghostAbsPos.X >= chestContainerPos.X and ghostAbsPos.X <= chestContainerPos.X + chestContainerSize.X
			and ghostAbsPos.Y >= chestContainerPos.Y and ghostAbsPos.Y <= chestContainerPos.Y + chestContainerSize.Y
	end
	
	-- Track which grid we're targeting
	State.dragTargetGrid = nil
	State.dragTargetRow = nil
	State.dragTargetCol = nil
	
	if isOverInventory then
		State.dragTargetGrid = "inventory"
		State.dragTargetRow = row
		State.dragTargetCol = col
		
		-- Clear chest/storage highlights when over inventory
		clearChestHighlights()
		clearStorageHighlights()
		
		-- Check if within inventory bounds
		local isOutsideGrid = row < 1 or col < 1 or row > Config.GRID_ROWS or col > Config.GRID_COLS
		if isOutsideGrid then
			clearHighlights()
			return
		end
		
		local canPlace = canPlaceItem(width, height, row, col, itemId)
		local finalWidth, finalHeight = width, height
		
		if not canPlace then
			canPlace = canPlaceItem(height, width, row, col, itemId)
			if canPlace then
				finalWidth, finalHeight = height, width
			end
		end
		
		if canPlace then
			highlightSlots(row, col, finalWidth, finalHeight, true)
		else
			clearHighlights()
		end
	elseif isOverChest then
		State.dragTargetGrid = "chest"
		State.dragTargetRow = chestRow
		State.dragTargetCol = chestCol
		
		clearHighlights()
		clearStorageHighlights()
		
		-- Use dynamic chest config for bounds checking
		local chestConf = State.currentChestConfig or { gridRows = 6, gridCols = 6 }
		local isOutsideChestGrid = chestRow < 1 or chestCol < 1 or chestRow > chestConf.gridRows or chestCol > chestConf.gridCols
		if isOutsideChestGrid then
			clearChestHighlights()
			return
		end
		
		local canPlace = canPlaceItemInChest(width, height, chestRow, chestCol, itemId)
		local finalWidth, finalHeight = width, height
		
		if not canPlace then
			canPlace = canPlaceItemInChest(height, width, chestRow, chestCol, itemId)
			if canPlace then
				finalWidth, finalHeight = height, width
			end
		end
		
		if canPlace then
			highlightChestSlots(chestRow, chestCol, finalWidth, finalHeight, true)
		else
			clearChestHighlights()
		end
	elseif State.isStorageOpen and UI.storageGridFrame then
		-- Check storage grid overlap
		local storageContainerPos = UI.storageGridFrame.AbsolutePosition
		local storageContainerSize = UI.storageGridFrame.AbsoluteSize
		local storageScaledCellSize = (Config.STORAGE.CELL_SIZE + Config.STORAGE.CELL_PADDING) * scale
		
		local storageRelX = ghostAbsPos.X - storageContainerPos.X
		local storageRelY = ghostAbsPos.Y - storageContainerPos.Y
		local storageCol = math.floor(storageRelX / storageScaledCellSize + 0.5) + 1
		local storageRow = math.floor(storageRelY / storageScaledCellSize + 0.5) + 1
		
		local isOverStorage = ghostAbsPos.X >= storageContainerPos.X and ghostAbsPos.X <= storageContainerPos.X + storageContainerSize.X
			and ghostAbsPos.Y >= storageContainerPos.Y and ghostAbsPos.Y <= storageContainerPos.Y + storageContainerSize.Y
			
		if isOverStorage then
			State.dragTargetGrid = "storage"
			State.dragTargetRow = storageRow
			State.dragTargetCol = storageCol
			
			clearHighlights()
			clearChestHighlights()
			
			local isOutsideStorageGrid = storageRow < 1 or storageCol < 1 or storageRow > Config.STORAGE.GRID_ROWS or storageCol > Config.STORAGE.GRID_COLS
			if isOutsideStorageGrid then
				clearStorageHighlights()
				return
			end
			
			local canPlace = canPlaceItemInStorage(width, height, storageRow, storageCol, itemId)
			local finalWidth, finalHeight = width, height
			
			if not canPlace then
				canPlace = canPlaceItemInStorage(height, width, storageRow, storageCol, itemId)
				if canPlace then
					finalWidth, finalHeight = height, width
				end
			end
			
			if canPlace then
				highlightStorageSlots(storageRow, storageCol, finalWidth, finalHeight, true)
			else
				clearStorageHighlights()
			end
		else
			clearHighlights()
			clearChestHighlights()
			clearStorageHighlights()
		end
	else
		clearHighlights()
		clearChestHighlights()
		clearStorageHighlights()
	end
end

-- Continuous auto-scroll while dragging (runs every frame)
Services.RunService.Heartbeat:Connect(function()
	if State.isDragging and State.isAutoScrolling and State.autoScrollDirection ~= 0 then
		local scrollAbsSize = UI.contentScroll.AbsoluteSize
		local scrollAmount = Config.DRAG_SCROLL_SPEED * State.autoScrollIntensity
		
		if State.autoScrollDirection == -1 then
			-- Scroll UP continuously
			local newY = math.max(0, UI.contentScroll.CanvasPosition.Y - scrollAmount)
			UI.contentScroll.CanvasPosition = Vector2.new(UI.contentScroll.CanvasPosition.X, newY)
		elseif State.autoScrollDirection == 1 then
			-- Scroll DOWN continuously
			local maxY = math.max(0, UI.contentScroll.CanvasSize.Y.Offset - scrollAbsSize.Y)
			local newY = math.min(maxY, UI.contentScroll.CanvasPosition.Y + scrollAmount)
			UI.contentScroll.CanvasPosition = Vector2.new(UI.contentScroll.CanvasPosition.X, newY)
		end
	end
end)

local function endDrag(inputPos)
	if not State.isDragging or not State.draggedItem or not State.dragGhost then return end
	
	-- Re-enable scrolling after drag (Mobile improvement)
	if UI.contentScroll then
		UI.contentScroll.ScrollingEnabled = true
	end
	
	-- Reset auto-scroll state
	State.isAutoScrolling = false
	State.autoScrollDirection = 0
	State.autoScrollIntensity = 0
	State.lastDragPosition = nil
	
	local width = State.draggedItem.width
	local height = State.draggedItem.height
	local rotated = State.draggedItem.rotated or false
	
	-- Use the target grid tracked during updateDrag
	local targetGrid = State.dragTargetGrid
	local row = State.dragTargetRow or 1
	local col = State.dragTargetCol or 1
	
	local placed = false
	local newWidth, newHeight = width, height
	
	if targetGrid == "inventory" then
		-- Check if can place in inventory
		if canPlaceItem(width, height, row, col, State.draggedItem.config.id) then
			placed = true
			newWidth, newHeight = width, height
		elseif canPlaceItem(height, width, row, col, State.draggedItem.config.id) then
			placed = true
			newWidth, newHeight = height, width
			rotated = not rotated
		end
	elseif targetGrid == "chest" then
		-- Check if can place in chest
		if canPlaceItemInChest(width, height, row, col, State.draggedItem.config.id) then
			placed = true
			newWidth, newHeight = width, height
		elseif canPlaceItemInChest(height, width, row, col, State.draggedItem.config.id) then
			placed = true
			newWidth, newHeight = height, width
			rotated = not rotated
		end
	elseif targetGrid == "storage" then
		-- Check if can place in storage
		if canPlaceItemInStorage(width, height, row, col, State.draggedItem.config.id) then
			placed = true
			newWidth, newHeight = width, height
		elseif canPlaceItemInStorage(height, width, row, col, State.draggedItem.config.id) then
			placed = true
			newWidth, newHeight = height, width
			rotated = not rotated
		end
	end
	
	if placed then
		if targetGrid == "inventory" then
			if State.dragSource == "chest" then
				-- Chest to inventory - collect item at specific position
				local collectEvent = Services.ReplicatedStorage:FindFirstChild("Remotes") and Services.ReplicatedStorage.Remotes:FindFirstChild("CollectItemAtPosition")
				if collectEvent then
					local chestPos = State.currentChestModel and State.currentChestModel.PrimaryPart and State.currentChestModel.PrimaryPart.Position
					-- Pass: itemName, chestPos, targetRow, targetCol, rotated
					local wasRotated = (newWidth ~= State.dragSourceChestData.width)
					collectEvent:FireServer(State.dragSourceChestData.name, chestPos, row, col, wasRotated)
				end
				if State.draggedItem.frame then
					State.draggedItem.frame:Destroy()
				end
				if chestLootItems and State.dragSourceChestData then
					chestLootItems[State.dragSourceChestData.id] = nil
				end
				if Data.chestItems and State.dragSourceChestData then
					Data.chestItems[State.dragSourceChestData.id] = nil
				end
			elseif State.dragSource == "storage" then
				-- Storage to Inventory
				local moveEvent = Services.ReplicatedStorage:FindFirstChild("Remotes") and Services.ReplicatedStorage.Remotes:FindFirstChild("MoveToInventory")
				if moveEvent then
					moveEvent:FireServer(State.draggedItem.config.id, row, col)
				end
				
				-- Optimistic cleanup from Storage
				if State.draggedItem.frame then
					State.draggedItem.frame:Destroy()
				end
				if Data.storageItems and Data.storageItems[State.draggedItem.config.id] then
					Data.storageItems[State.draggedItem.config.id] = nil
					removeItemFromStorageGrid(State.draggedItem.config.id)
				end
			else
				-- Inventory to inventory drag
				placeItemInGrid(State.draggedItem.config.id, newWidth, newHeight, row, col)
				
				State.draggedItem.row = row
				State.draggedItem.col = col
				State.draggedItem.width = newWidth
				State.draggedItem.height = newHeight
				State.draggedItem.rotated = rotated
				
				State.draggedItem.frame.Size = UDim2.new(0, newWidth * Config.CELL_SIZE + (newWidth - 1) * Config.CELL_PADDING, 0, newHeight * Config.CELL_SIZE + (newHeight - 1) * Config.CELL_PADDING)
				State.draggedItem.frame.Position = UDim2.new(0, (col - 1) * (Config.CELL_SIZE + Config.CELL_PADDING), 0, (row - 1) * (Config.CELL_SIZE + Config.CELL_PADDING))
				State.draggedItem.frame.Visible = true
				
				if newWidth ~= State.originalSlot.width or newHeight ~= State.originalSlot.height then
					local stroke = State.draggedItem.frame:FindFirstChild("ItemStroke")
					if stroke then
						local originalColor = stroke.Color
						stroke.Color = Color3.fromRGB(255, 255, 100)
						Services.TweenService:Create(stroke, TweenInfo.new(0.3), { Color = originalColor }):Play()
					end
				end
			end
		elseif targetGrid == "chest" then
			-- Placing in chest (chest-to-chest reposition)
			if State.dragSource == "chest" then
				-- Update chest grid data
				placeItemInChestGrid(State.draggedItem.config.id, newWidth, newHeight, row, col)
				
				-- Update the chest item data
				State.dragSourceChestData.row = row
				State.dragSourceChestData.col = col
				State.dragSourceChestData.width = newWidth
				State.dragSourceChestData.height = newHeight
				
				-- Update visual
				State.draggedItem.frame.Size = UDim2.new(0, newWidth * Config.CHEST.CELL_SIZE + (newWidth - 1) * Config.CHEST.CELL_PADDING, 0, newHeight * Config.CHEST.CELL_SIZE + (newHeight - 1) * Config.CHEST.CELL_PADDING)
				State.draggedItem.frame.Position = UDim2.new(0, (col - 1) * (Config.CHEST.CELL_SIZE + Config.CHEST.CELL_PADDING), 0, (row - 1) * (Config.CHEST.CELL_SIZE + Config.CHEST.CELL_PADDING))
				State.draggedItem.frame.Visible = true
				
				-- Sync position to server
				local updateEvent = Services.ReplicatedStorage:FindFirstChild("Remotes") and Services.ReplicatedStorage.Remotes:FindFirstChild("UpdateChestItemPosition")
				if updateEvent and State.currentChestModel then
					updateEvent:FireServer(State.dragSourceChestData.id, State.currentChestModel, row, col, newWidth, newHeight)
				end
				
				-- Flash animation if rotated
				if newWidth ~= State.originalSlot.width or newHeight ~= State.originalSlot.height then
					local stroke = State.draggedItem.frame:FindFirstChild("ItemStroke")
					if stroke then
						local originalColor = stroke.Color
						stroke.Color = Color3.fromRGB(255, 255, 100)
						Services.TweenService:Create(stroke, TweenInfo.new(0.3), { Color = originalColor }):Play()
					end
				end
			elseif State.dragSource == "storage" then
				-- Storage to Chest - deposit item
				local depositEvent = Services.ReplicatedStorage:FindFirstChild("Remotes") and Services.ReplicatedStorage.Remotes:FindFirstChild("DepositItemToChest")
				if depositEvent and State.currentChestModel then
					local uniqueItemId = State.draggedItem.config.id
					depositEvent:FireServer(uniqueItemId, State.currentChestModel, row, col, width, height)
				end
				
				-- Remove from local STORAGE data
				if State.draggedItem.frame then
					State.draggedItem.frame:Destroy()
				end
				if Data.storageItems and Data.storageItems[State.draggedItem.config.id] then
					Data.storageItems[State.draggedItem.config.id] = nil
					removeItemFromStorageGrid(State.draggedItem.config.id)
				end
			else
				-- Inventory to chest - deposit item
				-- Fire event to tell server to move this item to chest
				-- Send unique instanceId (config.id) which matches server's item.id
				local depositEvent = Services.ReplicatedStorage:FindFirstChild("Remotes") and Services.ReplicatedStorage.Remotes:FindFirstChild("DepositItemToChest")
				if depositEvent and State.currentChestModel then
					-- Use unique instanceId for exact matching (e.g., "Bandage_12345678_1")
					local uniqueItemId = State.draggedItem.config.id
					-- Pass current width/height to fix auto-rotate bug
					-- Pass chestModel INSTANCE to resolve ambiguity
					depositEvent:FireServer(uniqueItemId, State.currentChestModel, row, col, width, height)
				end
				-- Server will sync both inventory and chest back, so just destroy frame for now
				if State.draggedItem.frame then
					State.draggedItem.frame:Destroy()
				end
				-- Remove from local inventory data  
				if Data.inventoryItems then
					Data.inventoryItems[State.draggedItem.config.id] = nil
					removeItemFromGrid(State.draggedItem.config.id)
				end
			end
		elseif targetGrid == "storage" then
			if State.dragSource == "storage" then
				-- Storage to Storage (Move within storage)
				placeItemInStorageGrid(State.draggedItem.config.id, newWidth, newHeight, row, col)
				
				-- Update logical data
				if Data.storageItems[State.draggedItem.config.id] then
					Data.storageItems[State.draggedItem.config.id].row = row
					Data.storageItems[State.draggedItem.config.id].col = col
					Data.storageItems[State.draggedItem.config.id].width = newWidth
					Data.storageItems[State.draggedItem.config.id].height = newHeight
				end
				
				-- Update visual
				State.draggedItem.frame.Size = UDim2.new(0, newWidth * Config.STORAGE.CELL_SIZE + (newWidth - 1) * Config.STORAGE.CELL_PADDING, 0, newHeight * Config.STORAGE.CELL_SIZE + (newHeight - 1) * Config.STORAGE.CELL_PADDING)
				State.draggedItem.frame.Position = UDim2.new(0, (col - 1) * (Config.STORAGE.CELL_SIZE + Config.STORAGE.CELL_PADDING), 0, (row - 1) * (Config.STORAGE.CELL_SIZE + Config.STORAGE.CELL_PADDING))
				State.draggedItem.frame.Visible = true
				
				-- Fire server event update storage position (TODO: implement UpdateStoragePosition if needed, for now move works implicitly)
				-- Actually better to fire MoveToStorage logic with updated coordinates if we treat it as re-move? No, we need UpdateStorageItemPosition.
				-- For now, let's just assume MoveToStorage handles updates or add UpdateStorageItemPosition later.
				-- Wait, Implementation Plan says "Update MoveToStorage to accept targetRow/Col". So we use that.
				
				if Events.MoveToStorage then
					Events.MoveToStorage:FireServer(State.draggedItem.config.id, row, col)
				end
				
			else
				-- Inventory to Storage
				if Events.MoveToStorage then
					Events.MoveToStorage:FireServer(State.draggedItem.config.id, row, col)
				end
				
				if State.draggedItem.frame then
					State.draggedItem.frame:Destroy()
				end
				if Data.inventoryItems then
					Data.inventoryItems[State.draggedItem.config.id] = nil
					removeItemFromGrid(State.draggedItem.config.id)
				end
			end
		end
	else
		-- Return to original position
		if State.dragSource == "chest" then
			-- Place back in chest grid
			placeItemInChestGrid(State.draggedItem.config.id, State.originalSlot.width, State.originalSlot.height, State.originalSlot.row, State.originalSlot.col)
			if State.draggedItem.frame then
				State.draggedItem.frame.Visible = true
			end
		elseif State.dragSource == "storage" then
			-- Place back in storage grid
			placeItemInStorageGrid(State.draggedItem.config.id, State.originalSlot.width, State.originalSlot.height, State.originalSlot.row, State.originalSlot.col)
			if State.draggedItem.frame then
				State.draggedItem.frame.Visible = true
			end
		else
			-- Return inventory item to original
			placeItemInGrid(State.draggedItem.config.id, State.originalSlot.width, State.originalSlot.height, State.originalSlot.row, State.originalSlot.col)
			State.draggedItem.row = State.originalSlot.row
			State.draggedItem.col = State.originalSlot.col
			State.draggedItem.width = State.originalSlot.width
			State.draggedItem.height = State.originalSlot.height
			State.draggedItem.frame.Visible = true
		end
	end
	
	-- Cleanup
	if State.dragGhost then
		State.dragGhost:Destroy()
		State.dragGhost = nil
	end
	
	clearHighlights()
	clearChestHighlights()
	clearStorageHighlights()
	
	if State.dragSource == "inventory" then
		resetOriginalSlotHighlight(State.originalSlot.row, State.originalSlot.col, State.originalSlot.width, State.originalSlot.height)
	elseif State.dragSource == "chest" then
		resetChestOriginalSlotHighlight()
	elseif State.dragSource == "storage" then
		resetStorageOriginalSlotHighlight()
	end
	
	State.isDragging = false
	State.draggedItem = nil
	State.dragSource = nil
	State.dragSourceChestData = nil
	State.dragTargetGrid = nil
	State.dragTargetRow = nil
	State.dragTargetCol = nil
end

-- ============================================================================
-- INPUT HANDLING
-- ============================================================================

State.activeTouchId = nil  -- Track active touch to prevent multiple drags
State.tapStartTime = 0
State.tapStartPos = Vector2.new(0, 0)
Config.TAP_THRESHOLD_TIME = 0.2  -- seconds
Config.TAP_THRESHOLD_DISTANCE = 10  -- pixels

local function setupItemInput(itemFrame, itemId)
	local dragStarted = false
	local isMouseDown = false  -- Track if mouse/touch is currently pressed
	local longPressThread = nil  -- For long-press detection
	local lastTapTime = 0  -- For double-tap detection (deposit to chest)

	
	-- Handle input began on item frame
	itemFrame.InputBegan:Connect(function(input, gameProcessed)
		-- Prevent if already dragging
		if State.isDragging then return end
		
	if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			local currentItemData = Data.inventoryItems[itemId]
			
			-- Record tap start
			isMouseDown = true  -- Mark as pressed
			State.tapStartTime = tick()
			State.tapStartPos = Vector2.new(input.Position.X, input.Position.Y)
			dragStarted = false
			
			-- Start long-press timer for info popup
			if currentItemData then
				longPressThread = task.spawn(function()
					task.wait(Config.LONG_PRESS_DURATION)
					-- Only show if still pressed and not dragging
					if isMouseDown and not dragStarted and not State.isDragging then
						showItemInfoPopup(currentItemData)
					end
				end)
			end
			
			if input.UserInputType == Enum.UserInputType.Touch then
				State.activeTouchId = input
			end
		end
	end)
	
	itemFrame.InputChanged:Connect(function(input, gameProcessed)
		if State.isDragging then return end
		if not isMouseDown then return end  -- Only process if mouse/touch is held
		
		if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
			local currentPos = Vector2.new(input.Position.X, input.Position.Y)
			local distance = (currentPos - State.tapStartPos).Magnitude
			
			-- If moved beyond threshold, start drag (cancel long-press)
			if not dragStarted and distance > Config.TAP_THRESHOLD_DISTANCE then
				dragStarted = true
				-- Cancel long-press if dragging
				if longPressThread then
					task.cancel(longPressThread)
					longPressThread = nil
				end
				closeItemInfoPopup()  -- Close any popup
				clearSelection()  -- Clear selection when starting drag
				startDrag(itemId, currentPos)
			end
		end
	end)
	
	itemFrame.InputEnded:Connect(function(input, gameProcessed)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			-- Only process if we started on this item (isMouseDown)
			if not isMouseDown then return end
			
			local elapsed = tick() - State.tapStartTime
			local currentPos = Vector2.new(input.Position.X, input.Position.Y)
			local distance = (currentPos - State.tapStartPos).Magnitude
			
		-- If short tap without much movement and not currently dragging
			-- Increased thresholds for easier unselect
			local now = tick()
			
			-- CRITICAL: Cancel long-press timer BEFORE checking for double-tap
			-- This prevents popup from showing during double-tap
			if longPressThread then
				task.cancel(longPressThread)
				longPressThread = nil
			end
			
			if elapsed < 0.5 and distance < 20 and not State.isDragging and not dragStarted then
				local itemData = Data.inventoryItems[itemId]
				if itemData then
					-- Check for DOUBLE TAP (quick deposit to chest)
					if now - lastTapTime < 0.3 and UI.ChestContainer.Visible and State.currentChestModel then
						-- DOUBLE TAP: Deposit to chest - find first available slot
						local deposited = false
						for r = 1, Config.CHEST.GRID_ROWS do
							for c = 1, Config.CHEST.GRID_COLS do
								if canPlaceItemInChest(itemData.width, itemData.height, r, c, nil) then
									-- Found a slot - deposit item
									local depositEvent = Services.ReplicatedStorage:FindFirstChild("Remotes") and Services.ReplicatedStorage.Remotes:FindFirstChild("DepositItemToChest")
									if depositEvent then
										-- Pass chestModel INSTANCE
										depositEvent:FireServer(itemData.config.id, State.currentChestModel, r, c, itemData.width, itemData.height)
									end
									deposited = true
									-- Remove from local data
									removeItemFromGrid(itemData.config.id)
									Data.inventoryItems[itemData.config.id] = nil
									if itemData.frame then
										itemData.frame:Destroy()
									end
									deposited = true
									break
								end
							end
							if deposited then break end
						end
						if not deposited then
							-- Flash red if failed
							-- local stroke = itemFrame:FindFirstChild("ItemStroke") ...
						end
					elseif now - lastTapTime < 0.3 and State.isStorageOpen then
						-- DOUBLE TAP: Move to storage
						if Events.MoveToStorage then
							Events.MoveToStorage:FireServer(itemId, nil, nil) -- Let server find first empty slot
						end
						
						-- Optimistic update: Remove from local inventory
						-- CRITICAL: Use current frame from Data.inventoryItems, not closure parameter
						local currentItemData = Data.inventoryItems[itemId]
						if currentItemData and currentItemData.frame then
							currentItemData.frame:Destroy()
						end
						removeItemFromGrid(itemId)
						Data.inventoryItems[itemId] = nil
						
						closeItemInfoPopup()
						clearSelection()
						
						lastTapTime = 0
						return
						-- End of storage move
					else
						-- SINGLE TAP: Toggle selection
						if State.selectedItem and State.selectedItem.config.id == itemData.config.id then
							-- Deselect if clicking same item
							clearSelection()
						else
							-- Select this item
							selectItem(itemData)
						end
						lastTapTime = now
					end
				end
			end

			
			dragStarted = false
			isMouseDown = false  -- Reset mouse/touch state
			
			-- Cancel long-press thread and close popup when releasing
			if longPressThread then
				task.cancel(longPressThread)
				longPressThread = nil
			end
			closeItemInfoPopup()  -- Auto-close popup on release
		end
	end)
end

-- Setup grid slot click for moving selected item (inventory-to-inventory or chest-to-inventory)
local function setupGridSlotInput(slot, row, col)
	slot.InputBegan:Connect(function(input, gameProcessed)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			-- If item is selected, try to move it here
			if State.selectedItem and not State.isDragging then
				-- Check if this cell is empty (not occupied by another item)
				local cellOccupant = Data.gridData[row] and Data.gridData[row][col]
				
				if State.selectedItem.isChestItem then
					-- CHEST TO INVENTORY: Use smart placement
					local itemWidth = State.selectedItem.width or 1
					local itemHeight = State.selectedItem.height or 1
					
					-- Create temp item data for findBestPlacement
					local tempItemData = {
						width = itemWidth,
						height = itemHeight,
						config = State.selectedItem.config
					}
					
					-- Find best placement (with rotation and nearby search)
					local newRow, newCol, newWidth, newHeight, rotated = findBestPlacement(tempItemData, row, col)
					
					if newRow then
						-- Collect item from chest to specific inventory position
						local collectEvent = Services.ReplicatedStorage:FindFirstChild("Remotes") and Services.ReplicatedStorage.Remotes:FindFirstChild("CollectItemAtPosition")
						if collectEvent and State.currentChestModel then
							local chestPos = State.currentChestModel.PrimaryPart and State.currentChestModel.PrimaryPart.Position
							collectEvent:FireServer(State.selectedItem.config.name, chestPos, newRow, newCol, rotated)
						end
						
						-- Remove from chest grid data
						removeItemFromChestGrid(State.selectedItem.config.id)
						Data.chestItems[State.selectedItem.config.id] = nil
						if State.selectedItem.frame then
							State.selectedItem.frame:Destroy()
						end
						
						-- Clear selection
						clearSelection()
					else
						-- Flash red on failure
						local originalColor = slot.BackgroundColor3
						slot.BackgroundColor3 = Color3.fromRGB(100, 40, 40)
						Services.TweenService:Create(slot, TweenInfo.new(0.3), { BackgroundColor3 = originalColor }):Play()
					end

				elseif State.selectedItem.isStorageItem then
					-- STORAGE TO INVENTORY: Use smart placement
					local itemWidth = State.selectedItem.width or 1
					local itemHeight = State.selectedItem.height or 1
					
					-- Create temp item data for findBestPlacement
					local tempItemData = {
						width = itemWidth,
						height = itemHeight,
						config = State.selectedItem.config
					}
					
					-- Find best placement (with rotation and nearby search)
					local newRow, newCol, newWidth, newHeight, rotated = findBestPlacement(tempItemData, row, col)
					
					if newRow then
						-- Move item from storage to specific inventory position
						if Events.MoveToInventory then
							Events.MoveToInventory:FireServer(State.selectedItem.config.id, newRow, newCol, rotated)
						end
						
						-- Optimistic update: Remove from storage
						local currentItemData = Data.storageItems[State.selectedItem.config.id]
						if currentItemData and currentItemData.frame then
							currentItemData.frame:Destroy()
						end
						removeItemFromStorageGrid(State.selectedItem.config.id)
						Data.storageItems[State.selectedItem.config.id] = nil
						
						-- Clear selection
						clearSelection()
					else
						-- Flash red on failure
						local originalColor = slot.BackgroundColor3
						slot.BackgroundColor3 = Color3.fromRGB(100, 40, 40)
						Services.TweenService:Create(slot, TweenInfo.new(0.3), { BackgroundColor3 = originalColor }):Play()
					end

				else
					-- INVENTORY TO INVENTORY: Original move logic
					if cellOccupant == nil or cellOccupant == State.selectedItem.config.id then
						local success = moveSelectedItemTo(row, col)
						if not success then
							-- Flash red on failure
							local originalColor = slot.BackgroundColor3
							slot.BackgroundColor3 = Color3.fromRGB(100, 40, 40)
							Services.TweenService:Create(slot, TweenInfo.new(0.3), { BackgroundColor3 = originalColor }):Play()
						end
					end
				end
			end
		end
	end)
end


-- Setup chest grid slot click for moving items (inventory-to-chest or chest-to-chest)
-- Uses SMART PLACEMENT with rotation and nearby search
setupChestSlotInput = function(slot, row, col)
	slot.InputBegan:Connect(function(input, gameProcessed)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			-- If item is selected and chest is visible
			if State.selectedItem and not State.isDragging and UI.ChestContainer.Visible and State.currentChestModel then
				local itemWidth = State.selectedItem.width or 1
				local itemHeight = State.selectedItem.height or 1
				
				if State.selectedItem.isChestItem then
					-- CHEST TO CHEST: Use smart placement
					-- Remove from old position first for placement check
					removeItemFromChestGrid(State.selectedItem.config.id)
					
					-- Find best placement (with rotation and nearby search)
					local newRow, newCol, newWidth, newHeight, rotated = findBestChestPlacement(itemWidth, itemHeight, row, col, State.selectedItem.config.id)
					
					if newRow then
						-- Place in new position
						placeItemInChestGrid(State.selectedItem.config.id, newWidth, newHeight, newRow, newCol)
						
						-- Update visual position and size (if rotated)
						if State.selectedItem.frame then
							State.selectedItem.frame.Size = UDim2.new(0, newWidth * Config.CHEST.CELL_SIZE + (newWidth - 1) * Config.CHEST.CELL_PADDING, 0, newHeight * Config.CHEST.CELL_SIZE + (newHeight - 1) * Config.CHEST.CELL_PADDING)
							State.selectedItem.frame.Position = UDim2.new(0, (newCol - 1) * (Config.CHEST.CELL_SIZE + Config.CHEST.CELL_PADDING), 0, (newRow - 1) * (Config.CHEST.CELL_SIZE + Config.CHEST.CELL_PADDING))
						end
						
						-- Update data
						State.selectedItem.row = newRow
						State.selectedItem.col = newCol
						State.selectedItem.width = newWidth
						State.selectedItem.height = newHeight
						if Data.chestItems[State.selectedItem.config.id] then
							Data.chestItems[State.selectedItem.config.id].row = newRow
							Data.chestItems[State.selectedItem.config.id].col = newCol
							Data.chestItems[State.selectedItem.config.id].width = newWidth
							Data.chestItems[State.selectedItem.config.id].height = newHeight
						end
						
						-- Sync to server
						local updateEvent = Services.ReplicatedStorage:FindFirstChild("Remotes") and Services.ReplicatedStorage.Remotes:FindFirstChild("UpdateChestItemPosition")
						if updateEvent then
							updateEvent:FireServer(State.selectedItem.config.id, State.currentChestModel, newRow, newCol, newWidth, newHeight)
						end
						
						-- Clear selection
						clearSelection()
					else
						-- Restore original position if no valid placement found
						placeItemInChestGrid(State.selectedItem.config.id, itemWidth, itemHeight, State.selectedItem.row, State.selectedItem.col)
						-- Flash red on failure
						local originalColor = slot.BackgroundColor3
						slot.BackgroundColor3 = Color3.fromRGB(100, 40, 40)
						Services.TweenService:Create(slot, TweenInfo.new(0.3), { BackgroundColor3 = originalColor }):Play()
					end
				else
					-- INVENTORY TO CHEST: Use smart placement
					local newRow, newCol, newWidth, newHeight, rotated = findBestChestPlacement(itemWidth, itemHeight, row, col, nil)
					
					if newRow then
						-- Mark that this is a deposit update, not first chest open
						State.isFirstChestSync = false
						
						-- Deposit item to chest
						local depositEvent = Services.ReplicatedStorage:FindFirstChild("Remotes") and Services.ReplicatedStorage.Remotes:FindFirstChild("DepositItemToChest")
						if depositEvent then
							depositEvent:FireServer(State.selectedItem.config.id, State.currentChestModel, newRow, newCol, newWidth, newHeight)
						end
						
						-- Remove from local inventory data
						removeItemFromGrid(State.selectedItem.config.id)
						Data.inventoryItems[State.selectedItem.config.id] = nil
						if State.selectedItem.frame then
							State.selectedItem.frame:Destroy()
						end
						
						-- Clear selection
						clearSelection()
					else
						-- Flash red on failure (can't place due to size)
						local originalColor = slot.BackgroundColor3
						slot.BackgroundColor3 = Color3.fromRGB(100, 40, 40)
						Services.TweenService:Create(slot, TweenInfo.new(0.3), { BackgroundColor3 = originalColor }):Play()
					end
				end
			end
		end
	end)
end





-- NOTE: Chest grid input handlers are now set up dynamically in recreateChestGrid()
-- when a chest is opened, based on the chest's configuration


-- Connect input handlers to all inventory grid slots (enables tap-to-move)
for row = 1, Config.GRID_ROWS do
	for col = 1, Config.GRID_COLS do
		local slot = Data.gridSlots[row] and Data.gridSlots[row][col]
		if slot then
			setupGridSlotInput(slot, row, col)
		end
	end
end


-- Global touch/mouse move handler

Services.UserInputService.InputChanged:Connect(function(input, gameProcessed)
	if not State.isDragging then return end
	
	if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
		if input.UserInputType == Enum.UserInputType.Touch then
			-- Only satisfy if tracking this touch
			if State.activeTouchId and input == State.activeTouchId then
				updateDrag()
			elseif State.activeTouchId == nil then
				updateDrag()
			end
		else
			updateDrag()
		end
	end
end)

-- Global touch/mouse end handler
Services.UserInputService.InputEnded:Connect(function(input, gameProcessed)
	-- Always close popup on mouse/touch release (even if not dragging)
	if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
		closeItemInfoPopup()  -- Cleanup popup on any release
	end
	
	if not State.isDragging then return end
	
	if input.UserInputType == Enum.UserInputType.MouseButton1 then
		endDrag(Vector2.new(input.Position.X, input.Position.Y))
		State.activeTouchId = nil
	elseif input.UserInputType == Enum.UserInputType.Touch then
		-- Only end drag if this is the active touch
		if State.activeTouchId == nil or input == State.activeTouchId then
			endDrag(Vector2.new(input.Position.X, input.Position.Y))
			State.activeTouchId = nil
		end
	end
end)

-- ============================================================================
-- STATS UPDATE
-- ============================================================================

local function updateStatsUI()
	local totalWeight = 0
	local totalValue = 0
	
	for _, itemData in pairs(Data.inventoryItems) do
		if itemData.config then
			totalWeight = totalWeight + (itemData.config.weight or 0)
			totalValue = totalValue + (itemData.config.price or 0)
		end
	end
	
	if UI.weightLabel then
		UI.weightLabel.Text = string.format("%.1f/65.0 kg", totalWeight)
		-- Change color based on weight
		if totalWeight > 55 then
			UI.weightLabel.TextColor3 = Color3.fromRGB(255, 100, 100)
		elseif totalWeight > 40 then
			UI.weightLabel.TextColor3 = Color3.fromRGB(255, 200, 100)
		else
			UI.weightLabel.TextColor3 = Color3.fromRGB(200, 200, 220)
		end
	end
	
	if UI.equipmentValueLabel then
		UI.equipmentValueLabel.Text = "Equipment Value: " .. tostring(totalValue)
	end
end

-- ============================================================================
-- SERVER INVENTORY SYNC
-- ============================================================================

local function loadInventoryFromServer(inventoryData)
	-- Clear selection
	clearSelection()
	
	-- Clear existing items
	for id, itemData in pairs(Data.inventoryItems) do
		if itemData.frame then
			itemData.frame:Destroy()
		end
		removeItemFromGrid(id)
	end
	Data.inventoryItems = {}
	
	-- Setup grid slot inputs (for click-to-move)
	if Data.gridSlots then
		for row = 1, Config.GRID_ROWS do
			if Data.gridSlots[row] then
				for col = 1, Config.GRID_COLS do
					local slot = Data.gridSlots[row][col]
					if slot then
						setupGridSlotInput(slot, row, col)
					end
				end
			end
		end
	end
	
	-- Load items from server data
	if inventoryData and inventoryData.items then
		for i, itemInfo in ipairs(inventoryData.items) do
			-- Use itemId from server for config lookup, or fallback to name
			local itemType = itemInfo.itemId or itemInfo.name
			local baseConfig = ItemConfig[itemType] or ItemConfig.GetItem(itemType)
			
			-- Merge base config with server-provided unique data
			local config = {
				id = itemInfo.id,  -- Use unique instance ID directly from server (e.g. "Bandage_12345678_1")
				itemId = itemType,  -- Original item type ID for config lookups
				name = itemInfo.name,
				width = itemInfo.width or (baseConfig and baseConfig.width) or 1,
				height = itemInfo.height or (baseConfig and baseConfig.height) or 1,
				color = baseConfig and baseConfig.color or Color3.fromRGB(itemInfo.color and itemInfo.color[1] or 200, itemInfo.color and itemInfo.color[2] or 200, itemInfo.color and itemInfo.color[3] or 200),
				weight = itemInfo.weight or (baseConfig and baseConfig.weight) or 0.15,
				price = itemInfo.price or (baseConfig and baseConfig.price) or 50,
				icon = (baseConfig and baseConfig.icon) or itemInfo.icon or "",
				rarity = (baseConfig and baseConfig.rarity) or itemInfo.rarity or "Common",
				description = (baseConfig and baseConfig.description) or "A useful item.",
				-- Armor specific fields
				isArmor = baseConfig and baseConfig.isArmor or false,
				armorType = baseConfig and baseConfig.armorType,
				armorSet = baseConfig and baseConfig.armorSet,
				slotType = baseConfig and baseConfig.slotType,
				modelPath = baseConfig and baseConfig.modelPath,
			}
			
			if canPlaceItem(config.width, config.height, itemInfo.row, itemInfo.col, nil) then
				local frame = createItemFrame(config, config.width, config.height, itemInfo.row, itemInfo.col)
				
				local itemData = {
					config = config,
					row = itemInfo.row,
					col = itemInfo.col,
					width = config.width,
					height = config.height,
					rotated = itemInfo.rotated or false,
					frame = frame,
				}
				
				Data.inventoryItems[config.id] = itemData
				placeItemInGrid(config.id, config.width, config.height, itemInfo.row, itemInfo.col)
				setupItemInput(frame, config.id)
			else
				-- Debug: Item couldn't be placed - log why

				
				-- Try to place anyway since server validated the position
				-- The grid state might be out of sync
				local frame = createItemFrame(config, config.width, config.height, itemInfo.row, itemInfo.col)
				
				local itemData = {
					config = config,
					row = itemInfo.row,
					col = itemInfo.col,
					width = config.width,
					height = config.height,
					rotated = itemInfo.rotated or false,
					frame = frame,
				}
				
				Data.inventoryItems[config.id] = itemData
				placeItemInGrid(config.id, config.width, config.height, itemInfo.row, itemInfo.col)
				setupItemInput(frame, config.id)
			end
		end
	end
	
	-- Update weight and value display
	updateStatsUI()
end


-- ============================================================================
-- LOOT POPUP UI (Multi-Item Scrollable)
-- ============================================================================

State.lootPopup = nil
State.nearbyItems = {}  -- Track all items in range
State.lootHighlights = {}  -- Multiple highlights for multiple items
State.isCollecting = false
State.collectedItems = {}
local ITEM_ROW_HEIGHT = 50  -- Height of each item row in pixels
local MIN_VISIBLE_ITEMS = 2  -- Minimum items visible without scrolling

-- Helper function to check if an item can fit in inventory
local function canItemFitInInventory(itemInstance)
	local itemName = itemInstance.Name
	local itemIconConfig = ItemConfig[itemName] or ItemConfig.GetItem(itemName)
	local itemWidth = (itemIconConfig and itemIconConfig.width) or itemInstance:GetAttribute("Width") or 1
	local itemHeight = (itemIconConfig and itemIconConfig.height) or itemInstance:GetAttribute("Height") or 1
	
	-- Try normal orientation
	for row = 1, Config.GRID_ROWS do
		for col = 1, Config.GRID_COLS do
			if canPlaceItem(itemWidth, itemHeight, row, col, nil) then
				return true
			end
		end
	end
	
	-- Try rotated orientation
	if itemWidth ~= itemHeight then
		for row = 1, Config.GRID_ROWS do
			for col = 1, Config.GRID_COLS do
				if canPlaceItem(itemHeight, itemWidth, row, col, nil) then
					return true
				end
			end
		end
	end
	
	return false
end

local function getItemPosition(item)
	if item:IsA("Model") then
		if item.PrimaryPart then
			return item.PrimaryPart.Position
		end
		local part = item:FindFirstChildWhichIsA("BasePart", true)
		if part then
			return part.Position
		end
	elseif item:IsA("BasePart") then
		return item.Position
	end
	return nil
end

local function collectItem(itemInstance)
	if not itemInstance or State.isCollecting or State.collectedItems[itemInstance] then return end
	
	-- Check if item can fit in inventory BEFORE doing anything
	local canFit = canItemFitInInventory(itemInstance)
	if not canFit then
		-- Flash red to indicate backpack full - but don't collect
		return
	end
	
	State.isCollecting = true
	local itemToCollect = itemInstance.Name
	State.collectedItems[itemInstance] = true
	
	-- Remove highlight for this item
	if State.lootHighlights[itemInstance] then
		State.lootHighlights[itemInstance]:Destroy()
		State.lootHighlights[itemInstance] = nil
	end
	
	-- Remove from State.nearbyItems
	for i, item in ipairs(State.nearbyItems) do
		if item == itemInstance then
			table.remove(State.nearbyItems, i)
			break
		end
	end
	
	-- Play animation (only if item can fit)
	local character = player.Character
	if character then
		local humanoid = character:FindFirstChildOfClass("Humanoid")
		if humanoid then
			local animFolder = Services.ReplicatedStorage:FindFirstChild("Anim")
			if animFolder then
				local actionTrigger = animFolder:FindFirstChild("ActionTrigger")
				if actionTrigger then
					local animator = humanoid:FindFirstChildOfClass("Animator")
					if animator then
						local track = animator:LoadAnimation(actionTrigger)
						track.Looped = false
						track:Play()
					end
				end
			end
		end
	end
	
	-- Delay then fire server event
	task.delay(0.5, function()
		if Events.CollectItem then
			local itemPos = getItemPosition(itemInstance)
			Events.CollectItem:FireServer(itemToCollect, itemPos)
		end
		State.isCollecting = false
	end)
end

local function createLootPopup(items)
	-- Remove existing popup
	if State.lootPopup then
		State.lootPopup:Destroy()
		State.lootPopup = nil
	end
	
	if #items == 0 then return end
	
	local itemCount = #items
	local visibleItems = math.min(itemCount, MIN_VISIBLE_ITEMS)
	local popupHeight = 30 + (visibleItems * ITEM_ROW_HEIGHT)  -- TopBar + items
	
	-- Create popup frame (ZIndex 5, below UI.mainPanel's 10)
	State.lootPopup = Instance.new("Frame")
	State.lootPopup.Name = "LootPopup"
	State.lootPopup.Size = UDim2.new(0, 220, 0, popupHeight)
	State.lootPopup.Position = UDim2.new(0.5, 50, 0.5, 30)
	State.lootPopup.AnchorPoint = Vector2.new(0, 0)
	State.lootPopup.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	State.lootPopup.BorderSizePixel = 0
	State.lootPopup.ZIndex = 5  -- Below UI.mainPanel (10) so inventory is always on top
	State.lootPopup.Parent = UI.screenGui
	
	local popupStroke = Instance.new("UIStroke")
	popupStroke.Color = Color3.fromRGB(100, 80, 140)
	popupStroke.Thickness = 2
	popupStroke.Parent = State.lootPopup
	
	local popupCorner = Instance.new("UICorner")
	popupCorner.CornerRadius = UDim.new(0, 8)
	popupCorner.Parent = State.lootPopup
	
	-- TopBar with count
	local topBar = Instance.new("Frame")
	topBar.Name = "TopBar"
	topBar.Size = UDim2.new(1, 0, 0, 28)
	topBar.Position = UDim2.new(0, 0, 0, 0)
	topBar.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	topBar.BorderSizePixel = 0
	topBar.ZIndex = 6
	topBar.Parent = State.lootPopup
	
	local topBarCorner = Instance.new("UICorner")
	topBarCorner.CornerRadius = UDim.new(0, 8)
	topBarCorner.Parent = topBar
	
	local topBarLabel = Instance.new("TextLabel")
	topBarLabel.Size = UDim2.new(1, -10, 1, 0)
	topBarLabel.Position = UDim2.new(0, 10, 0, 0)
	topBarLabel.BackgroundTransparency = 1
	topBarLabel.Text = "Loot (" .. itemCount .. ")"
	topBarLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
	topBarLabel.TextXAlignment = Enum.TextXAlignment.Left
	topBarLabel.TextSize = 14
	topBarLabel.Font = Enum.Font.GothamBold
	topBarLabel.ZIndex = 7
	topBarLabel.Parent = topBar
	
	-- Scrollable item list
	local scrollFrame = Instance.new("ScrollingFrame")
	scrollFrame.Name = "ItemList"
	scrollFrame.Size = UDim2.new(1, -4, 1, -30)
	scrollFrame.Position = UDim2.new(0, 2, 0, 29)
	scrollFrame.BackgroundTransparency = 1
	scrollFrame.BorderSizePixel = 0
	scrollFrame.ScrollBarThickness = 6
	scrollFrame.ScrollBarImageColor3 = Color3.fromRGB(100, 100, 130)
	scrollFrame.CanvasSize = UDim2.new(0, 0, 0, itemCount * ITEM_ROW_HEIGHT)
	scrollFrame.ZIndex = 6
	scrollFrame.Parent = State.lootPopup
	
	local listLayout = Instance.new("UIListLayout")
	listLayout.SortOrder = Enum.SortOrder.LayoutOrder
	listLayout.Padding = UDim.new(0, 2)
	listLayout.Parent = scrollFrame
	
	-- Create item rows
	for i, item in ipairs(items) do
		local itemName = item.Name
		local itemWeight = item:GetAttribute("Weight") or 0.15
		local itemPrice = item:GetAttribute("Price") or 50
		
		local itemRow = Instance.new("TextButton")
		itemRow.Name = "ItemRow_" .. i
		itemRow.Size = UDim2.new(1, -8, 0, ITEM_ROW_HEIGHT - 4)
		itemRow.LayoutOrder = i
		itemRow.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
		itemRow.BorderSizePixel = 0
		itemRow.Text = ""
		itemRow.AutoButtonColor = true
		itemRow.ZIndex = 7
		itemRow.Parent = scrollFrame
		
		local rowCorner = Instance.new("UICorner")
		rowCorner.CornerRadius = UDim.new(0, 4)
		rowCorner.Parent = itemRow
		
		-- Icon frame
		local iconFrame = Instance.new("Frame")
		iconFrame.Size = UDim2.new(0, 38, 0, 38)
		iconFrame.Position = UDim2.new(0, 4, 0.5, -19)
		iconFrame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
		iconFrame.BorderSizePixel = 0
		iconFrame.ZIndex = 8
		iconFrame.Parent = itemRow
		
		local iconCorner = Instance.new("UICorner")
		iconCorner.CornerRadius = UDim.new(0, 4)
		iconCorner.Parent = iconFrame
		
		-- Get item icon from ItemConfig
		local itemIconConfig = ItemConfig[itemName] or ItemConfig.GetItem(itemName)
		if itemIconConfig and itemIconConfig.icon and itemIconConfig.icon ~= "" then
			local iconImage = Instance.new("ImageLabel")
			iconImage.Name = "Icon"
			iconImage.Size = UDim2.new(1, 0, 1, 0)
			iconImage.BackgroundTransparency = 1
			iconImage.Image = itemIconConfig.icon
			iconImage.ScaleType = Enum.ScaleType.Fit
			iconImage.ZIndex = 9
			iconImage.Parent = iconFrame
		end
		
		-- Name
		local nameLabel = Instance.new("TextLabel")
		nameLabel.Size = UDim2.new(1, -55, 0, 18)
		nameLabel.Position = UDim2.new(0, 48, 0, 4)
		nameLabel.BackgroundTransparency = 1
		nameLabel.Text = itemName .. " (" .. string.format("%.2f", itemWeight) .. " KG)"
		nameLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
		nameLabel.TextXAlignment = Enum.TextXAlignment.Left
		nameLabel.TextSize = 11
		nameLabel.Font = Enum.Font.GothamBold
		nameLabel.ZIndex = 8
		nameLabel.Parent = itemRow
		
		-- Price
		local priceLabel = Instance.new("TextLabel")
		priceLabel.Size = UDim2.new(1, -55, 0, 16)
		priceLabel.Position = UDim2.new(0, 48, 0, 24)
		priceLabel.BackgroundTransparency = 1
		priceLabel.Text = "Price: $" .. tostring(itemPrice)
		priceLabel.TextColor3 = Color3.fromRGB(180, 180, 140)
		priceLabel.TextXAlignment = Enum.TextXAlignment.Left
		priceLabel.TextSize = 10
		priceLabel.Font = Enum.Font.Gotham
		priceLabel.ZIndex = 8
		priceLabel.Parent = itemRow
		
		-- Backpack Full Overlay (red, visible when item can't fit)
		local fullOverlay = Instance.new("Frame")
		fullOverlay.Name = "BackpackFullOverlay"
		fullOverlay.Size = UDim2.new(1, 0, 1, 0)
		fullOverlay.Position = UDim2.new(0, 0, 0, 0)
		fullOverlay.BackgroundColor3 = Color3.fromRGB(100, 20, 20)  -- Dark red
		fullOverlay.BackgroundTransparency = 0.65
		fullOverlay.BorderSizePixel = 0
		fullOverlay.ZIndex = 10  -- Above all other elements
		fullOverlay.Parent = itemRow
		
		local overlayCorner = Instance.new("UICorner")
		overlayCorner.CornerRadius = UDim.new(0, 4)
		overlayCorner.Parent = fullOverlay
		
		-- Check if item can fit in backpack
		local itemWidth = item:GetAttribute("Width") or 1
		local itemHeight = item:GetAttribute("Height") or 1
		-- Also check from ItemConfig
		if itemIconConfig then
			itemWidth = itemIconConfig.width or itemWidth
			itemHeight = itemIconConfig.height or itemHeight
		end
		
		-- Try to find a spot for this item
		local canFit = false
		for row = 1, Config.GRID_ROWS do
			for col = 1, Config.GRID_COLS do
				if canPlaceItem(itemWidth, itemHeight, row, col, nil) then
					canFit = true
					break
				end
			end
			if canFit then break end
		end
		
		-- Show red overlay and disable button if can't fit
		fullOverlay.Visible = not canFit
		itemRow.Active = canFit  -- Disable button when backpack full
		itemRow.AutoButtonColor = canFit  -- Remove hover effect when disabled
		
		-- Click handler for this row (with guard check)
		itemRow.MouseButton1Click:Connect(function()
			-- Double-check if item can still fit (inventory may have changed)
			if not canItemFitInInventory(item) then
				return  -- Backpack full, do nothing
			end
			
			collectItem(item)
			-- Update popup after collection
			if #State.nearbyItems > 0 then
				createLootPopup(State.nearbyItems)
			else
				if State.lootPopup then
					State.lootPopup:Destroy()
					State.lootPopup = nil
				end
			end
		end)
	end
	
	return State.lootPopup
end

local function closeLootPopup()
	if State.lootPopup then
		State.lootPopup:Destroy()
		State.lootPopup = nil
	end
	-- Clear all highlights
	for item, highlight in pairs(State.lootHighlights) do
		if highlight then
			highlight:Destroy()
		end
	end
	State.lootHighlights = {}
	State.nearbyItems = {}
end

-- ============================================================================
-- PROXIMITY DETECTION LOOP (Multi-Item)
-- ============================================================================

Services.RunService.Heartbeat:Connect(function()
	local character = player.Character
	if not character then
		closeLootPopup()
		return
	end
	
	local hrp = character:FindFirstChild("HumanoidRootPart")
	if not hrp then
		closeLootPopup()
		return
	end
	
	local itemsFolder = workspace:FindFirstChild("Items")
	local lootsFolder = workspace:FindFirstChild("Loots")
	
	-- If neither folder exists, close popup
	if not itemsFolder and not lootsFolder then
		closeLootPopup()
		return
	end
	
	-- Find ALL items in range from both Items and Loots folders
	local currentNearbyItems = {}
	
	-- Helper function to check items in a folder
	local function scanFolderForItems(folder)
		if not folder then return end
		for _, item in ipairs(folder:GetChildren()) do
			-- Skip chest models (they have their own interaction system)
			-- Check if this model is a configured chest type
			if item:IsA("Model") then
				local isChest = ChestConfig and ChestConfig.GetChest(item.Name) ~= nil
				if isChest then
					continue
				end
			end
			
			if not State.collectedItems[item] then
				local itemPos = getItemPosition(item)
				if itemPos then
					local distance = (hrp.Position - itemPos).Magnitude
					if distance <= Config.DROPPED_ITEM_DISTANCE then
						table.insert(currentNearbyItems, item)
					end
				end
			end
		end
	end
	
	-- Scan both folders
	scanFolderForItems(itemsFolder)
	scanFolderForItems(lootsFolder)
	
	-- Sort by distance (closest first)
	table.sort(currentNearbyItems, function(a, b)
		local posA = getItemPosition(a)
		local posB = getItemPosition(b)
		if posA and posB then
			return (hrp.Position - posA).Magnitude < (hrp.Position - posB).Magnitude
		end
		return false
	end)
	
	-- Check if items changed
	local itemsChanged = #currentNearbyItems ~= #State.nearbyItems
	if not itemsChanged then
		for i, item in ipairs(currentNearbyItems) do
			if State.nearbyItems[i] ~= item then
				itemsChanged = true
				break
			end
		end
	end
	
	if itemsChanged and not State.isCollecting then
		State.nearbyItems = currentNearbyItems
		
		-- Clear old highlights
		for item, highlight in pairs(State.lootHighlights) do
			if highlight then
				highlight:Destroy()
			end
		end
		State.lootHighlights = {}
		
		if #State.nearbyItems > 0 then
			-- Add highlights to all nearby items
			for _, item in ipairs(State.nearbyItems) do
				local highlight = Instance.new("Highlight")
				highlight.Name = "LootHighlight"
				highlight.FillColor = Color3.fromRGB(100, 200, 100)
				highlight.FillTransparency = 0.7
				highlight.OutlineColor = Color3.fromRGB(150, 255, 150)
				highlight.OutlineTransparency = 0.3
				highlight.Parent = item
				State.lootHighlights[item] = highlight
			end
			
			createLootPopup(State.nearbyItems)
		else
			closeLootPopup()
		end
	elseif #currentNearbyItems == 0 and #State.nearbyItems > 0 then
		closeLootPopup()
	end
end)

-- ============================================================================
-- SERVER SYNC EVENT HANDLER
-- ============================================================================

if Events.SyncInventory then
	Events.SyncInventory.OnClientEvent:Connect(function(inventoryData)
		loadInventoryFromServer(inventoryData)
		
		-- Refresh loot popup to update backpack full overlay status
		if State.lootPopup and #State.nearbyItems > 0 then
			createLootPopup(State.nearbyItems)
		end
	end)
end

-- Handle inventory full notification
if Events.InventoryFull then
	Events.InventoryFull.OnClientEvent:Connect(function(itemName)
		-- Remove item from State.collectedItems so it can be picked up again later
		for item, _ in pairs(State.collectedItems) do
			if item.Name == itemName then
				State.collectedItems[item] = nil
				break
			end
		end
		
		-- Flash red on UI.mainPanel to indicate backpack is full
		local originalColor = UI.mainPanel.BackgroundColor3
		UI.mainPanel.BackgroundColor3 = Color3.fromRGB(100, 30, 30)
		task.delay(0.3, function()
			UI.mainPanel.BackgroundColor3 = originalColor
		end)
	end)
end

-- Handle armor sync from server
if Events.ArmorSync then
	Events.ArmorSync.OnClientEvent:Connect(function(armorData)
		-- Check if this is a checkResult response
		if armorData and armorData.checkResult ~= nil then
			-- Server responded to check_space action
			return
		end
		
		
		-- Update each armor slot based on server data
		local equippedArmor = armorData
		for slotName, slotData in pairs(Data.armorSlots) do
			local equippedItemId = equippedArmor and equippedArmor[slotName]
			
			if equippedItemId then
				-- Armor is equipped in this slot
				local armorConfig = ItemConfig[equippedItemId] or ItemConfig.GetItem(equippedItemId)
				if armorConfig then
					slotData.equippedIcon.Image = armorConfig.icon
					slotData.equippedIcon.Visible = true
					slotData.icon.Visible = false
					slotData.equipped = equippedItemId
					slotData.stroke.Color = Color3.fromRGB(100, 255, 100)
				end
			else
				-- No armor in this slot
				slotData.equippedIcon.Visible = false
				slotData.equippedIcon.Image = ""
				slotData.icon.Visible = true
				slotData.equipped = nil
				slotData.stroke.Color = Color3.fromRGB(80, 80, 120)
				slotData.stroke.Thickness = 1
			end
		end
	end)
end

-- ============================================================================
-- PANEL OPEN/CLOSE
-- ============================================================================

-- Helper function to play inventory animations
local function playInventoryAnimation(animName, looped)
	local character = player.Character
	if not character then return nil end
	
	local humanoid = character:FindFirstChildOfClass("Humanoid")
	if not humanoid then return nil end
	
	local animFolder = Services.ReplicatedStorage:FindFirstChild("Anim")
	if not animFolder then return nil end
	
	local animAsset = animFolder:FindFirstChild(animName)
	if not animAsset then return nil end
	
	-- Stop current animation if playing
	if State.currentInventoryAnimTrack and State.currentInventoryAnimTrack.IsPlaying then
		State.currentInventoryAnimTrack:Stop()
	end
	
	local animator = humanoid:FindFirstChildOfClass("Animator")
	if not animator then
		animator = Instance.new("Animator")
		animator.Parent = humanoid
	end
	
	local animTrack = animator:LoadAnimation(animAsset)
	animTrack.Looped = looped or false
	animTrack.Priority = Enum.AnimationPriority.Action4
	animTrack:Play()
	
	State.currentInventoryAnimTrack = animTrack
	return animTrack
end

-- Forward declaration for closePanel (needed for movement listener)
local closePanel
local cancelLooting

cancelLooting = function()
	if not State.isLootingChest then return end
	
	State.isLootingChest = false
	
	-- Stop looting animation
	if State.currentInventoryAnimTrack then
		 State.currentInventoryAnimTrack:Stop()
		 State.currentInventoryAnimTrack = nil
	end
	
	-- Cancel delayed panel open
	if State.lootingDelayTask then
		task.cancel(State.lootingDelayTask)
		State.lootingDelayTask = nil
	end
	
	-- Disconnect movement listener
	if State.lootingMoveConnection then
		State.lootingMoveConnection:Disconnect()
		State.lootingMoveConnection = nil
	end

	-- Re-enable scrolling if interrupted (Mobile improvement)
	if UI.contentScroll then
		UI.contentScroll.ScrollingEnabled = true
	end
	
	-- Reset opening button if visible
	if UI.chestOpenButton then
		UI.chestOpenButton.Visible = false
	end
	if UI.chestOpenLabel then
		UI.chestOpenLabel.Text = "OPEN"
	end
	if UI.chestOpenProgress then
		UI.chestOpenProgress.Size = UDim2.new(0, 0, 1, 0)
	end
	if State.openingProgressTween then
		State.openingProgressTween:Cancel()
		State.openingProgressTween = nil
	end
	
end

local function openPanel(fromChest)
	State.isPanelOpen = true
	
	-- Handle chest vs inventory mode
	if fromChest and State.isLootingChest then
		-- Chest looting mode - show ChestContainer, hide others
		UI.PlayerContainer.Visible = false
		UI.ChestContainer.Visible = true
		-- Hide Storage as well
		if UI.storageContainer then
			UI.storageContainer.Visible = false
		end
		State.isStorageOpen = false
		-- Don't play CheckInventoryIdle for chest looting (OpenChestIdle is played separately)
	else
		-- Normal inventory mode
		UI.PlayerContainer.Visible = true
		UI.ChestContainer.Visible = false
		-- Hide Storage as well
		if UI.storageContainer then
			UI.storageContainer.Visible = false
		end
		State.isStorageOpen = false
		State.isLootingChest = false
		-- Play CheckInventoryIdle animation (looped)
		playInventoryAnimation("CheckInventoryIdle", true)
	end
	
	-- Setup movement listener to auto-close when player moves
	local character = player.Character
	if character then
		local humanoid = character:FindFirstChildOfClass("Humanoid")
		if humanoid then
			-- Disconnect previous connection if any
			if State.movementConnection then
				State.movementConnection:Disconnect()
				State.movementConnection = nil
			end
			
			-- Connect to Running signal - fires when player starts moving
			State.movementConnection = humanoid.Running:Connect(function(speed)
				if speed > 0.1 and State.isPanelOpen then
					-- Player started moving - close inventory
					closePanel()
				end
			end)
		end
	end
	
	-- Enable blur
	if UI.blurEffect then
		UI.blurEffect.Enabled = true
	end
	
	-- Reset for instant display (no animation)
	UI.mainPanel.BackgroundTransparency = 0
	UI.mainPanel.AnchorPoint = Vector2.new(0.5, 0.5)
	UI.mainPanel.Position = UDim2.new(0.5, 0, 0.5, 0)
	UI.mainPanel.Visible = true
	UI.panelScale.Scale = 1  -- Full size immediately
	
	-- Show touch blocker for mobile (prevents camera movement)
	UI.touchBlocker.Visible = true
	
	-- Enable Modal to sink touch input (prevents camera movement on mobile)
	UI.mainPanel.Active = true

	
	-- Setup based on mode
	if not State.isLootingChest then
		-- Inventory mode: Setup grid slot inputs for click-to-move
		if Data.gridSlots then
			for row = 1, Config.GRID_ROWS do
				if Data.gridSlots[row] then
					for col = 1, Config.GRID_COLS do
						local slot = Data.gridSlots[row][col]
						if slot then
							setupGridSlotInput(slot, row, col)
						end
					end
				end
			end
		end
		
		-- Update character viewport and health bar
		updateCharacterViewport()
		connectHealthBar()
	end
end

closePanel = function()
	State.isPanelOpen = false
	
	-- Re-enable scrolling if interrupted (Mobile improvement)
	if UI.contentScroll then
		UI.contentScroll.ScrollingEnabled = true
	end
	
	-- Disconnect movement listener
	if State.movementConnection then
		State.movementConnection:Disconnect()
		State.movementConnection = nil
	end
	
	-- Cancel looting progress if any
	if State.isLootingChest then
		cancelLooting()
	end
	
	-- Clear chest grid data and visuals for security (prevent hacking)
	if State.currentChestModel then
		-- Clear chest item frames
		for _, itemFrame in pairs(chestLootItems or {}) do
			if itemFrame and itemFrame.Parent then
				itemFrame:Destroy()
			end
		end
		chestLootItems = {}
		
		-- Clear chest grid data
		Data.chestGridData = {}
		Data.chestItems = {}
		
		-- Clear chest state
		State.currentChestModel = nil
		State.currentChestConfig = nil
		State.isLootingChest = false
	end
	
	-- Clear selection and close any popups
	clearSelection()
	closeItemInfoPopup()
	
	-- Stop current inventory animation
	if State.currentInventoryAnimTrack and State.currentInventoryAnimTrack.IsPlaying then
		State.currentInventoryAnimTrack:Stop()
	end
	
	-- Hide touch blocker
	UI.touchBlocker.Visible = false
	
	-- Cleanup any active drag state
	if State.isDragging then
		if State.dragGhost then
			State.dragGhost:Destroy()
			State.dragGhost = nil
		end
		clearHighlights()
		if State.draggedItem then
			State.draggedItem.frame.Visible = true
			resetOriginalSlotHighlight(State.originalSlot.row, State.originalSlot.col, State.originalSlot.width, State.originalSlot.height)
			-- Return item to original position
			placeItemInGrid(State.draggedItem.config.id, State.originalSlot.width, State.originalSlot.height, State.originalSlot.row, State.originalSlot.col)
			State.draggedItem.row = State.originalSlot.row
			State.draggedItem.col = State.originalSlot.col
		end
		State.isDragging = false
		State.draggedItem = nil
		State.activeTouchId = nil
	end
	
	-- Close instantly (no animation)
	UI.mainPanel.Visible = false
	if UI.blurEffect then
		UI.blurEffect.Enabled = false
	end
end

-- ============================================================================
-- BUTTON CONNECTIONS
-- ============================================================================

UI.invButton.MouseButton1Click:Connect(function()
	-- Play inventory sound
	local soundService = game:GetService("SoundService")
	local inventorySound = soundService:FindFirstChild("Inventory")
	if inventorySound and inventorySound:IsA("Sound") then
		inventorySound:Play()
	end
	
	if State.isPanelOpen then
		closePanel()
	else
		openPanel()
	end
end)

UI.closeButton.MouseButton1Click:Connect(function()
	-- Play close sound
	local soundService = game:GetService("SoundService")
	local closeSound = soundService:FindFirstChild("InventoryClose")
	if closeSound and closeSound:IsA("Sound") then
		closeSound:Play()
	end
	closePanel()
end)

-- Hover effects
UI.invButton.MouseEnter:Connect(function()
	Services.TweenService:Create(UI.invButton, TweenInfo.new(0.15), {BackgroundColor3 = Color3.fromRGB(45, 45, 75)}):Play()
end)
UI.invButton.MouseLeave:Connect(function()
	Services.TweenService:Create(UI.invButton, TweenInfo.new(0.15), {BackgroundColor3 = Color3.fromRGB(25, 25, 45)}):Play()
end)

UI.closeButton.MouseEnter:Connect(function()
	Services.TweenService:Create(UI.closeButton, TweenInfo.new(0.15), {BackgroundColor3 = Color3.fromRGB(220, 70, 70)}):Play()
end)
UI.closeButton.MouseLeave:Connect(function()
	Services.TweenService:Create(UI.closeButton, TweenInfo.new(0.15), {BackgroundColor3 = Color3.fromRGB(180, 50, 50)}):Play()
end)

-- ============================================================================
-- CHEST LOOT DETECTION SYSTEM
-- ============================================================================

-- Chest Open Button UI (Container Button)
UI.chestOpenButton = Instance.new("TextButton")
UI.chestOpenButton.Name = "ChestOpenButton"
UI.chestOpenButton.Size = UDim2.new(0, 150, 0, 40)
UI.chestOpenButton.Position = UDim2.new(0.5, 50, 0.5, 30) -- Match lootPopup position
UI.chestOpenButton.AnchorPoint = Vector2.new(0, 0)
UI.chestOpenButton.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
UI.chestOpenButton.BackgroundTransparency = 0.6
UI.chestOpenButton.BorderSizePixel = 0
UI.chestOpenButton.Text = "" -- Empty text, using label instead
UI.chestOpenButton.AutoButtonColor = false
UI.chestOpenButton.Visible = false
UI.chestOpenButton.ZIndex = 50
UI.chestOpenButton.Parent = UI.screenGui

local chestButtonCorner = Instance.new("UICorner")
chestButtonCorner.CornerRadius = UDim.new(0, 8)
chestButtonCorner.Parent = UI.chestOpenButton

local chestButtonStroke = Instance.new("UIStroke")
chestButtonStroke.Color = Color3.fromRGB(100, 80, 140) -- Match lootPopup color
chestButtonStroke.Thickness = 2
chestButtonStroke.Parent = UI.chestOpenButton

-- Image/Icon on the left
local chestOpenIcon = Instance.new("ImageLabel")
chestOpenIcon.Name = "Icon"
chestOpenIcon.Size = UDim2.new(0, 30, 0, 30)
chestOpenIcon.Position = UDim2.new(0, 6, 0.5, -15)
chestOpenIcon.BackgroundTransparency = 1
chestOpenIcon.Image = "rbxassetid://91638685038954"
chestOpenIcon.ScaleType = Enum.ScaleType.Fit
chestOpenIcon.ZIndex = 51
chestOpenIcon.Parent = UI.chestOpenButton

-- Open Label on the right
UI.chestOpenLabel = Instance.new("TextLabel")
UI.chestOpenLabel.Name = "OpenLabel"
UI.chestOpenLabel.Size = UDim2.new(1, -45, 1, 0)
UI.chestOpenLabel.Position = UDim2.new(0, 40, 0, 0)
UI.chestOpenLabel.BackgroundTransparency = 1
UI.chestOpenLabel.Text = "OPEN"
UI.chestOpenLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
UI.chestOpenLabel.TextSize = 16
UI.chestOpenLabel.Font = Enum.Font.GothamBold
UI.chestOpenLabel.ZIndex = 51
UI.chestOpenLabel.Parent = UI.chestOpenButton

-- Progress bar for opening animation (fills from left to right)
UI.chestOpenProgress = Instance.new("Frame")
UI.chestOpenProgress.Name = "ProgressBar"
UI.chestOpenProgress.Size = UDim2.new(0, 0, 1, 0)  -- Starts at 0 width
UI.chestOpenProgress.Position = UDim2.new(0, 0, 0, 0)
UI.chestOpenProgress.BackgroundColor3 = Color3.fromRGB(50, 150, 80)
UI.chestOpenProgress.BackgroundTransparency = 0.5
UI.chestOpenProgress.BorderSizePixel = 0
UI.chestOpenProgress.ZIndex = 49  -- Behind button content
UI.chestOpenProgress.Parent = UI.chestOpenButton

local progressCorner = Instance.new("UICorner")
progressCorner.CornerRadius = UDim.new(0, 8)
progressCorner.Parent = UI.chestOpenProgress

-- Chest detection state
State.nearbyChest = nil

-- Function to check distance to chests
local function findNearbyChest()
	local character = player.Character
	if not character then return nil end
	
	local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
	if not humanoidRootPart then return nil end
	
	local playerPos = humanoidRootPart.Position
	
	-- Check for chests in Workspace.Loots
	local lootsFolder = workspace:FindFirstChild("Loots")
	if not lootsFolder then return nil end
	
	local closestChest = nil
	local closestDistance = math.huge
	
	for _, chestModel in ipairs(lootsFolder:GetChildren()) do
		if chestModel:IsA("Model") then
			local chestPrimaryPart = chestModel.PrimaryPart or chestModel:FindFirstChildWhichIsA("BasePart")
			if chestPrimaryPart then
				-- Get chest-specific activation distance from ChestConfig
				local chestConf = ChestConfig and ChestConfig.GetChest(chestModel.Name)
				local maxDistance = (chestConf and chestConf.activationDistance) or 8  -- Default to 8
				
				local distance = (playerPos - chestPrimaryPart.Position).Magnitude
				if distance < maxDistance and distance < closestDistance then
					closestDistance = distance
					closestChest = chestModel
				end
			end
		end
	end
	
	return closestChest
end

-- Helper to play animation on physical chest model in workspace
local function playPhysicalChestAnimation(chestModel, animName, looped)
	local animFolder = Services.ReplicatedStorage:FindFirstChild("Anim")
	local lootAnims = animFolder and animFolder:FindFirstChild("Loots")
	if not lootAnims then return end
	
	local chestType = chestModel.Name
	local chestAnims = lootAnims:FindFirstChild(chestType)
	if not chestAnims then return end
	
	local anim = chestAnims:FindFirstChild(animName)
	if not anim or not anim:IsA("Animation") then return end
	
	local animationController = chestModel:FindFirstChildOfClass("AnimationController") or chestModel:FindFirstChild("Humanoid")
	if not animationController then
		animationController = Instance.new("AnimationController")
		animationController.Parent = chestModel
	end
	
	local animator = animationController:FindFirstChildOfClass("Animator") or Instance.new("Animator", animationController)
	
	-- Check if already playing the exact same animation to avoid resets
	for _, track in ipairs(animator:GetPlayingAnimationTracks()) do
		if track.Animation == anim then
			return track
		end
	end
	
	local track = animator:LoadAnimation(anim)
	track.Priority = animName == "Idle" and Enum.AnimationPriority.Idle or Enum.AnimationPriority.Action
	track.Looped = looped or false
	track:Play()
	
	return track
end

-- Centralized logic to handle physical chest visuals (Global Sync)
local function handlePhysicalChestState(chestModel, isInitial)
	local isOpen = chestModel:GetAttribute("Open") == true
	local wasOpenedLocally = chestModel:GetAttribute("LocallyAnimated") == true
	
	if isOpen then
		if not wasOpenedLocally and not isInitial then
			-- TRANSITION: First time seeing it open in real-time
			local animFolder = Services.ReplicatedStorage:FindFirstChild("Anim")
			local lootAnims = animFolder and animFolder:FindFirstChild("Loots")
			if lootAnims then
				local openSound = lootAnims:FindFirstChild("OpenSound")
				if openSound and openSound:IsA("Sound") then
					openSound:Play()
				end
			end
			
			-- Mark as animated to prevent re-opening if player walks away and back
			chestModel:SetAttribute("LocallyAnimated", true)
			
			-- Play Open -> Idle sequence (Idle REQUIRED to hold open position)
			local openTrack = playPhysicalChestAnimation(chestModel, "Open", false)
			if openTrack then
				openTrack.Stopped:Once(function()
					-- Idle MUST loop to keep chest in open pose
					playPhysicalChestAnimation(chestModel, "Idle", true)
				end)
			else
				playPhysicalChestAnimation(chestModel, "Idle", true)
			end
		else
			-- INITIAL or ALREADY ANIMATED: Ensure Idle is playing to hold pose
			if not wasOpenedLocally then
				chestModel:SetAttribute("LocallyAnimated", true)
			end
			-- Idle keeps the chest visually open
			playPhysicalChestAnimation(chestModel, "Idle", true)
		end
	end
end

-- Setup listeners for all chests
local function setupChestAttributeListeners()
	local lootsFolder = workspace:FindFirstChild("Loots")
	if not lootsFolder then return end
	
	local function observeChest(chest)
		if chest:IsA("Model") then
			-- Initial check (jump to Idle if already open)
			handlePhysicalChestState(chest, true)
			-- Listen for changes (play Open transition)
			chest:GetAttributeChangedSignal("Open"):Connect(function()
				handlePhysicalChestState(chest, false)
			end)
		end
	end
	
	-- Observe existing chests
	for _, child in ipairs(lootsFolder:GetChildren()) do
		observeChest(child)
	end
	
	-- Observe new chests (if they spawn)
	lootsFolder.ChildAdded:Connect(observeChest)
end

-- Start listeners
task.spawn(setupChestAttributeListeners)

local function openChest(chestModel)
	if State.isPanelOpen then return end
	
	local chestType = chestModel.Name
	local chestConf = ChestConfig and ChestConfig.GetChest(chestType)
	
	if not chestConf then
		chestConf = {
			name = "Unknown Chest",
			openingDelay = 5,
			gridRows = 4,
			gridCols = 5,
		}
	end
	
	-- Update state
	State.isLootingChest = true
	State.currentChestModel = chestModel
	State.currentChestConfig = chestConf
	
	-- Recreate chest grid based on this chest's configuration
	recreateChestGrid()
	
	-- OPTIMIZATION: If chest is already opened locally, skip wait
	local isAlreadyOpened = chestModel:GetAttribute("Open") == true
	if isAlreadyOpened then
		-- Request server to open (to get loot)
		if Events.OpenChest then
			-- Only trigger reveal animation if this is a DIFFERENT chest
			if State.lastOpenedChest ~= chestModel then
				State.isFirstChestSync = true
				State.lastOpenedChest = chestModel
			end
			Events.OpenChest:FireServer(chestModel)
		end
		-- Play OpenChestIdle animation since we're skipping the wait
		playInventoryAnimation("OpenChestIdle", true)
		-- handlePhysicalChestState will ensure Idle is playing
		openPanel(true)
		return
	end
	
	-- Setup movement listener for looting phase
	local character = player.Character
	if character then
		local humanoid = character:FindFirstChildOfClass("Humanoid")
		if humanoid then
			if State.lootingMoveConnection then
				State.lootingMoveConnection:Disconnect()
			end
			State.lootingMoveConnection = humanoid.Running:Connect(function(speed)
				if speed > 0.1 and State.isLootingChest then
					cancelLooting()
				end
			end)
		end
	end

	UI.chestNameLabel.Text = chestConf.name
	
	-- Start player looting animation (The circular inventory progress/arms)
	-- ONLY if not already opened (Mobile/UX Fix: skip search for open chests)
	local openTrack = nil
	if not isAlreadyOpened then
		openTrack = playInventoryAnimation("OpenChest", false)
		if openTrack then
			openTrack.Stopped:Once(function()
				if State.isLootingChest then
					playInventoryAnimation("OpenChestIdle", true)
				end
			end)
		end
		
		-- Show "Opening..." on the button with progress animation
		if UI.chestOpenButton and UI.chestOpenLabel and UI.chestOpenProgress then
			-- Change button text
			UI.chestOpenLabel.Text = "Opening..."
			UI.chestOpenButton.Visible = true
			
			-- Reset and animate progress bar (left to right)
			UI.chestOpenProgress.Size = UDim2.new(0, 0, 1, 0)
			
			local progressTween = Services.TweenService:Create(
				UI.chestOpenProgress,
				TweenInfo.new(chestConf.openingDelay, Enum.EasingStyle.Linear),
				{ Size = UDim2.new(1, 0, 1, 0) }
			)
			progressTween:Play()
			
			-- Store tween for cancellation
			State.openingProgressTween = progressTween
		end
	else
		UI.chestOpenButton.Visible = false
	end
	
	-- Wait for opening delay
	State.lootingDelayTask = task.delay(chestConf.openingDelay, function()
		if not State.isLootingChest then return end
		
		-- Reset and hide the opening button
		if UI.chestOpenButton then
			UI.chestOpenButton.Visible = false
		end
		if UI.chestOpenLabel then
			UI.chestOpenLabel.Text = "OPEN"
		end
		if UI.chestOpenProgress then
			UI.chestOpenProgress.Size = UDim2.new(0, 0, 1, 0)
		end
		if State.openingProgressTween then
			State.openingProgressTween:Cancel()
			State.openingProgressTween = nil
		end
		
		-- REQUEST SERVER TO OPEN (Server will set "Open" attribute)
		-- Visuals (Sound/Anim) will trigger via handlePhysicalChestState listener
		if Events.OpenChest then
			-- Only trigger reveal animation if this is a DIFFERENT chest
			if State.lastOpenedChest ~= chestModel then
				State.isFirstChestSync = true
				State.lastOpenedChest = chestModel
			end
			Events.OpenChest:FireServer(chestModel)
		end
		
		if State.lootingMoveConnection then
			State.lootingMoveConnection:Disconnect()
			State.lootingMoveConnection = nil
		end
		
		State.lootingDelayTask = nil
		
		-- openPanel will be called by SyncChestLoot event handler
	end)
end

-- Chest Open button click handler
UI.chestOpenButton.MouseButton1Click:Connect(function()
	if State.nearbyChest then
		openChest(State.nearbyChest)
	end
end)

-- Chest detection loop
Services.RunService.Heartbeat:Connect(function()
	-- Security: If panel is open and looting a chest, check if still in range
	if State.isPanelOpen and State.isLootingChest and State.currentChestModel then
		local character = player.Character
		if character then
			local hrp = character:FindFirstChild("HumanoidRootPart")
			local chestPart = State.currentChestModel.PrimaryPart or State.currentChestModel:FindFirstChildWhichIsA("BasePart")
			if hrp and chestPart then
				local chestConf = State.currentChestConfig
				local maxDistance = (chestConf and chestConf.activationDistance) or 8
				local distance = (hrp.Position - chestPart.Position).Magnitude
				if distance > maxDistance + 2 then  -- Small buffer
					-- Force close panel - player walked away
					closePanel()
					return
				end
			end
		end
	end
	
	if State.isPanelOpen then
		UI.chestOpenButton.Visible = false
		return
	end
	
	local foundChest = findNearbyChest()
	
	if foundChest then
		State.nearbyChest = foundChest
		UI.chestOpenButton.Visible = true
	else
		State.nearbyChest = nil
		UI.chestOpenButton.Visible = false
	end
end)

-- Hover effects for chest button
UI.chestOpenButton.MouseEnter:Connect(function()
	Services.TweenService:Create(UI.chestOpenButton, TweenInfo.new(0.15), {BackgroundColor3 = Color3.fromRGB(30, 30, 30), BackgroundTransparency = 0.6}):Play()
end)
UI.chestOpenButton.MouseLeave:Connect(function()
	Services.TweenService:Create(UI.chestOpenButton, TweenInfo.new(0.15), {BackgroundColor3 = Color3.fromRGB(0, 0, 0), BackgroundTransparency = 0.6}):Play()
end)

-- ============================================================================
-- STORAGE SYSTEM (Mirrors Chest System)
-- ============================================================================

local storageLootItems = {} -- Track visual frames

-- Helper: Clear visual grid
local function clearStorageGridVisuals()
	for _, itemFrame in pairs(storageLootItems) do
		if itemFrame then itemFrame:Destroy() end
	end
	storageLootItems = {}
end

-- Create Storage Item Frame (Visual) - Mirrors createChestItemFrame
local function createStorageItemFrame(itemData)
	local itemFrame = Instance.new("Frame")
	itemFrame.Name = itemData.id
	itemFrame.Size = UDim2.new(0, itemData.width * Config.STORAGE.CELL_SIZE + (itemData.width - 1) * Config.STORAGE.CELL_PADDING, 
	                           0, itemData.height * Config.STORAGE.CELL_SIZE + (itemData.height - 1) * Config.STORAGE.CELL_PADDING)
	itemFrame.Position = UDim2.new(0, (itemData.col - 1) * (Config.STORAGE.CELL_SIZE + Config.STORAGE.CELL_PADDING), 
	                               0, (itemData.row - 1) * (Config.STORAGE.CELL_SIZE + Config.STORAGE.CELL_PADDING))
	
	-- Appearance (same as inventory/chest)
	local frameColor = ItemConfig.GetRarityFrameColor(itemData.rarity or "Common")
	itemFrame.BackgroundColor3 = frameColor
	itemFrame.BackgroundTransparency = ItemConfig.GetRarityFrameTransparency()
	itemFrame.BorderSizePixel = 0
	itemFrame.ZIndex = 15
	itemFrame.Active = true
	itemFrame.Parent = UI.storageGridFrame -- Must be defined in createStoragePanel or similar
	
	local stroke = Instance.new("UIStroke")
	stroke.Color = ItemConfig.GetRarityColor(itemData.rarity or "Common")
	stroke.Thickness = 1
	stroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
	stroke.Parent = itemFrame
	
	-- Gradient
	local darkerColor = Color3.fromRGB(frameColor.R*255*0.6, frameColor.G*255*0.6, frameColor.B*255*0.6)
	local gradient = Instance.new("UIGradient")
	gradient.Color = ColorSequence.new({ColorSequenceKeypoint.new(0, frameColor), ColorSequenceKeypoint.new(1, darkerColor)})
	gradient.Rotation = 45
	gradient.Parent = itemFrame
	
	-- Icon
	if itemData.icon and itemData.icon ~= "" and itemData.icon ~= "rbxassetid://0" then
		local icon = Instance.new("ImageLabel")
		icon.Size = UDim2.new(1,0,1,0)
		icon.BackgroundTransparency = 1
		icon.Image = itemData.icon
		icon.ScaleType = Enum.ScaleType.Fit
		icon.ZIndex = 16
		icon.Parent = itemFrame
	end
	
	-- Input Handling (matches createChestItemFrame pattern)
	local dragStarted = false
	local isPressed = false
	local longPressThread = nil
	local lastTapTime = 0
	local tapStartTime = 0
	local tapStartPos = nil
	
	itemFrame.InputBegan:Connect(function(input, gameProcessed)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			if State.isDragging then return end
			
			isPressed = true
			dragStarted = false
			tapStartTime = tick()
			tapStartPos = Vector2.new(input.Position.X, input.Position.Y)
			
			-- Long press for drag
			longPressThread = task.spawn(function()
				task.wait(Config.LONG_PRESS_DURATION or 0.4)
				if isPressed and not dragStarted and not State.isDragging then
					dragStarted = true
					startStorageDrag(itemData, itemFrame, Services.UserInputService:GetMouseLocation())
				end
			end)
			
			if input.UserInputType == Enum.UserInputType.Touch then
				State.activeTouchId = input
			end
		end
	end)
	
	itemFrame.InputChanged:Connect(function(input, gameProcessed)
		if not isPressed or State.isDragging then return end
		
		if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
			if tapStartPos then
				local currentPos = Vector2.new(input.Position.X, input.Position.Y)
				local distance = (currentPos - tapStartPos).Magnitude
				
				if not dragStarted and distance > (Config.TAP_THRESHOLD_DISTANCE or 10) then
					dragStarted = true
					if longPressThread then
						task.cancel(longPressThread)
						longPressThread = nil
					end
					startStorageDrag(itemData, itemFrame, Services.UserInputService:GetMouseLocation())
				end
			end
		end
	end)
	
	itemFrame.InputEnded:Connect(function(input, gameProcessed)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			if not isPressed then return end
			
			local now = tick()
			
			if not dragStarted and tapStartPos then
				local elapsed = now - tapStartTime
				local currentPos = Vector2.new(input.Position.X, input.Position.Y)
				local distance = (currentPos - tapStartPos).Magnitude
				
				if elapsed < 0.4 and distance < 20 then
					if now - lastTapTime < 0.3 then
						-- DOUBLE TAP: Move to inventory (requires selection first)
						if State.selectedItem and State.selectedItem.config.id == itemData.config.id then
							if Events.MoveToInventory then
								Events.MoveToInventory:FireServer(itemData.id, nil, nil)
							end
							
							if Data.storageItems[itemData.id] then
								Data.storageItems[itemData.id] = nil
								removeItemFromStorageGrid(itemData.id)
							end
							itemFrame:Destroy()
							
							lastTapTime = 0
							clearSelection()
						else
							-- Double-tap but not selected? Select it
							local pseudoData = {
								config = itemData.config,
								row = itemData.row, col = itemData.col,
								width = itemData.width, height = itemData.height,
								frame = itemFrame,
								isStorageItem = true
							}
							selectItem(pseudoData)
							lastTapTime = now
						end
					else
						-- SINGLE TAP: Selection
						local pseudoData = {
							config = itemData.config,
							row = itemData.row, col = itemData.col,
							width = itemData.width, height = itemData.height,
							frame = itemFrame,
							isStorageItem = true
						}
						
						if State.selectedItem and State.selectedItem.config.id == itemData.config.id then
							-- Already selected - toggle off (unselect)
							clearSelection()
						else
							selectItem(pseudoData)
						end
						lastTapTime = now
					end
				end
			end
			
			isPressed = false
			tapStartPos = nil
			dragStarted = false
			if longPressThread then
				task.cancel(longPressThread)
				longPressThread = nil
			end
		end
	end)
	
	return itemFrame
end

-- Setup Storage Slot Input (Inventory -> Storage via click/smart placement)
local function setupStorageSlotInput(slot, row, col)
	slot.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			if State.selectedItem and not State.isDragging then
				-- Check if storage slot is empty
				-- Need Data.storageGridData to be populated
				if not Data.storageGridData[row] or not Data.storageGridData[row][col] then
					-- If Inventory Item Selected -> Move to Storage (Grid click)
					if not State.selectedItem.isStorageItem and not State.selectedItem.isChestItem then
						-- Inventory to Storage
						if Events.MoveToStorage then
							-- Smart placement check can go here or let server handle
							Events.MoveToStorage:FireServer(State.selectedItem.config.id, row, col)
							
							-- Optimistic cleanup
							removeItemFromGrid(State.selectedItem.config.id)
							Data.inventoryItems[State.selectedItem.config.id] = nil
							if State.selectedItem.frame then State.selectedItem.frame:Destroy() end
							clearSelection()
						end
					elseif State.selectedItem.isStorageItem then
						-- Storage to Storage (Move within storage) - Use smart placement
						local itemWidth = State.selectedItem.width or 1
						local itemHeight = State.selectedItem.height or 1
						local itemId = State.selectedItem.config.id
						
						-- Remove from current position temporarily
						removeItemFromStorageGrid(itemId)
						
						-- Try to place at target position with rotation support
						local canPlace = canPlaceItemInStorage(itemWidth, itemHeight, row, col, itemId)
						local finalRow, finalCol, finalWidth, finalHeight = row, col, itemWidth, itemHeight
						local rotated = false
						
						if not canPlace and itemWidth ~= itemHeight then
							-- Try rotated
							if canPlaceItemInStorage(itemHeight, itemWidth, row, col, itemId) then
								canPlace = true
								finalWidth = itemHeight
								finalHeight = itemWidth
								rotated = true
							end
						end
						
						if canPlace then
							-- Update item position
							State.selectedItem.row = finalRow
							State.selectedItem.col = finalCol
							State.selectedItem.width = finalWidth
							State.selectedItem.height = finalHeight
							
							-- Update in Data.storageItems
							if Data.storageItems[itemId] then
								Data.storageItems[itemId].row = finalRow
								Data.storageItems[itemId].col = finalCol
								Data.storageItems[itemId].width = finalWidth
								Data.storageItems[itemId].height = finalHeight
							end
							
							-- Place in new position
							placeItemInStorageGrid(itemId, finalWidth, finalHeight, finalRow, finalCol)
							
							-- Update frame position
							if State.selectedItem.frame then
								State.selectedItem.frame.Size = UDim2.new(0, finalWidth * Config.STORAGE.CELL_SIZE + (finalWidth - 1) * Config.STORAGE.CELL_PADDING, 
								                                          0, finalHeight * Config.STORAGE.CELL_SIZE + (finalHeight - 1) * Config.STORAGE.CELL_PADDING)
								State.selectedItem.frame.Position = UDim2.new(0, (finalCol - 1) * (Config.STORAGE.CELL_SIZE + Config.STORAGE.CELL_PADDING), 
								                                               0, (finalRow - 1) * (Config.STORAGE.CELL_SIZE + Config.STORAGE.CELL_PADDING))
							end
							
							-- Notify server
							if Events.UpdateStorageItemPosition then
								Events.UpdateStorageItemPosition:FireServer(itemId, finalRow, finalCol, rotated)
							end
							
							clearSelection()
						else
							-- Can't place, restore original position
							placeItemInStorageGrid(itemId, itemWidth, itemHeight, State.selectedItem.row, State.selectedItem.col)
							
							-- Flash red
							local originalColor = slot.BackgroundColor3
							slot.BackgroundColor3 = Color3.fromRGB(100, 40, 40)
							Services.TweenService:Create(slot, TweenInfo.new(0.3), { BackgroundColor3 = originalColor }):Play()
						end
					end
				end
			end
		end
	end)
end

-- ============================================================================
-- CHEST LOOT SYNC HANDLER
-- ============================================================================

local chestLootItems = {}  -- Track items displayed in chest grid

-- Clear chest grid items
local function clearChestGrid()
	for _, itemFrame in pairs(chestLootItems) do
		if itemFrame and itemFrame.Parent then
			itemFrame:Destroy()
		end
	end
	chestLootItems = {}
	State.isRevealSequenceRunning = false
end

-- Create chest item frame (similar to inventory item)
local function createChestItemFrame(itemData)
	local itemFrame = Instance.new("Frame")
	itemFrame.Name = itemData.id
	
	-- Use dynamic chest config for cell size/padding (fallback to default if not set)
	local chestConf = State.currentChestConfig or { gridRows = 6, gridCols = 6 }
	local cellSize = Config.CHEST.CELL_SIZE
	local cellPadding = Config.CHEST.CELL_PADDING
	
	itemFrame.Size = UDim2.new(0, itemData.width * cellSize + (itemData.width - 1) * cellPadding, 
	                           0, itemData.height * cellSize + (itemData.height - 1) * cellPadding)
	itemFrame.Position = UDim2.new(0, (itemData.col - 1) * (cellSize + cellPadding), 
	                               0, (itemData.row - 1) * (cellSize + cellPadding))
	
	-- Use RarityFrameColors for background
	local frameColor = ItemConfig.GetRarityFrameColor(itemData.rarity or "Common")
	local frameTransparency = ItemConfig.GetRarityFrameTransparency()
	itemFrame.BackgroundColor3 = frameColor
	itemFrame.BackgroundTransparency = frameTransparency
	itemFrame.BorderSizePixel = 0
	itemFrame.ZIndex = 15
	itemFrame.Active = true  -- Frame needs Active=true for robust input began
	itemFrame.Parent = UI.gridContainerChest
	
	-- Stroke color (using RarityColors for stroke/border)
	local strokeColor = ItemConfig.GetRarityColor(itemData.rarity or "Common")
	
	-- Gradient (based on frame color for visual effect)
	local darkerColor = Color3.fromRGB(
		math.floor(frameColor.R * 255 * 0.6),
		math.floor(frameColor.G * 255 * 0.6),
		math.floor(frameColor.B * 255 * 0.6)
	)
	local gradient = Instance.new("UIGradient")
	gradient.Color = ColorSequence.new({
		ColorSequenceKeypoint.new(0, frameColor),
		ColorSequenceKeypoint.new(1, darkerColor),
	})
	gradient.Rotation = 45
	gradient.Parent = itemFrame
	
	-- Stroke (using RarityColors for stroke/border) - hidden initially for reveal
	local stroke = Instance.new("UIStroke")
	stroke.Name = "ItemStroke"
	stroke.Color = strokeColor
	stroke.Thickness = 1
	stroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
	stroke.Transparency = 1  -- Hidden during reveal
	stroke.Parent = itemFrame
	
	-- Icon
	local iconImage = nil
	if itemData.icon and itemData.icon ~= "" and itemData.icon ~= "rbxassetid://0" then
		iconImage = Instance.new("ImageLabel")
		iconImage.Name = "Icon"
		iconImage.Size = UDim2.new(1, 0, 1, 0)
		iconImage.Position = UDim2.new(0, 0, 0, 0)
		iconImage.BackgroundTransparency = 1
		iconImage.Image = itemData.icon
		iconImage.ScaleType = Enum.ScaleType.Fit
		iconImage.ZIndex = 16
		iconImage.Parent = itemFrame
	end
	
	-- SIMPLE LOGIC: 
	-- isFirstChestSync = true (chest first open)  mystery box + hidden icon
	-- isFirstChestSync = false (deposit update)  no mystery box, icon visible
	if State.isFirstChestSync then
		-- First chest open: hide icon, show mystery box
		if iconImage then
			iconImage.Visible = false
		end
		stroke.Transparency = 1  -- Hide stroke during reveal
		
		local mysteryBox = Instance.new("ImageLabel")
		mysteryBox.Name = "MysteryBox"
		mysteryBox.Size = UDim2.new(1, 0, 1, 0)
		mysteryBox.Position = UDim2.new(0, 0, 0, 0)
		mysteryBox.BackgroundTransparency = 1
		mysteryBox.Image = ItemConfig.GetMysteryBoxAsset(itemData.width or 1, itemData.height or 1)
		mysteryBox.ScaleType = Enum.ScaleType.Fit
		mysteryBox.ZIndex = 17
		mysteryBox.Parent = itemFrame
		
		itemFrame:SetAttribute("IsRevealing", true)
	else
		-- Deposit update: show icon immediately, no mystery box
		if iconImage then
			iconImage.Visible = true
		end
		stroke.Transparency = 0
		itemFrame:SetAttribute("IsRevealing", false)
	end
	

	
	-- Standardized Input Handling for Mobile (Match Inventory logic)
	local dragStarted = false
	local isPressed = false
	local longPressThread = nil
	local lastTapTime = 0
	
	itemFrame.InputBegan:Connect(function(input, gameProcessed)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			-- Block interaction during reveal animation
			if itemFrame:GetAttribute("IsRevealing") then return end
			if State.isDragging then return end
			
			isPressed = true
			dragStarted = false
			tapStartTime = tick()
			tapStartPos = Vector2.new(input.Position.X, input.Position.Y)
			
			-- Start same long-press pattern as inventory
			longPressThread = task.spawn(function()
				task.wait(Config.LONG_PRESS_DURATION)
				if isPressed and not dragStarted and not State.isDragging then
					-- For chest items, we just trigger the drag after duration too
					dragStarted = true
					startChestDrag(itemData, itemFrame, Services.UserInputService:GetMouseLocation())
				end
			end)
			
			if input.UserInputType == Enum.UserInputType.Touch then
				State.activeTouchId = input
			end
		end
	end)
	
	itemFrame.InputChanged:Connect(function(input, gameProcessed)
		if not isPressed or State.isDragging then return end
		
		if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
			if tapStartPos then
				local currentPos = Vector2.new(input.Position.X, input.Position.Y)
				local distance = (currentPos - tapStartPos).Magnitude
				
				-- If moved beyond threshold, start drag (cancel long-press)
				if not dragStarted and distance > Config.TAP_THRESHOLD_DISTANCE then
					dragStarted = true
					if longPressThread then
						task.cancel(longPressThread)
						longPressThread = nil
					end
					startChestDrag(itemData, itemFrame, Services.UserInputService:GetMouseLocation())
				end
			end
		end
	end)
	
	itemFrame.InputEnded:Connect(function(input, gameProcessed)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			if not isPressed then return end
			
			local now = tick()
			-- Let global InputEnded handler manage endDrag to prevent premature snap-back
			if not dragStarted and tapStartPos then
				-- Handle double-tap or selection (only if not dragging)
				local elapsed = now - tapStartTime
				local currentPos = Vector2.new(input.Position.X, input.Position.Y)
				local distance = (currentPos - tapStartPos).Magnitude
				
				if elapsed < 0.4 and distance < 20 then
					if now - lastTapTime < 0.3 then
						-- DOUBLE TAP: Collect - but first check if inventory has space
						local itemWidth = itemData.width or 1
						local itemHeight = itemData.height or 1
						
						-- Check if inventory has space for this item
						if not canFitItemAnywhere(itemWidth, itemHeight) then
							-- No space in inventory - don't collect, keep item in chest
							lastTapTime = 0
							return
						end
						
						-- Has space - proceed with collection
						if Events.CollectItem then
							local chestPos = State.currentChestModel and State.currentChestModel.PrimaryPart and State.currentChestModel.PrimaryPart.Position
							Events.CollectItem:FireServer(itemData.name, chestPos)
							
							-- CRITICAL: Clear chest grid data (real-time update fix)
							removeItemFromChestGrid(itemData.id)
							Data.chestItems[itemData.id] = nil
							
							itemFrame:Destroy()
						end
						lastTapTime = 0
					else
						-- SINGLE TAP: Selection
						local pseudoItemData = {
							config = {
								id = itemData.id,
								name = itemData.name,
								icon = itemData.icon,
								weight = itemData.weight,
								price = itemData.price,
								rarity = itemData.rarity,
							},
							row = itemData.row,
							col = itemData.col,
							width = itemData.width,
							height = itemData.height,
							frame = itemFrame,
							isChestItem = true
						}
						
						if State.selectedItem and State.selectedItem.config.id == itemData.id then
							clearSelection()
						else
							selectItem(pseudoItemData)
						end
						lastTapTime = now
					end
				end
			end
			
			isPressed = false
			tapStartPos = nil
			dragStarted = false
			if longPressThread then
				task.cancel(longPressThread)
				longPressThread = nil
			end
		end
	end)
	
	return itemFrame
end

-- Reveal a single chest item with animated search icon
local function revealChestItem(itemFrame, itemData)
	if not itemFrame or not itemFrame.Parent then return end
	
	-- Get reveal delay based on rarity
	local revealDelay = ItemConfig.GetRevealDelay(itemData.rarity or "Common")
	
	-- Create search icon
	local searchIcon = Instance.new("ImageLabel")
	searchIcon.Name = "SearchIcon"
	searchIcon.Size = UDim2.new(1, 0, 1, 0)
	searchIcon.Position = UDim2.new(0, 0, 0, 0)
	searchIcon.AnchorPoint = Vector2.new(0.5, 0.5)
	searchIcon.BackgroundTransparency = 1
	searchIcon.Image = "rbxassetid://102779162979818"
	searchIcon.ScaleType = Enum.ScaleType.Fit
	searchIcon.ZIndex = 18  -- Above mystery box
	searchIcon.Parent = itemFrame
	
	-- Animate search icon in circular orbit (smaller radius)
	local orbitRadius = math.min(itemFrame.AbsoluteSize.X, itemFrame.AbsoluteSize.Y) * 0.075
	local orbitSpeed = 2  -- seconds per full rotation
	
	local orbitConnection
	local startTime = tick()
	orbitConnection = Services.RunService.Heartbeat:Connect(function()
		if not searchIcon.Parent then
			orbitConnection:Disconnect()
			return
		end
		
		local elapsed = tick() - startTime
		local angle = (elapsed / orbitSpeed) * math.pi * 2
		
		-- Calculate orbit position (circular motion around center)
		local offsetX = math.cos(angle) * orbitRadius
		local offsetY = math.sin(angle) * orbitRadius
		
		searchIcon.Position = UDim2.new(0.5, offsetX, 0.5, offsetY)
	end)
	
	-- Wait for reveal delay
	task.wait(revealDelay)
	
	-- Stop orbit animation
	if orbitConnection then
		orbitConnection:Disconnect()
	end
	
	-- Remove search icon
	if searchIcon and searchIcon.Parent then
		searchIcon:Destroy()
	end
	
	-- Find and remove mystery box
	local mysteryBox = itemFrame:FindFirstChild("MysteryBox")
	if mysteryBox then
		mysteryBox:Destroy()
	end
	
	-- Show actual icon
	local icon = itemFrame:FindFirstChild("Icon")
	if icon then
		icon.Visible = true
	end
	
	-- Show stroke (rarity border)
	local stroke = itemFrame:FindFirstChild("ItemStroke")
	if stroke then
		stroke.Transparency = 0
	end
	
	-- Enable interactions
	itemFrame:SetAttribute("IsRevealing", false)
end

-- Start sequential reveal animation for all chest items
local function startChestRevealSequence()
	if State.isRevealSequenceRunning then
		return
	end
	
	State.isRevealSequenceRunning = true
	task.spawn(function()
		-- Get all chest items and sort by position
		local itemsToReveal = {}
		for itemId, itemData in pairs(Data.chestItems) do
			local frame = chestLootItems[itemId]
			-- Only include items that have MysteryBox (need to be revealed)
			if frame and frame.Parent and frame:FindFirstChild("MysteryBox") then
				table.insert(itemsToReveal, {
					frame = frame,
					data = itemData,
				})
			end
		end
		
		-- Sort by position (row then column)
		table.sort(itemsToReveal, function(a, b)
			if a.data.row == b.data.row then
				return a.data.col < b.data.col
			else
				return a.data.row < b.data.row
			end
		end)
		
		-- Animate each item sequentially
		for _, item in ipairs(itemsToReveal) do
			if item.frame and item.frame.Parent then
				revealChestItem(item.frame, item.data.config)
			end
		end
		
		State.isRevealSequenceRunning = false
	end)
end


-- Handle chest loot sync from server
if Events.SyncChestLoot then
	Events.SyncChestLoot.OnClientEvent:Connect(function(chestData)
		if not chestData or not chestData.items then 
			return 
		end
		
		-- ALWAYS clear grid first to prevent any duplication
		clearChestGrid()
		initializeChestGridData()
		
		-- Create all items from server data
		for _, itemData in ipairs(chestData.items) do
			local frame = createChestItemFrame(itemData)
			chestLootItems[itemData.id] = frame
			
			Data.chestItems[itemData.id] = {
				config = {
					id = itemData.id,
					name = itemData.name,
					icon = itemData.icon,
					weight = itemData.weight,
					price = itemData.price,
					rarity = itemData.rarity,
				},
				row = itemData.row,
				col = itemData.col,
				width = itemData.width,
				height = itemData.height,
				frame = frame,
			}
			
			placeItemInChestGrid(itemData.id, itemData.width, itemData.height, itemData.row, itemData.col)
		end
		
		-- Only run reveal animation on first sync
		if State.isFirstChestSync then
			startChestRevealSequence()
			State.isFirstChestSync = false
		end
		
		
		-- UI Trigger: If the player currently waiting for this chest gets loot, open the panel
		if State.isLootingChest then
			-- Cancel any pending delay task
			if State.lootingDelayTask then
				task.cancel(State.lootingDelayTask)
				State.lootingDelayTask = nil
			end
			
			-- Stop current inventory animation
			if State.currentInventoryAnimTrack then
				State.currentInventoryAnimTrack:Stop()
			end
			
			-- Clean up looting connection
			if State.lootingMoveConnection then
				State.lootingMoveConnection:Disconnect()
				State.lootingMoveConnection = nil
			end
			
			-- Open panel for everyone who requested it (if not already showing)
			if not State.isPanelOpen then
				openPanel(true)
			end
			
			-- Reset looting flag
			State.isLootingChest = false
		end
	end)
end

-- ============================================================================
-- STORAGE SYSTEM
-- ============================================================================

local function initializeStorageGridData()
	Data.storageGridData = {}
	for row = 1, Config.STORAGE.GRID_ROWS do
		Data.storageGridData[row] = {}
		for col = 1, Config.STORAGE.GRID_COLS do
			Data.storageGridData[row][col] = nil
		end
	end
end

initializeStorageGridData()

local function placeItemInStorageGrid(itemId, width, height, row, col)
	for r = row, row + height - 1 do
		for c = col, col + width - 1 do
			if Data.storageGridData[r] then
				Data.storageGridData[r][c] = itemId
			end
		end
	end
end

local function removeItemFromStorageGrid(itemId)
	for r = 1, Config.STORAGE.GRID_ROWS do
		for c = 1, Config.STORAGE.GRID_COLS do
			if Data.storageGridData[r] and Data.storageGridData[r][c] == itemId then
				Data.storageGridData[r][c] = nil
			end
		end
	end
end

local function canPlaceInStorageGrid(row, col, width, height, excludeId)
	if row < 1 or col < 1 then return false end
	if row + height - 1 > Config.STORAGE.GRID_ROWS then return false end
	if col + width - 1 > Config.STORAGE.GRID_COLS then return false end
	
	for r = row, row + height - 1 do
		for c = col, col + width - 1 do
			local occupant = Data.storageGridData[r] and Data.storageGridData[r][c]
			if occupant and occupant ~= excludeId then
				return false
			end
		end
	end
	return true
end

-- ============================================================================
-- STORAGE CONTAINER (delegating to UIManager)
-- ============================================================================

UIManager.createStorageContainer(Data, Config, setupStorageSlotInput)

-- Handle Storage Sync
if Events.SyncStorage then
	Events.SyncStorage.OnClientEvent:Connect(function(storageData)
		clearStorageGridVisuals()
		initializeStorageGridData()
		
		if not storageData or not storageData.items then return end
		
		for _, itemInfo in ipairs(storageData.items) do
			-- Get base config from ItemConfig if available
			local baseConfig = ItemConfig[itemInfo.itemId or itemInfo.name] or ItemConfig.GetItem(itemInfo.itemId or itemInfo.name)
			
			-- Reconstruct item data for creation with FULL config
			local itemData = {
				id = itemInfo.id,
				config = {
					id = itemInfo.id,
					itemId = itemInfo.itemId or itemInfo.name,
					name = itemInfo.name,
					icon = itemInfo.icon or (baseConfig and baseConfig.icon) or "",
					rarity = itemInfo.rarity or (baseConfig and baseConfig.rarity) or "Common",
					width = itemInfo.width or (baseConfig and baseConfig.width) or 1,
					height = itemInfo.height or (baseConfig and baseConfig.height) or 1,
					weight = itemInfo.weight or (baseConfig and baseConfig.weight) or 0.15,
					price = itemInfo.price or (baseConfig and baseConfig.price) or 50,
					description = (baseConfig and baseConfig.description) or "A stored item."
				},
				name = itemInfo.name,
				itemId = itemInfo.itemId or itemInfo.name,
				icon = itemInfo.icon or (baseConfig and baseConfig.icon) or "",
				rarity = itemInfo.rarity or (baseConfig and baseConfig.rarity) or "Common",
				row = itemInfo.row,
				col = itemInfo.col,
				width = itemInfo.width or (baseConfig and baseConfig.width) or 1,
				height = itemInfo.height or (baseConfig and baseConfig.height) or 1,
				weight = itemInfo.weight or (baseConfig and baseConfig.weight) or 0.15,
				price = itemInfo.price or (baseConfig and baseConfig.price) or 50
			}
			
			local frame = createStorageItemFrame(itemData)
			storageLootItems[itemData.id] = frame
			Data.storageItems[itemData.id] = itemData
			placeItemInStorageGrid(itemData.id, itemData.width, itemData.height, itemData.row, itemData.col)
		end
	end)
end

-- ============================================================================
-- STORAGE INTERACTION LOGIC (Restored)
-- ============================================================================

UIManager.createStorageOpenButton()

local function findNearbyStorage()
	local character = player.Character
	if not character then return nil end
	
	local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
	if not humanoidRootPart then return nil end
	
	local playerPos = humanoidRootPart.Position
	
	local safeZone = workspace:FindFirstChild("SafeZone")
	if not safeZone then return nil end
	
	local storage = safeZone:FindFirstChild("Storage")
	if not storage then return nil end
	
	local trigger = storage:FindFirstChild("TriggerStorage")
	if not trigger or not trigger:IsA("BasePart") then return nil end
	
	local distance = (playerPos - trigger.Position).Magnitude
	if distance < 10 then
		return trigger
	end
	
	return nil
end

local function openStoragePanel()
	if State.isPanelOpen and not State.isStorageOpen then return end
	
	State.isStorageOpen = true
	
	UI.storageContainer.Visible = true
	
	-- Hide Chest Container when Storage is open
	if UI.ChestContainer then
		UI.ChestContainer.Visible = false
	end
	
	if UI.PlayerContainer then
		UI.PlayerContainer.Visible = false
	end
	
	if not State.isPanelOpen then
		if UI.blurEffect then
			UI.blurEffect.Enabled = true
		end
		
		-- Reset UI properties for full display
		UI.mainPanel.BackgroundTransparency = 0
		UI.mainPanel.AnchorPoint = Vector2.new(0.5, 0.5)
		UI.mainPanel.Position = UDim2.new(0.5, 0, 0.5, 0)
		UI.mainPanel.Visible = true
		UI.panelScale.Scale = 1  -- Ensure full size
		
		State.isPanelOpen = true
		UI.touchBlocker.Visible = true
		
		-- Also ensure Active is true
		UI.mainPanel.Active = true
	end
end

local function closeStoragePanel()
	State.isStorageOpen = false
	UI.storageContainer.Visible = false
	
	if UI.PlayerContainer then
		UI.PlayerContainer.Visible = true
	end
end

State.storageOpeningTween = nil

UI.storageOpenButton.MouseButton1Click:Connect(function()
	if State.nearbyStorage then
		-- Already opening?
		if State.storageOpeningTween then return end
		
		-- Start opening animation (1 second)
		UI.storageOpenLabel.Text = "Opening..."
		UI.storageOpenProgress.Size = UDim2.new(0, 0, 1, 0)
		
		local progressTween = Services.TweenService:Create(
			UI.storageOpenProgress,
			TweenInfo.new(1, Enum.EasingStyle.Linear),
			{ Size = UDim2.new(1, 0, 1, 0) }
		)
		State.storageOpeningTween = progressTween
		progressTween:Play()
		
		progressTween.Completed:Connect(function(playbackState)
			if playbackState == Enum.PlaybackState.Completed then
				openStoragePanel()
				UI.storageOpenLabel.Text = "STORAGE"
				UI.storageOpenProgress.Size = UDim2.new(0, 0, 1, 0)
			end
			State.storageOpeningTween = nil
		end)
	end
end)

Services.RunService.Heartbeat:Connect(function()
	if State.isPanelOpen and State.isStorageOpen and State.nearbyStorage then
		local character = player.Character
		if character then
			local hrp = character:FindFirstChild("HumanoidRootPart")
			if hrp and State.nearbyStorage and State.nearbyStorage:IsA("BasePart") then
				local distance = (hrp.Position - State.nearbyStorage.Position).Magnitude
				if distance > 12 then
					closeStoragePanel()
					closePanel()
					return
				end
			end
		end
	end
	
	if State.isPanelOpen then
		UI.storageOpenButton.Visible = false
		return
	end
	
	if State.isLootingChest then
		UI.storageOpenButton.Visible = false
		return
	end
	
	local foundStorage = findNearbyStorage()
	
	if foundStorage then
		State.nearbyStorage = foundStorage
		UI.storageOpenButton.Visible = true
	else
		State.nearbyStorage = nil
		UI.storageOpenButton.Visible = false
	end
end)