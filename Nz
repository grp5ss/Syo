-- GridInventory.lua
-- LocalScript for grid-based inventory system with drag-and-drop
-- Place in StarterPlayerScripts

local player = game:GetService("Players").LocalPlayer
local Services = {
	Players = game:GetService("Players"),
	TweenService = game:GetService("TweenService"),
	UserInputService = game:GetService("UserInputService"),
	RunService = game:GetService("RunService"),
	ReplicatedStorage = game:GetService("ReplicatedStorage"),
	Lighting = game:GetService("Lighting"),
	playerGui = player:WaitForChild("PlayerGui"),
}

-- ============================================================================
-- CONFIGURATION & TABLES
-- ============================================================================

-- RigsBackpackConfig for shared grid dimensions with server
local RigsBackpackConfig = require(Services.ReplicatedStorage:WaitForChild("RigsBackpackConfig"))
local currentRig = RigsBackpackConfig.GetRig("Default")

local Config = {
	GRID_COLS = currentRig.gridCols,
	GRID_ROWS = currentRig.gridRows,
	CELL_SIZE = currentRig.cellSize,
	CELL_PADDING = currentRig.cellPadding,
	DROPPED_ITEM_DISTANCE = 5,  -- Fixed distance for dropped items
	DRAG_SCROLL_EDGE_TOP = 120,   -- Larger area for scrolling UP
	DRAG_SCROLL_EDGE_BOTTOM = 50, -- Smaller area for scrolling DOWN
	DRAG_SCROLL_SPEED = 12,
	ARMOR_SLOT_SIZE = 50,
	PANEL_PADDING = 20,
	UI = {
		invBtnSize = UDim2.new(0, 57, 0, 66),
		invBtnPos = UDim2.new(0, 15, 0.5, 39),
		invEmojiSize = 28,
		invLabelSize = 12,
		titleTextSize = 18,
		closeBtnSize = UDim2.new(0, 32, 0, 32),
	},
	CHEST = {
		GRID_ROWS = 6,
		GRID_COLS = 6,
		CELL_SIZE = 50,
		CELL_PADDING = 4,
	},
	STORAGE = {
		GRID_ROWS = 11,
		GRID_COLS = 6,
		CELL_SIZE = 50,
		CELL_PADDING = 4,
	},
	LONG_PRESS_DURATION = 0.4,
	TAP_THRESHOLD_TIME = 0.2,
	TAP_THRESHOLD_DISTANCE = 10,
}


local Data = {
	gridData = {},
	inventoryItems = {},
	chestGridData = {},
	chestItems = {},
	storageGridData = {},
	storageItems = {},
}

local State = {
	isDragging = false,
	draggedItem = nil,
	dragGhost = nil,
	originalSlot = { row = 0, col = 0 },
	selectedItem = nil,
	selectionHighlight = nil,
	isAutoScrolling = false,
	autoScrollDirection = 0,
	autoScrollIntensity = 0,
	lastDragPosition = nil,
	isPanelOpen = false,
	isLootingChest = false,
	currentChestModel = nil,
	currentChestConfig = nil,
	currentInventoryAnimTrack = nil,
	movementConnection = nil,
	itemInfoPopup = nil,
	longPressStartTime = nil,
	longPressItem = nil,
	activeTouchId = nil,
	isRevealSequenceRunning = false,
	isFirstChestSync = true,
	lastOpenedChest = nil,  -- Track which chest was last opened
	tapStartTime = 0,
	tapStartPos = Vector2.new(0, 0),
	lootingDelayTask = nil,
	lootingMoveConnection = nil,
	dragSource = nil,
	dragSourceChestData = nil,
	isStorageOpen = false,
	nearbyStorage = nil,
}

local UI = {
	screenGui = nil,
	mainPanel = nil,
	actionBar = nil,
	itemInfoModal = nil,
	chestOpenButton = nil,
	blurEffect = nil,
	infoStroke = nil,
	dropStroke = nil,
}

-- Remote events (will be created by server)
local Remotes = Services.ReplicatedStorage:WaitForChild("Remotes", 10)
local Events = {
	CollectItem = Remotes and Remotes:WaitForChild("CollectItem", 5),
	SyncInventory = Remotes and Remotes:WaitForChild("SyncInventory", 5),
	InventoryFull = Remotes and Remotes:WaitForChild("InventoryFull", 5),
	DropItem = Remotes and Remotes:WaitForChild("DropItem", 5),
	OpenChest = Remotes and Remotes:WaitForChild("OpenChest", 5),
	SyncChestLoot = Remotes and Remotes:WaitForChild("SyncChestLoot", 5),
	ArmorEquip = Remotes and Remotes:WaitForChild("ArmorEquipEvent", 5),
	ArmorSync = Remotes and Remotes:WaitForChild("ArmorSyncEvent", 5),
	SyncStorage = Remotes and Remotes:WaitForChild("SyncStorage", 5),
	MoveToStorage = Remotes and Remotes:WaitForChild("MoveToStorage", 5),
	MoveToInventory = Remotes and Remotes:WaitForChild("MoveToInventory", 5),
}

-- Item Configuration (Shared Module)
local ItemConfig = require(Services.ReplicatedStorage:WaitForChild("ItemConfig"))

-- Chest Configuration (Shared Module) - needed for chest detection
local ChestConfig = require(Services.ReplicatedStorage:WaitForChild("ChestConfig", 5))

-- Initialize gridData
for row = 1, Config.GRID_ROWS do
	Data.gridData[row] = {}
	for col = 1, Config.GRID_COLS do
		Data.gridData[row][col] = nil
	end
end

-- ============================================================================
-- CREATE MAIN UI
-- ============================================================================

local function createBaseUI()
	UI.screenGui = Instance.new("ScreenGui")
	UI.screenGui.Name = "GridInventoryUI"
	UI.screenGui.ResetOnSpawn = false
	UI.screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	UI.screenGui.IgnoreGuiInset = true
	UI.screenGui.DisplayOrder = 100
	UI.screenGui.Parent = Services.playerGui

	UI.uiScale = Instance.new("UIScale")
	UI.uiScale.Name = "ResponsiveScale"
	UI.uiScale.Scale = 1
	UI.uiScale.Parent = UI.screenGui

	local function updateScale()
		local camera = workspace.CurrentCamera
		if not camera then return end
		local viewport = camera.ViewportSize
		local minDimension = math.min(viewport.X, viewport.Y)
		local scale = math.clamp(minDimension / 700, 0.7, 1.3)
		UI.uiScale.Scale = scale
	end

	workspace.CurrentCamera:GetPropertyChangedSignal("ViewportSize"):Connect(updateScale)
	task.spawn(updateScale)
end

createBaseUI()

-- Lighting effects
UI.blurEffect = Services.Lighting:FindFirstChild("Blur")

local function createInventoryButton()
	-- Inventory Button
	UI.invButton = Instance.new("TextButton")
	UI.invButton.Name = "InventoryButton"
	UI.invButton.Size = Config.UI.invBtnSize
	UI.invButton.Position = Config.UI.invBtnPos
	UI.invButton.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	UI.invButton.BorderSizePixel = 0
	UI.invButton.Text = ""
	UI.invButton.Parent = UI.screenGui

	local invCorner = Instance.new("UICorner")
	invCorner.CornerRadius = UDim.new(0, 10)
	invCorner.Parent = UI.invButton

	local invStroke = Instance.new("UIStroke")
	invStroke.Color = Color3.fromRGB(139, 92, 246)
	invStroke.Thickness = 2
	invStroke.Parent = UI.invButton

	local invEmoji = Instance.new("TextLabel")
	invEmoji.Size = UDim2.new(1, 0, 0, 40)
	invEmoji.Position = UDim2.new(0, 0, 0, 2)
	invEmoji.BackgroundTransparency = 1
	invEmoji.Text = "ðŸ“¦"
	invEmoji.TextSize = Config.UI.invEmojiSize
	invEmoji.Font = Enum.Font.GothamBold
	invEmoji.Parent = UI.invButton

	local invLabel = Instance.new("TextLabel")
	invLabel.Size = UDim2.new(1, 0, 0, 20)
	invLabel.Position = UDim2.new(0, 0, 0, 42)
	invLabel.BackgroundTransparency = 1
	invLabel.Text = "BAG"
	invLabel.TextColor3 = Color3.new(1, 1, 1)
	invLabel.TextSize = Config.UI.invLabelSize
	invLabel.Font = Enum.Font.GothamBold
	invLabel.Parent = UI.invButton

	-- TOUCH BLOCKER (Mobile - prevents camera movement when inventory is open)
	UI.touchBlocker = Instance.new("Frame")
	UI.touchBlocker.Name = "TouchBlocker"
	UI.touchBlocker.Size = UDim2.new(1, 0, 1, 0)
	UI.touchBlocker.Position = UDim2.new(0, 0, 0, 0)
	UI.touchBlocker.BackgroundColor3 = Color3.new(0, 0, 0)
	UI.touchBlocker.BackgroundTransparency = 0.5
	UI.touchBlocker.BorderSizePixel = 0
	UI.touchBlocker.Visible = false
	UI.touchBlocker.ZIndex = 9  -- Below panel
	UI.touchBlocker.Active = true  -- This sinks all touch input
	UI.touchBlocker.Parent = UI.screenGui
end

createInventoryButton()

-- ============================================================================
-- MAIN PANEL
-- ============================================================================

local function createMainPanel()
	UI.mainPanel = Instance.new("Frame")
	UI.mainPanel.Name = "MainPanel"
	UI.mainPanel.Size = UDim2.new(1, 0, 1, 0)  -- Full screen
	UI.mainPanel.Position = UDim2.new(0, 0, 0, 0)  -- Top-left corner
	UI.mainPanel.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	UI.mainPanel.BorderSizePixel = 0
	UI.mainPanel.Visible = false
	UI.mainPanel.ZIndex = 10
	UI.mainPanel.ClipsDescendants = true  -- Prevent child overflow
	UI.mainPanel.Parent = UI.screenGui

	UI.panelScale = Instance.new("UIScale")
	UI.panelScale.Scale = 0.8
	UI.panelScale.Parent = UI.mainPanel



	-- White gradient on UI.mainPanel (white at top, fading down)
	local panelGradient = Instance.new("UIGradient")
	panelGradient.Color = ColorSequence.new({
		ColorSequenceKeypoint.new(0, Color3.new(1, 1, 1)),      -- White at top
		ColorSequenceKeypoint.new(0.3, Color3.fromRGB(30, 30, 40)),  -- Dark gray
		ColorSequenceKeypoint.new(1, Color3.new(0, 0, 0)),      -- Black at bottom
	})
	panelGradient.Rotation = 90  -- Top to bottom
	panelGradient.Parent = UI.mainPanel

	-- Background ImageLabel (same size as UI.mainPanel, for custom background image)
	local panelBackgroundImage = Instance.new("ImageLabel")
	panelBackgroundImage.Name = "BackgroundImage"
	panelBackgroundImage.Size = UDim2.new(1, 0, 1, 0)  -- Full size
	panelBackgroundImage.Position = UDim2.new(0, 0, 0, 0)
	panelBackgroundImage.BackgroundTransparency = 1
	panelBackgroundImage.Image = "rbxassetid://115143845524149"  -- Background image
	panelBackgroundImage.ScaleType = Enum.ScaleType.Stretch
	panelBackgroundImage.ZIndex = 1  -- Lowest level, behind all other content
	panelBackgroundImage.Parent = UI.mainPanel


	-- Close button
	UI.closeButton = Instance.new("TextButton")
	UI.closeButton.Name = "CloseButton"
	UI.closeButton.Size = Config.UI.closeBtnSize
	UI.closeButton.Position = UDim2.new(1, -42, 0, 8)
	UI.closeButton.BackgroundColor3 = Color3.fromRGB(180, 50, 50)
	UI.closeButton.BackgroundTransparency = 1 -- Made fully transparent background
	UI.closeButton.BorderSizePixel = 0
	UI.closeButton.Text = "X"
	UI.closeButton.TextColor3 = Color3.new(1, 1, 1)
	UI.closeButton.TextSize = 16
	UI.closeButton.Font = Enum.Font.GothamBold
	UI.closeButton.ZIndex = 11
	UI.closeButton.Parent = UI.mainPanel

	local closeCorner = Instance.new("UICorner")
	closeCorner.CornerRadius = UDim.new(0, 8)
	closeCorner.Parent = UI.closeButton
end

createMainPanel()

-- ============================================================================
-- ITEM ACTION BAR (at bottom, shown when item selected)
-- ============================================================================


local function createActionBar()
	UI.actionBar = Instance.new("Frame")
	UI.actionBar.Name = "ActionBar"
	UI.actionBar.Size = UDim2.new(1, -20, 0, 50)
	UI.actionBar.Position = UDim2.new(0, 10, 1, -60)  -- At bottom with small margin
	UI.actionBar.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	UI.actionBar.BorderSizePixel = 0
	UI.actionBar.ZIndex = 20
	UI.actionBar.Visible = false  -- Hidden by default
	UI.actionBar.Parent = UI.mainPanel

	local actionBarCorner = Instance.new("UICorner")
	actionBarCorner.CornerRadius = UDim.new(0, 8)
	actionBarCorner.Parent = UI.actionBar

	local actionBarStroke = Instance.new("UIStroke")
	actionBarStroke.Color = Color3.fromRGB(80, 80, 120)
	actionBarStroke.Thickness = 2
	actionBarStroke.Parent = UI.actionBar

	-- Item Icon (left side) - uses RarityFrameColors (updated dynamically when item selected)
	UI.actionItemIcon = Instance.new("ImageLabel")
	UI.actionItemIcon.Name = "ItemIcon"
	UI.actionItemIcon.Size = UDim2.new(0, 40, 0, 40)
	UI.actionItemIcon.Position = UDim2.new(0, 8, 0.5, -20)
	UI.actionItemIcon.BackgroundColor3 = ItemConfig.GetRarityFrameColor("Common")
	UI.actionItemIcon.BackgroundTransparency = ItemConfig.GetRarityFrameTransparency()
	UI.actionItemIcon.BorderSizePixel = 0
	UI.actionItemIcon.Image = ""  -- Will be set when item is selected
	UI.actionItemIcon.ScaleType = Enum.ScaleType.Fit
	UI.actionItemIcon.ZIndex = 21
	UI.actionItemIcon.Parent = UI.actionBar
	
	-- Stroke for action icon (updated dynamically based on item rarity)
	UI.actionIconStroke = Instance.new("UIStroke")
	UI.actionIconStroke.Name = "IconStroke"
	UI.actionIconStroke.Color = ItemConfig.GetRarityColor("Common")
	UI.actionIconStroke.Thickness = 1
	UI.actionIconStroke.Parent = UI.actionItemIcon

	-- Item Name Label (next to icon)
	UI.actionNameLabel = Instance.new("TextLabel")
	UI.actionNameLabel.Name = "NameLabel"
	UI.actionNameLabel.Size = UDim2.new(0.4, -60, 0, 20)
	UI.actionNameLabel.Position = UDim2.new(0, 55, 0.5, -10)
	UI.actionNameLabel.BackgroundTransparency = 1
	UI.actionNameLabel.Text = "Item Name"
	UI.actionNameLabel.TextColor3 = Color3.new(1, 1, 1)
	UI.actionNameLabel.TextXAlignment = Enum.TextXAlignment.Left
	UI.actionNameLabel.TextSize = 13
	UI.actionNameLabel.Font = Enum.Font.GothamBold
	UI.actionNameLabel.ZIndex = 21
	UI.actionNameLabel.Parent = UI.actionBar

	-- Info Button (right side, next to drop)
	UI.infoButton = Instance.new("TextButton")
	UI.infoButton.Name = "InfoButton"
	UI.infoButton.Size = UDim2.new(0, 80, 0, 32)
	UI.infoButton.Position = UDim2.new(1, -185, 0.5, -16)
	UI.infoButton.BackgroundColor3 = Color3.fromRGB(40, 40, 80)
	UI.infoButton.BorderSizePixel = 0
	UI.infoButton.Text = "INFO"
	UI.infoButton.TextColor3 = Color3.new(1, 1, 1)
	UI.infoButton.TextSize = 12
	UI.infoButton.Font = Enum.Font.GothamBold
	UI.infoButton.ZIndex = 21
	UI.infoButton.Parent = UI.actionBar

	UI.infoStroke = Instance.new("UIStroke") -- Assign to the higher-scoped variable
	UI.infoStroke.Color = Color3.new(1, 1, 1)
	UI.infoStroke.Thickness = 1
	UI.infoStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
	UI.infoStroke.Parent = UI.infoButton

	local infoCorner = Instance.new("UICorner")
	infoCorner.CornerRadius = UDim.new(0, 6)
	infoCorner.Parent = UI.infoButton
	
	-- Set Button attribute for sound system
	UI.infoButton:SetAttribute("Button", true)
end

createActionBar()

-- Drop Button (right side) - Transparent with white stroke
UI.dropButton = Instance.new("TextButton")
UI.dropButton.Name = "DropButton"
UI.dropButton.Size = UDim2.new(0, 70, 0, 34)
UI.dropButton.Position = UDim2.new(1, -82, 0.5, -17)
UI.dropButton.BackgroundTransparency = 1  -- Transparent background
UI.dropButton.BorderSizePixel = 0
UI.dropButton.Text = "ðŸ—‘ï¸ DROP"
UI.dropButton.TextColor3 = Color3.new(1, 1, 1)  -- White text
UI.dropButton.TextSize = 12
UI.dropButton.Font = Enum.Font.GothamBold
UI.dropButton.ZIndex = 21
UI.dropButton.Parent = UI.actionBar

UI.dropStroke = Instance.new("UIStroke") -- Assign to the higher-scoped variable
UI.dropStroke.Color = Color3.new(1, 1, 1)  -- White stroke
UI.dropStroke.Thickness = 1
UI.dropStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
UI.dropStroke.Parent = UI.dropButton

local dropCorner = Instance.new("UICorner")
dropCorner.CornerRadius = UDim.new(0, 6)
dropCorner.Parent = UI.dropButton

-- Set Button attribute for sound system
UI.dropButton:SetAttribute("Button", true)

-- Selected item reference for action bar
State.actionBarSelectedItem = nil

-- Item Info Modal (center of screen, shown when INFO clicked)
local function createItemInfoModal()
	UI.itemInfoModal = Instance.new("Frame")
	UI.itemInfoModal.Name = "ItemInfoModal"
	UI.itemInfoModal.Size = UDim2.new(0, 500, 0, 455)  -- Reduced by 1.1x
	UI.itemInfoModal.Position = UDim2.new(0.5, 0, 0.5, 0)
	UI.itemInfoModal.AnchorPoint = Vector2.new(0.5, 0.5)
	UI.itemInfoModal.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	UI.itemInfoModal.BorderSizePixel = 0
	UI.itemInfoModal.ZIndex = 150
	UI.itemInfoModal.Visible = false
	UI.itemInfoModal.Parent = UI.screenGui

	local modalCorner = Instance.new("UICorner")
	modalCorner.CornerRadius = UDim.new(0, 12)
	modalCorner.Parent = UI.itemInfoModal

	local modalStroke = Instance.new("UIStroke")
	modalStroke.Color = Color3.fromRGB(100, 100, 150)
	modalStroke.Thickness = 3
	modalStroke.Parent = UI.itemInfoModal

	-- Modal Title Bar
	local modalTitleBar = Instance.new("Frame")
	modalTitleBar.Name = "TitleBar"
	modalTitleBar.Size = UDim2.new(1, 0, 0, 40)
	modalTitleBar.BackgroundColor3 = Color3.fromRGB(30, 30, 50)
	modalTitleBar.BorderSizePixel = 0
	modalTitleBar.ZIndex = 151
	modalTitleBar.Parent = UI.itemInfoModal

	local titleBarCorner = Instance.new("UICorner")
	titleBarCorner.CornerRadius = UDim.new(0, 12)
	titleBarCorner.Parent = modalTitleBar

	UI.modalTitle = Instance.new("TextLabel")
	UI.modalTitle.Name = "Title"
	UI.modalTitle.Size = UDim2.new(1, -50, 1, 0)
	UI.modalTitle.Position = UDim2.new(0, 15, 0, 0)
	UI.modalTitle.BackgroundTransparency = 1
	UI.modalTitle.Text = "ITEM INFORMATION"
	UI.modalTitle.TextColor3 = Color3.new(1, 1, 1)
	UI.modalTitle.TextXAlignment = Enum.TextXAlignment.Left
	UI.modalTitle.TextSize = 16
	UI.modalTitle.Font = Enum.Font.GothamBold
	UI.modalTitle.ZIndex = 152
	UI.modalTitle.Parent = modalTitleBar

	UI.modalCloseBtn = Instance.new("TextButton")
	UI.modalCloseBtn.Name = "CloseButton"
	UI.modalCloseBtn.Size = UDim2.new(0, 30, 0, 30)
	UI.modalCloseBtn.Position = UDim2.new(1, -35, 0.5, -15)
	UI.modalCloseBtn.BackgroundColor3 = Color3.fromRGB(180, 50, 50)
	UI.modalCloseBtn.BackgroundTransparency = 1  -- Transparent background
	UI.modalCloseBtn.BorderSizePixel = 0
	UI.modalCloseBtn.Text = "X"
	UI.modalCloseBtn.TextColor3 = Color3.new(1, 1, 1)
	UI.modalCloseBtn.TextSize = 14
	UI.modalCloseBtn.Font = Enum.Font.GothamBold
	UI.modalCloseBtn.ZIndex = 152
	UI.modalCloseBtn.Parent = modalTitleBar
	
	-- Set Button attribute for sound system
	UI.modalCloseBtn:SetAttribute("Button", true)

	local closeBtnCorner = Instance.new("UICorner")
	closeBtnCorner.CornerRadius = UDim.new(0, 6)
	closeBtnCorner.Parent = UI.modalCloseBtn

	-- Item Icon Section (left side) - stores references for dynamic rarity color updates
	UI.modalIconFrame = Instance.new("Frame")
	UI.modalIconFrame.Name = "IconFrame"
	UI.modalIconFrame.Size = UDim2.new(0, 240, 0, 240)
	UI.modalIconFrame.Position = UDim2.new(0, 20, 0, 60)
	UI.modalIconFrame.BackgroundColor3 = ItemConfig.GetRarityFrameColor("Common")
	UI.modalIconFrame.BackgroundTransparency = ItemConfig.GetRarityFrameTransparency()
	UI.modalIconFrame.BorderSizePixel = 0
	UI.modalIconFrame.ZIndex = 151
	UI.modalIconFrame.Parent = UI.itemInfoModal

	-- Stroke for icon frame (color updated dynamically based on item rarity)
	UI.modalIconStroke = Instance.new("UIStroke")
	UI.modalIconStroke.Name = "IconStroke"
	UI.modalIconStroke.Color = ItemConfig.GetRarityColor("Common")
	UI.modalIconStroke.Thickness = 2
	UI.modalIconStroke.Parent = UI.modalIconFrame

	-- Item Icon Image (inside icon frame) - full size to match frame
	UI.modalIconImage = Instance.new("ImageLabel")
	UI.modalIconImage.Name = "IconImage"
	UI.modalIconImage.Size = UDim2.new(1, 0, 1, 0)
	UI.modalIconImage.Position = UDim2.new(0, 0, 0, 0)
	UI.modalIconImage.BackgroundTransparency = 1
	UI.modalIconImage.Image = ""
	UI.modalIconImage.ScaleType = Enum.ScaleType.Fit
	UI.modalIconImage.ZIndex = 152
	UI.modalIconImage.Parent = UI.modalIconFrame

	-- Modal content labels (right side of icon)
	UI.modalNameLabel = Instance.new("TextLabel")
	UI.modalNameLabel.Name = "NameLabel"
	UI.modalNameLabel.Size = UDim2.new(0, 250, 0, 30)
	UI.modalNameLabel.Position = UDim2.new(0, 290, 0, 60)
	UI.modalNameLabel.BackgroundTransparency = 1
	UI.modalNameLabel.Text = "Item Name"
	UI.modalNameLabel.TextColor3 = Color3.new(1, 1, 1)
	UI.modalNameLabel.TextXAlignment = Enum.TextXAlignment.Left
	UI.modalNameLabel.TextSize = 24
	UI.modalNameLabel.Font = Enum.Font.GothamBold
	UI.modalNameLabel.ZIndex = 152
	UI.modalNameLabel.Parent = UI.itemInfoModal

	UI.modalRarityLabel = Instance.new("TextLabel")
	UI.modalRarityLabel.Name = "RarityLabel"
	UI.modalRarityLabel.Size = UDim2.new(0, 250, 0, 20)
	UI.modalRarityLabel.Position = UDim2.new(0, 290, 0, 95)
	UI.modalRarityLabel.BackgroundTransparency = 1
	UI.modalRarityLabel.Text = "Common"
	UI.modalRarityLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
	UI.modalRarityLabel.TextXAlignment = Enum.TextXAlignment.Left
	UI.modalRarityLabel.TextSize = 16
	UI.modalRarityLabel.Font = Enum.Font.GothamBold
	UI.modalRarityLabel.ZIndex = 152
	UI.modalRarityLabel.Parent = UI.itemInfoModal

	UI.modalWeightLabel = Instance.new("TextLabel")
	UI.modalWeightLabel.Name = "WeightLabel"
	UI.modalWeightLabel.Size = UDim2.new(0, 250, 0, 20)
	UI.modalWeightLabel.Position = UDim2.new(0, 290, 0, 125)
	UI.modalWeightLabel.BackgroundTransparency = 1
	UI.modalWeightLabel.Text = "Weight: 1.0kg"
	UI.modalWeightLabel.TextColor3 = Color3.fromRGB(180, 180, 220)
	UI.modalWeightLabel.TextXAlignment = Enum.TextXAlignment.Left
	UI.modalWeightLabel.TextSize = 14
	UI.modalWeightLabel.Font = Enum.Font.Gotham
	UI.modalWeightLabel.ZIndex = 152
	UI.modalWeightLabel.Parent = UI.itemInfoModal

	UI.modalValueLabel = Instance.new("TextLabel")
	UI.modalValueLabel.Name = "ValueLabel"
	UI.modalValueLabel.Size = UDim2.new(0, 250, 0, 20)
	UI.modalValueLabel.Position = UDim2.new(0, 290, 0, 150)
	UI.modalValueLabel.BackgroundTransparency = 1
	UI.modalValueLabel.Text = "Value: 100 Gems"
	UI.modalValueLabel.TextColor3 = Color3.fromRGB(100, 255, 100)
	UI.modalValueLabel.TextXAlignment = Enum.TextXAlignment.Left
	UI.modalValueLabel.TextSize = 14
	UI.modalValueLabel.Font = Enum.Font.Gotham
	UI.modalValueLabel.ZIndex = 152
	UI.modalValueLabel.Parent = UI.itemInfoModal

	UI.modalSizeLabel = Instance.new("TextLabel")
	UI.modalSizeLabel.Name = "SizeLabel"
	UI.modalSizeLabel.Size = UDim2.new(0, 250, 0, 20)
	UI.modalSizeLabel.Position = UDim2.new(0, 290, 0, 175)
	UI.modalSizeLabel.BackgroundTransparency = 1
	UI.modalSizeLabel.Text = "Grid Size: 1x1"
	UI.modalSizeLabel.TextColor3 = Color3.fromRGB(150, 150, 250)
	UI.modalSizeLabel.TextXAlignment = Enum.TextXAlignment.Left
	UI.modalSizeLabel.TextSize = 14
	UI.modalSizeLabel.Font = Enum.Font.Gotham
	UI.modalSizeLabel.ZIndex = 152
	UI.modalSizeLabel.Parent = UI.itemInfoModal

	-- Description section (below everything)
	local descHeader = Instance.new("TextLabel")
	descHeader.Name = "DescHeader"
	descHeader.Size = UDim2.new(1, -40, 0, 20)
	descHeader.Position = UDim2.new(0, 20, 0, 310)
	descHeader.BackgroundTransparency = 1
	descHeader.Text = "DESCRIPTION"
	descHeader.TextColor3 = Color3.fromRGB(150, 150, 180)
	descHeader.TextXAlignment = Enum.TextXAlignment.Left
	descHeader.TextSize = 12
	descHeader.Font = Enum.Font.GothamBold
	descHeader.ZIndex = 152
	descHeader.Parent = UI.itemInfoModal

	UI.modalDescLabel = Instance.new("TextLabel")
	UI.modalDescLabel.Name = "DescLabel"
	UI.modalDescLabel.Size = UDim2.new(1, -40, 0, 100)
	UI.modalDescLabel.Position = UDim2.new(0, 20, 0, 335)
	UI.modalDescLabel.BackgroundTransparency = 1
	UI.modalDescLabel.Text = "This is a detailed description of the item."
	UI.modalDescLabel.TextColor3 = Color3.new(1, 1, 1)
	UI.modalDescLabel.TextXAlignment = Enum.TextXAlignment.Left
	UI.modalDescLabel.TextYAlignment = Enum.TextYAlignment.Top
	UI.modalDescLabel.TextSize = 14
	UI.modalDescLabel.TextWrapped = true
	UI.modalDescLabel.Font = Enum.Font.Gotham
	UI.modalDescLabel.ZIndex = 152
	UI.modalDescLabel.Parent = UI.itemInfoModal
end

createItemInfoModal()

-- Divider line below icon
local modalDivider = Instance.new("Frame")
modalDivider.Name = "Divider"
modalDivider.Size = UDim2.new(1, -30, 0, 2)
modalDivider.Position = UDim2.new(0, 15, 0, 325)
modalDivider.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
modalDivider.BorderSizePixel = 0
modalDivider.ZIndex = 151
modalDivider.Parent = UI.itemInfoModal



local function showItemInfoModal(itemData)
	local config = itemData.config
	UI.modalTitle.Text = "ðŸ“¦ " .. config.name
	UI.modalNameLabel.Text = config.name
	UI.modalWeightLabel.Text = "Weight: " .. string.format("%.2f", config.weight) .. " KG"
	UI.modalValueLabel.Text = "Price: $" .. tostring(config.price)
	UI.modalRarityLabel.Text = "Rarity: " .. (config.rarity or "Common")
	UI.modalSizeLabel.Text = "Grid Size: " .. tostring(itemData.width) .. "x" .. tostring(itemData.height)
	UI.modalDescLabel.Text = config.description or "A useful item for your adventures."
	
	-- Set icon image from ItemConfig
	UI.modalIconImage.Image = config.icon or ""
	
	-- Update modal icon frame colors based on item rarity
	local rarity = config.rarity or "Common"
	UI.modalIconFrame.BackgroundColor3 = ItemConfig.GetRarityFrameColor(rarity)
	UI.modalIconStroke.Color = ItemConfig.GetRarityColor(rarity)
	
	UI.itemInfoModal.Visible = true
end

local function hideItemInfoModal()
	UI.itemInfoModal.Visible = false
end

UI.modalCloseBtn.MouseButton1Click:Connect(hideItemInfoModal)

local function updateActionBar(itemData)
	State.actionBarSelectedItem = itemData
	if itemData then
		UI.actionBar.Visible = true
		UI.actionNameLabel.Text = itemData.config.name
		UI.actionItemIcon.Image = itemData.config.icon or ""  -- Set item icon
		
		-- Update action icon colors based on item rarity
		local rarity = itemData.config.rarity or "Common"
		UI.actionItemIcon.BackgroundColor3 = ItemConfig.GetRarityFrameColor(rarity)
		UI.actionIconStroke.Color = ItemConfig.GetRarityColor(rarity)
	else
		UI.actionBar.Visible = true -- Keep visible but clear content for consistency or hide if preferred
		UI.actionBar.Visible = false
		UI.actionNameLabel.Text = ""
		UI.actionItemIcon.Image = ""  -- Clear icon
		
		-- Reset to default colors
		UI.actionItemIcon.BackgroundColor3 = ItemConfig.GetRarityFrameColor("Common")
		UI.actionIconStroke.Color = ItemConfig.GetRarityColor("Common")
		
		hideItemInfoModal()
	end
end

-- INFO button click handler
UI.infoButton.MouseButton1Click:Connect(function()
	-- Play button sound
	local soundService = game:GetService("SoundService")
	local buttonSound = soundService:FindFirstChild("Button")
	if buttonSound and buttonSound:IsA("Sound") then
		buttonSound:Play()
	end
	
	if State.actionBarSelectedItem then
		showItemInfoModal(State.actionBarSelectedItem)
	end
end)

-- Drop button click handler
UI.dropButton.MouseButton1Click:Connect(function()
	-- Play button sound
	local soundService = game:GetService("SoundService")
	local buttonSound = soundService:FindFirstChild("Button")
	if buttonSound and buttonSound:IsA("Sound") then
		buttonSound:Play()
	end
	
	if not State.actionBarSelectedItem then return end
	
	-- Check if in safezone
	if player:GetAttribute("InSafezone") == true then
		return
	end
	
	-- Get item info
	local itemId = State.actionBarSelectedItem.config.id
	
	-- Fire drop event to server
	if Events.DropItem then
		Events.DropItem:FireServer(itemId)
	end
	
	-- Hide action bar immediately (server will sync inventory)
	updateActionBar(nil)
end)

-- Hover effects for buttons
UI.infoButton.MouseEnter:Connect(function()
	Services.TweenService:Create(UI.infoStroke, TweenInfo.new(0.15), {Color = Color3.fromRGB(150, 200, 255)}):Play()
end)
UI.infoButton.MouseLeave:Connect(function()
	Services.TweenService:Create(UI.infoStroke, TweenInfo.new(0.15), {Color = Color3.new(1, 1, 1)}):Play()
end)
UI.dropButton.MouseEnter:Connect(function()
	Services.TweenService:Create(UI.dropStroke, TweenInfo.new(0.15), {Color = Color3.fromRGB(255, 150, 150)}):Play()
end)
UI.dropButton.MouseLeave:Connect(function()
	Services.TweenService:Create(UI.dropStroke, TweenInfo.new(0.15), {Color = Color3.new(1, 1, 1)}):Play()
end)

-- ============================================================================
-- ============================================================================
-- MAIN CONTENT SCROLLING CONTAINER (holds armor + grid)
-- ============================================================================

local function createContentScroll()
	UI.contentScroll = Instance.new("ScrollingFrame")
	UI.contentScroll.Name = "ContentScroll"
	UI.contentScroll.Size = UDim2.new(0.47, 0, 1, -60)
	UI.contentScroll.Position = UDim2.new(0, 0, 0, 50)
	UI.contentScroll.BackgroundTransparency = 1
	UI.contentScroll.BorderSizePixel = 0
	UI.contentScroll.ScrollBarThickness = 8
	UI.contentScroll.ScrollBarImageColor3 = Color3.fromRGB(100, 100, 130)
	UI.contentScroll.ScrollBarImageTransparency = 1
	UI.contentScroll.CanvasSize = UDim2.new(0, 0, 0, 1150)
	UI.contentScroll.VerticalScrollBarPosition = Enum.VerticalScrollBarPosition.Left
	UI.contentScroll.ZIndex = 10
	UI.contentScroll.Parent = UI.mainPanel

	local contentLayout = Instance.new("UIListLayout")
	contentLayout.Name = "ContentLayout"
	contentLayout.SortOrder = Enum.SortOrder.Name
	contentLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
	contentLayout.VerticalAlignment = Enum.VerticalAlignment.Top
	-- contentLayout.VerticalFlex = Enum.UIFlexAlignment.SpaceAround -- Removed if not available in some versions, or keep if sure
	contentLayout.Padding = UDim.new(0, 20)
	contentLayout.Parent = UI.contentScroll

	-- Top Divider (transparent margin)
	local topDivider = Instance.new("Frame")
	topDivider.Name = "00_TopDivider"
	topDivider.Size = UDim2.new(1, -40, 0, 10)
	topDivider.BackgroundTransparency = 1
	topDivider.BorderSizePixel = 0
	topDivider.ZIndex = 11
	topDivider.Parent = UI.contentScroll
end

createContentScroll()

-- ============================================================================
-- RIG CONTAINER (contains grid, below armor)
-- ============================================================================

local function createRigContainer()
	UI.rigContainer = Instance.new("Frame")
	UI.rigContainer.Name = "2_RigContainer"
	UI.rigContainer.Size = UDim2.new(1, -20, 0, 470)
	UI.rigContainer.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	UI.rigContainer.BackgroundTransparency = 0.5
	UI.rigContainer.BorderSizePixel = 0
	UI.rigContainer.ZIndex = 10
	UI.rigContainer.Parent = UI.contentScroll

	local rigContainerCorner = Instance.new("UICorner")
	rigContainerCorner.CornerRadius = UDim.new(0, 8)
	rigContainerCorner.Parent = UI.rigContainer

	local rigContainerStroke = Instance.new("UIStroke")
	rigContainerStroke.Color = Color3.fromRGB(70, 70, 100)
	rigContainerStroke.Thickness = 1
	rigContainerStroke.Parent = UI.rigContainer

	local rigTitle = Instance.new("TextLabel")
	rigTitle.Name = "RigTitle"
	rigTitle.Size = UDim2.new(0, 140, 0, 25)
	rigTitle.Position = UDim2.new(1, -150, 0, 8)
	rigTitle.BackgroundTransparency = 1
	rigTitle.Text = "Chest Rig Slot"
	rigTitle.TextColor3 = Color3.fromRGB(200, 200, 220)
	rigTitle.TextXAlignment = Enum.TextXAlignment.Right
	rigTitle.TextSize = 14
	rigTitle.Font = Enum.Font.GothamBold
	rigTitle.ZIndex = 11
	rigTitle.Parent = UI.rigContainer

	UI.rigEquipSlot = Instance.new("Frame")
	UI.rigEquipSlot.Name = "RigEquipSlot"
	UI.rigEquipSlot.Size = UDim2.new(0.15, 0, 0.15, 0)
	UI.rigEquipSlot.Position = UDim2.new(0.02, 0, 0.1, 0)
	UI.rigEquipSlot.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	UI.rigEquipSlot.BorderSizePixel = 0
	UI.rigEquipSlot.ZIndex = 11
	UI.rigEquipSlot.Parent = UI.rigContainer

	local rigEquipStroke = Instance.new("UIStroke")
	rigEquipStroke.Color = Color3.fromRGB(80, 80, 120)
	rigEquipStroke.Thickness = 1
	rigEquipStroke.Parent = UI.rigEquipSlot

	UI.rigEquipIcon = Instance.new("ImageLabel")
	UI.rigEquipIcon.Name = "RigEquipIcon"
	UI.rigEquipIcon.Size = UDim2.new(0.85, 0, 0.85, 0)
	UI.rigEquipIcon.Position = UDim2.new(0.075, 0, 0.075, 0)
	UI.rigEquipIcon.BackgroundTransparency = 1
	UI.rigEquipIcon.Image = "rbxassetid://128194988776053"
	UI.rigEquipIcon.ImageColor3 = Color3.fromRGB(150, 150, 180)
	UI.rigEquipIcon.ImageTransparency = 0.5
	UI.rigEquipIcon.ScaleType = Enum.ScaleType.Fit
	UI.rigEquipIcon.ZIndex = 12
	UI.rigEquipIcon.Parent = UI.rigEquipSlot

	UI.gridContainer = Instance.new("Frame")
	UI.gridContainer.Name = "GridContainer"
	UI.gridContainer.Size = UDim2.new(0, (Config.CELL_SIZE + Config.CELL_PADDING) * Config.GRID_COLS, 0, (Config.CELL_SIZE + Config.CELL_PADDING) * Config.GRID_ROWS)
	UI.gridContainer.Position = UDim2.new(0.5, 0, 0, 55)  -- Fixed Y offset (55px) for proper alignment below title
	UI.gridContainer.AnchorPoint = Vector2.new(0.5, 0)
	UI.gridContainer.BackgroundTransparency = 1
	UI.gridContainer.ZIndex = 10
	UI.gridContainer.Parent = UI.rigContainer

	Data.gridSlots = {}


	for row = 1, Config.GRID_ROWS do
		Data.gridSlots[row] = {}
		for col = 1, Config.GRID_COLS do
			local slot = Instance.new("Frame")
			slot.Name = "Slot_" .. row .. "_" .. col
			slot.Size = UDim2.new(0, Config.CELL_SIZE, 0, Config.CELL_SIZE)
			slot.Position = UDim2.new(0, (col - 1) * (Config.CELL_SIZE + Config.CELL_PADDING), 0, (row - 1) * (Config.CELL_SIZE + Config.CELL_PADDING))
			slot.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
			slot.BackgroundTransparency = 1
			slot.BorderSizePixel = 0
			slot.ZIndex = 10
			slot.Parent = UI.gridContainer

			local slotStroke = Instance.new("UIStroke")
			slotStroke.Name = "SlotStroke"
			slotStroke.Color = Color3.fromRGB(60, 60, 80)
			slotStroke.Thickness = 1
			slotStroke.Parent = slot

			Data.gridSlots[row][col] = slot
		end
	end
end

createRigContainer()

-- ============================================================================
-- BACKPACK CONTAINER (below grid, for backpack slot)
-- ============================================================================

local function createBackpackContainer()
	UI.backpackContainer = Instance.new("Frame")
	UI.backpackContainer.Name = "3_BackpackContainer"
	UI.backpackContainer.Size = UDim2.new(1, -20, 0, 120)
	UI.backpackContainer.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	UI.backpackContainer.BackgroundTransparency = 0.5
	UI.backpackContainer.BorderSizePixel = 0
	UI.backpackContainer.ZIndex = 10
	UI.backpackContainer.Parent = UI.contentScroll

	local backpackContainerCorner = Instance.new("UICorner")
	backpackContainerCorner.CornerRadius = UDim.new(0, 8)
	backpackContainerCorner.Parent = UI.backpackContainer

	local backpackContainerStroke = Instance.new("UIStroke")
	backpackContainerStroke.Color = Color3.fromRGB(70, 70, 100)
	backpackContainerStroke.Thickness = 1
	backpackContainerStroke.Parent = UI.backpackContainer

	local backpackTitle = Instance.new("TextLabel")
	backpackTitle.Name = "BackpackTitle"
	backpackTitle.Size = UDim2.new(0, 140, 0, 25)
	backpackTitle.Position = UDim2.new(1, -150, 0, 8)
	backpackTitle.BackgroundTransparency = 1
	backpackTitle.Text = "Backpack Slot"
	backpackTitle.TextColor3 = Color3.fromRGB(200, 200, 220)
	backpackTitle.TextXAlignment = Enum.TextXAlignment.Right
	backpackTitle.TextSize = 14
	backpackTitle.Font = Enum.Font.GothamBold
	backpackTitle.ZIndex = 11
	backpackTitle.Parent = UI.backpackContainer

	UI.backpackSlotEquip = Instance.new("Frame")
	UI.backpackSlotEquip.Name = "BackpackSlotEquip"
	UI.backpackSlotEquip.Size = UDim2.new(0, 80, 0, 80)
	UI.backpackSlotEquip.Position = UDim2.new(0.02, 0, 0.2, 0)
	UI.backpackSlotEquip.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	UI.backpackSlotEquip.BorderSizePixel = 0
	UI.backpackSlotEquip.ZIndex = 11
	UI.backpackSlotEquip.Parent = UI.backpackContainer

	local backpackEquipStroke = Instance.new("UIStroke")
	backpackEquipStroke.Color = Color3.fromRGB(80, 80, 120)
	backpackEquipStroke.Thickness = 1
	backpackEquipStroke.Parent = UI.backpackSlotEquip

	UI.backpackSlotIcon = Instance.new("ImageLabel")
	UI.backpackSlotIcon.Name = "BackpackSlotIcon"
	UI.backpackSlotIcon.Size = UDim2.new(0.8, 0, 0.8, 0)
	UI.backpackSlotIcon.Position = UDim2.new(0.1, 0, 0.1, 0)
	UI.backpackSlotIcon.BackgroundTransparency = 1
	UI.backpackSlotIcon.Image = "rbxassetid://128194988776053"
	UI.backpackSlotIcon.ImageColor3 = Color3.fromRGB(150, 150, 180)
	UI.backpackSlotIcon.ImageTransparency = 0.5
	UI.backpackSlotIcon.ScaleType = Enum.ScaleType.Fit
	UI.backpackSlotIcon.ZIndex = 12
	UI.backpackSlotIcon.Parent = UI.backpackSlotEquip
end

createBackpackContainer()

-- ============================================================================
-- LOOT INFO CONTAINER (shows equipment value and weight)
-- ============================================================================

local function createLootInfoContainer()
	UI.lootInfoContainer = Instance.new("Frame")
	UI.lootInfoContainer.Name = "0_LootInfo"
	UI.lootInfoContainer.Size = UDim2.new(1, -20, 0, 35)
	UI.lootInfoContainer.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	UI.lootInfoContainer.BackgroundTransparency = 0.5
	UI.lootInfoContainer.BorderSizePixel = 0
	UI.lootInfoContainer.ZIndex = 10
	UI.lootInfoContainer.Parent = UI.contentScroll

	local lootInfoCorner = Instance.new("UICorner")
	lootInfoCorner.CornerRadius = UDim.new(0, 6)
	lootInfoCorner.Parent = UI.lootInfoContainer

	local lootInfoStroke = Instance.new("UIStroke")
	lootInfoStroke.Color = Color3.fromRGB(70, 70, 100)
	lootInfoStroke.Thickness = 1
	lootInfoStroke.Parent = UI.lootInfoContainer

	UI.equipmentValueLabel = Instance.new("TextLabel")
	UI.equipmentValueLabel.Name = "EquipmentValueLabel"
	UI.equipmentValueLabel.Size = UDim2.new(0.5, 0, 1, 0)
	UI.equipmentValueLabel.Position = UDim2.new(0, 10, 0, 0)
	UI.equipmentValueLabel.BackgroundTransparency = 1
	UI.equipmentValueLabel.Text = "Equipment Value: "
	UI.equipmentValueLabel.TextColor3 = Color3.fromRGB(200, 200, 220)
	UI.equipmentValueLabel.TextSize = 14
	UI.equipmentValueLabel.TextXAlignment = Enum.TextXAlignment.Left
	UI.equipmentValueLabel.Font = Enum.Font.GothamBold
	UI.equipmentValueLabel.ZIndex = 11
	UI.equipmentValueLabel.Parent = UI.lootInfoContainer

	UI.weightLabel = Instance.new("TextLabel")
	UI.weightLabel.Name = "WeightLabel"
	UI.weightLabel.Size = UDim2.new(0.4, 0, 1, 0)
	UI.weightLabel.Position = UDim2.new(0.55, 0, 0, 0)
	UI.weightLabel.BackgroundTransparency = 1
	UI.weightLabel.Text = "0/65kg"
	UI.weightLabel.TextColor3 = Color3.fromRGB(200, 200, 220)
	UI.weightLabel.TextSize = 14
	UI.weightLabel.TextXAlignment = Enum.TextXAlignment.Right
	UI.weightLabel.Font = Enum.Font.GothamBold
	UI.weightLabel.ZIndex = 11
	UI.weightLabel.Parent = UI.lootInfoContainer
end

createLootInfoContainer()

-- ============================================================================
-- ARMOR EQUIPMENT CONTAINER
-- ============================================================================

-- Forward declaration for canFitItemAnywhere (defined later in GRID UTILITY FUNCTIONS)
local canFitItemAnywhere

local function createArmorContainer()
	UI.armorContainer = Instance.new("Frame")
	UI.armorContainer.Name = "1_ArmorContainer"
	UI.armorContainer.Size = UDim2.new(1, -20, 0, 550)
	UI.armorContainer.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	UI.armorContainer.BackgroundTransparency = 0.5
	UI.armorContainer.BorderSizePixel = 0
	UI.armorContainer.ZIndex = 10
	UI.armorContainer.Parent = UI.contentScroll

	local armorContainerCorner = Instance.new("UICorner")
	armorContainerCorner.CornerRadius = UDim.new(0, 8)
	armorContainerCorner.Parent = UI.armorContainer

	local armorContainerStroke = Instance.new("UIStroke")
	armorContainerStroke.Color = Color3.fromRGB(70, 70, 100)
	armorContainerStroke.Thickness = 1
	armorContainerStroke.Parent = UI.armorContainer

	Data.armorSlots = {}

	local armorSlotTypes = {
		{ name = "Helmet", icon = "rbxassetid://74562094577384", scaleX = 0.30, scaleY = 0.02, scaleW = 0.35, scaleH = 0.20, iconSize = UDim2.new(1, 0, 1, 0), iconPos = UDim2.new(0, 0, 0, 0) },
		{ name = "LeftArm", icon = "rbxassetid://70718158694267", scaleX = 0.03, scaleY = 0.24, scaleW = 0.23, scaleH = 0.31 },
		{ name = "Armor", icon = "rbxassetid://73706008477424", scaleX = 0.30, scaleY = 0.24, scaleW = 0.35, scaleH = 0.31 },
		{ name = "RightArm", icon = "rbxassetid://116177084120383", scaleX = 0.69, scaleY = 0.24, scaleW = 0.23, scaleH = 0.31 },
		{ name = "Legging", icon = "rbxassetid://121631408860254", scaleX = 0.30, scaleY = 0.58, scaleW = 0.35, scaleH = 0.31 },
	}

	for _, slotInfo in ipairs(armorSlotTypes) do
		local armorSlot = Instance.new("Frame")
		armorSlot.Name = slotInfo.name .. "Slot"
		armorSlot.Size = UDim2.new(slotInfo.scaleW, 0, slotInfo.scaleH, 0)
		armorSlot.Position = UDim2.new(slotInfo.scaleX, 0, slotInfo.scaleY, 0)
		armorSlot.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
		armorSlot.BorderSizePixel = 0
		armorSlot.ZIndex = 11
		armorSlot.Parent = UI.armorContainer

		local armorSlotStroke = Instance.new("UIStroke")
		armorSlotStroke.Color = Color3.fromRGB(80, 80, 120)
		armorSlotStroke.Thickness = 1
		armorSlotStroke.Parent = armorSlot

		local iconImage = Instance.new("ImageLabel")
		iconImage.Name = "Icon"
		iconImage.Size = slotInfo.iconSize or UDim2.new(0.85, 0, 0.85, 0)
		iconImage.Position = slotInfo.iconPos or UDim2.new(0.075, 0, 0.075, 0)
		iconImage.BackgroundTransparency = 1
		iconImage.Image = slotInfo.icon
		iconImage.ImageColor3 = Color3.fromRGB(150, 150, 180)
		iconImage.ImageTransparency = 0.5
		iconImage.ScaleType = Enum.ScaleType.Fit
		iconImage.ZIndex = 12
		iconImage.Parent = armorSlot
		
		-- Equipped item icon (shown when armor is equipped)
		local equippedIcon = Instance.new("ImageLabel")
		equippedIcon.Name = "EquippedIcon"
		equippedIcon.Size = UDim2.new(0.9, 0, 0.9, 0)
		equippedIcon.Position = UDim2.new(0.05, 0, 0.05, 0)
		equippedIcon.BackgroundTransparency = 1
		equippedIcon.Image = ""
		equippedIcon.ImageTransparency = 0
		equippedIcon.ScaleType = Enum.ScaleType.Fit
		equippedIcon.ZIndex = 13
		equippedIcon.Visible = false
		equippedIcon.Parent = armorSlot

		Data.armorSlots[slotInfo.name] = {
			frame = armorSlot,
			icon = iconImage,
			equippedIcon = equippedIcon,
			equipped = nil,
			slotName = slotInfo.name,
			stroke = armorSlotStroke,
		}
		
		-- Click handler for equipping/unequipping armor
		armorSlot.InputBegan:Connect(function(input)
			if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
				local slotData = Data.armorSlots[slotInfo.name]
				
				-- Check if we have a selected item that's compatible armor
				if State.selectedItem then
					local itemConfig = State.selectedItem.config
					if itemConfig and itemConfig.isArmor and itemConfig.slotType == slotInfo.name then
						-- Block equipping if slot is already equipped
						if slotData and slotData.equipped then
							return
						end
						
						-- Equip the armor - use itemId for server lookup, instanceId for inventory removal
						local armorItemId = itemConfig.itemId or itemConfig.name
						local instanceId = itemConfig.id  -- The unique instance ID from inventory
						
						
						if Events.ArmorEquip then
							Events.ArmorEquip:FireServer("equip", armorItemId, slotInfo.name, instanceId)
						end
						
						-- Update slot visual
						if slotData then
							slotData.equippedIcon.Image = itemConfig.icon
							slotData.equippedIcon.Visible = true
							slotData.icon.Visible = false
							slotData.equipped = armorItemId
							slotData.stroke.Color = Color3.fromRGB(100, 255, 100) -- Green when equipped
						end
						
						-- Deselect the item
						if State.selectedItem and State.selectedItem.frame then
							local itemStroke = State.selectedItem.frame:FindFirstChild("ItemStroke")
							if itemStroke then
								itemStroke.Thickness = 1
							end
						end
						State.selectedItem = nil
						UI.actionBar.Visible = false
						
						-- Reset slot highlights
						for name, data in pairs(Data.armorSlots) do
							if not data.equipped then
								data.stroke.Color = Color3.fromRGB(80, 80, 120)
								data.stroke.Thickness = 1
							end
						end
						
						-- Play equip sound
						local soundService = game:GetService("SoundService")
						local equipSound = soundService:FindFirstChild("Button")
						if equipSound then equipSound:Play() end
					end
				elseif slotData and slotData.equipped then
					-- Clicked on equipped slot without item selected - UNEQUIP
					-- First check if inventory has space for this armor item
					local equippedItemId = slotData.equipped
					local armorConfig = ItemConfig[equippedItemId] or ItemConfig.GetItem(equippedItemId)
					
					if armorConfig then
						local itemWidth = armorConfig.width or 1
						local itemHeight = armorConfig.height or 1
						
						-- Check if inventory has space for this armor
						if not canFitItemAnywhere(itemWidth, itemHeight) then
							-- No space in inventory - don't unequip!
							return
						end
					end
					
					
					if Events.ArmorEquip then
						Events.ArmorEquip:FireServer("unequip", slotInfo.name)
					end
					
					-- Update slot visual (will be synced from server, but update immediately for feedback)
					slotData.equippedIcon.Visible = false
					slotData.icon.Visible = true
					slotData.equipped = nil
					slotData.stroke.Color = Color3.fromRGB(80, 80, 120)
					
					-- Play unequip sound
					local soundService = game:GetService("SoundService")
					local equipSound = soundService:FindFirstChild("Button")
					if equipSound then equipSound:Play() end
				end
			end
		end)
	end
end

createArmorContainer()

-- ============================================================================
-- PLAYER CONTAINER (Viewport + Health)
-- ============================================================================

local function createPlayerAndChestContainers()
	UI.PlayerContainer = Instance.new("Frame")
	UI.PlayerContainer.Name = "PlayerContainer"
	UI.PlayerContainer.Size = UDim2.new(0.5, 0, 1, -60)
	UI.PlayerContainer.Position = UDim2.new(0.5, 0, 0, 50)
	UI.PlayerContainer.BackgroundTransparency = 1
	UI.PlayerContainer.ClipsDescendants = true
	UI.PlayerContainer.Parent = UI.mainPanel

	UI.ChestContainer = Instance.new("Frame")
	UI.ChestContainer.Name = "ChestContainer"
	UI.ChestContainer.Size = UDim2.new(0.49, 0, 1, -60)
	UI.ChestContainer.Position = UDim2.new(0.5, 0, 0, 50)
	UI.ChestContainer.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	UI.ChestContainer.BackgroundTransparency = 0.5
	UI.ChestContainer.ClipsDescendants = true
	UI.ChestContainer.Visible = false
	UI.ChestContainer.Active = true -- Enable for touch capture
	UI.ChestContainer.Parent = UI.mainPanel

	local chestContainerCorner = Instance.new("UICorner")
	chestContainerCorner.CornerRadius = UDim.new(0, 8)
	chestContainerCorner.Parent = UI.ChestContainer

	local chestContainerStroke = Instance.new("UIStroke")
	chestContainerStroke.Color = Color3.fromRGB(70, 70, 100)
	chestContainerStroke.Thickness = 1
	chestContainerStroke.Parent = UI.ChestContainer

	UI.chestNameLabel = Instance.new("TextLabel")
	UI.chestNameLabel.Name = "ChestNameLabel"
	UI.chestNameLabel.Size = UDim2.new(0.5, 0, 0, 30)
	UI.chestNameLabel.Position = UDim2.new(0.02, 0, 0.02, 0)
	UI.chestNameLabel.BackgroundTransparency = 1
	UI.chestNameLabel.Text = "Wooden Chest"
	UI.chestNameLabel.TextColor3 = Color3.fromRGB(255, 220, 100)
	UI.chestNameLabel.TextSize = 18
	UI.chestNameLabel.TextXAlignment = Enum.TextXAlignment.Left
	UI.chestNameLabel.Font = Enum.Font.GothamBold
	UI.chestNameLabel.ZIndex = 12
	UI.chestNameLabel.Parent = UI.ChestContainer

	-- Chest grid container (will be populated dynamically based on chest type)
	UI.gridContainerChest = Instance.new("Frame")
	UI.gridContainerChest.Name = "GridContainerChest"
	UI.gridContainerChest.Position = UDim2.new(0.06, 0, 0.09, 0)
	UI.gridContainerChest.AnchorPoint = Vector2.new(0, 0)
	UI.gridContainerChest.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	UI.gridContainerChest.BackgroundTransparency = 0.5
	UI.gridContainerChest.ZIndex = 11
	UI.gridContainerChest.Active = true
	UI.gridContainerChest.Parent = UI.ChestContainer
	
	-- Initialize empty (will be created dynamically when chest opens)
	Data.chestGridSlots = {}
	
	-- Opening overlay (shows during chest opening delay)
	UI.chestOpeningOverlay = Instance.new("Frame")
	UI.chestOpeningOverlay.Name = "OpeningOverlay"
	UI.chestOpeningOverlay.Size = UDim2.new(1, 0, 1, 0)
	UI.chestOpeningOverlay.Position = UDim2.new(0, 0, 0, 0)
	UI.chestOpeningOverlay.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	UI.chestOpeningOverlay.BackgroundTransparency = 0.5
	UI.chestOpeningOverlay.ZIndex = 100  -- Above everything in chest container
	UI.chestOpeningOverlay.Visible = false
	UI.chestOpeningOverlay.Parent = UI.ChestContainer
	
	-- Progress bar (top-to-bottom reveal animation)
	UI.chestOpeningProgress = Instance.new("Frame")
	UI.chestOpeningProgress.Name = "ProgressBar"
	UI.chestOpeningProgress.Size = UDim2.new(1, 0, 0, 0)  -- Starts at 0 height
	UI.chestOpeningProgress.Position = UDim2.new(0, 0, 0, 0)
	UI.chestOpeningProgress.BackgroundColor3 = Color3.fromRGB(50, 120, 80)
	UI.chestOpeningProgress.BackgroundTransparency = 0.3
	UI.chestOpeningProgress.BorderSizePixel = 0
	UI.chestOpeningProgress.ZIndex = 101
	UI.chestOpeningProgress.Parent = UI.chestOpeningOverlay
	
	-- "Opening..." text
	UI.chestOpeningLabel = Instance.new("TextLabel")
	UI.chestOpeningLabel.Name = "OpeningText"
	UI.chestOpeningLabel.Size = UDim2.new(1, 0, 0, 50)
	UI.chestOpeningLabel.Position = UDim2.new(0, 0, 0.4, 0)
	UI.chestOpeningLabel.BackgroundTransparency = 1
	UI.chestOpeningLabel.Text = "Opening..."
	UI.chestOpeningLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
	UI.chestOpeningLabel.TextSize = 24
	UI.chestOpeningLabel.Font = Enum.Font.GothamBold
	UI.chestOpeningLabel.ZIndex = 102
	UI.chestOpeningLabel.Parent = UI.chestOpeningOverlay
end

createPlayerAndChestContainers()

-- ============================================================================
-- DYNAMIC CHEST GRID RECREATION
-- ============================================================================

-- Setup chest grid slot click for moving items (forward declaration)
local setupChestSlotInput

-- Recreate chest grid based on current chest configuration
local function recreateChestGrid()
	local chestConf = State.currentChestConfig or { gridRows = 6, gridCols = 6 }
	local cellSize = Config.CHEST.CELL_SIZE
	local cellPadding = Config.CHEST.CELL_PADDING
	
	-- Check if grid already exists with correct size
	local needsRecreate = false
	if not Data.chestGridSlots or #Data.chestGridSlots == 0 then
		needsRecreate = true
	else
		-- Check if size matches
		local currentRows = #Data.chestGridSlots
		local currentCols = Data.chestGridSlots[1] and #Data.chestGridSlots[1] or 0
		if currentRows ~= chestConf.gridRows or currentCols ~= chestConf.gridCols then
			needsRecreate = true
		end
	end
	
	-- Only recreate if needed
	if not needsRecreate then
		return
	end
	
	-- Clear existing slots
	for _, rowSlots in pairs(Data.chestGridSlots) do
		if type(rowSlots) == "table" then
			for _, slot in pairs(rowSlots) do
				if slot and slot.Parent then
					slot:Destroy()
				end
			end
		end
	end
	Data.chestGridSlots = {}
	
	-- Resize container based on chest config
	UI.gridContainerChest.Size = UDim2.new(
		0, chestConf.gridCols * cellSize + (chestConf.gridCols - 1) * cellPadding,
		0, chestConf.gridRows * cellSize + (chestConf.gridRows - 1) * cellPadding
	)
	
	-- Create new slots based on chest config
	for row = 1, chestConf.gridRows do
		Data.chestGridSlots[row] = {}
		for col = 1, chestConf.gridCols do
			local slot = Instance.new("Frame")
			slot.Name = "ChestSlot_" .. row .. "_" .. col
			slot.Size = UDim2.new(0, cellSize, 0, cellSize)
			slot.Position = UDim2.new(0, (col - 1) * (cellSize + cellPadding), 0, (row - 1) * (cellSize + cellPadding))
			slot.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
			slot.BackgroundTransparency = 1
			slot.BorderSizePixel = 0
			slot.ZIndex = 12
			slot.Parent = UI.gridContainerChest

			local slotStroke = Instance.new("UIStroke")
			slotStroke.Name = "SlotStroke"
			slotStroke.Color = Color3.fromRGB(60, 60, 80)
			slotStroke.Thickness = 1
			slotStroke.Parent = slot

			Data.chestGridSlots[row][col] = slot
			
			-- Setup input handler for this slot
			if setupChestSlotInput then
				setupChestSlotInput(slot, row, col)
			end
		end
	end
end


-- ============================================================================
-- CHARACTER VIEWPORT FRAME
-- ============================================================================

local function createCharacterViewport()
	UI.viewportFrame = Instance.new("ViewportFrame")
	UI.viewportFrame.Name = "CharacterViewport"
	UI.viewportFrame.Size = UDim2.new(0.6, 0, 1, 0)  -- 60% width, full height
	UI.viewportFrame.Position = UDim2.new(-0.06, 0, 0, 0)  -- Slightly left overflow
	UI.viewportFrame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	UI.viewportFrame.BackgroundTransparency = 1
	UI.viewportFrame.BorderSizePixel = 0
	UI.viewportFrame.ZIndex = 11
	UI.viewportFrame.Parent = UI.PlayerContainer  -- Parent to PlayerContainer

	-- Create WorldModel for viewport
	UI.worldModel = Instance.new("WorldModel")
	UI.worldModel.Name = "CharacterModel"
	UI.worldModel.Parent = UI.viewportFrame

	-- Create camera for viewport
	UI.viewportCamera = Instance.new("Camera")
	UI.viewportCamera.Name = "ViewportCamera"
	UI.viewportCamera.Parent = UI.viewportFrame
	UI.viewportFrame.CurrentCamera = UI.viewportCamera

	-- Rotation state in State table
	State.viewportCurrentRotationY = 180
	State.viewportIsRotating = false
	State.viewportLastMousePos = nil
	State.viewportCharClone = nil

	-- Interaction for rotating character
	UI.viewportFrame.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			State.viewportIsRotating = true
			State.viewportLastMousePos = input.Position
		end
	end)

	Services.UserInputService.InputChanged:Connect(function(input)
		if State.viewportIsRotating and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
			if State.viewportLastMousePos then
				local delta = input.Position.X - State.viewportLastMousePos.X
				State.viewportCurrentRotationY = State.viewportCurrentRotationY + (delta * 0.5) -- Adjust sensitivity here (Flipped direction)
				State.viewportLastMousePos = input.Position

				if State.viewportCharClone then
					local cloneRoot = State.viewportCharClone:FindFirstChild("HumanoidRootPart")
					if cloneRoot then
						cloneRoot.CFrame = CFrame.new(0, 0, 0) * CFrame.Angles(0, math.rad(State.viewportCurrentRotationY), 0)
					end
				end
			end
		end
	end)

	Services.UserInputService.InputEnded:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			State.viewportIsRotating = false
			State.viewportLastMousePos = nil
		end
	end)
end

createCharacterViewport()

-- Function to clone and setup character in viewport (STATIC - only called once)
local function updateCharacterViewport()
	-- Clear existing model
	for _, child in ipairs(UI.worldModel:GetChildren()) do
		child:Destroy()
	end

	local character = player.Character
	if not character then return end

	-- Wait for character to be fully loaded
	local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
	if not humanoidRootPart then return end

	-- Clone character
	local oldArchivable = character.Archivable
	character.Archivable = true
	State.viewportCharClone = character:Clone()

	character.Archivable = oldArchivable

	if State.viewportCharClone then
		-- Remove scripts and clean up the model for static display
		for _, desc in ipairs(State.viewportCharClone:GetDescendants()) do
			if desc:IsA("BaseScript") or desc:IsA("LocalScript") then
				desc:Destroy()
			elseif desc:IsA("Humanoid") then
				-- Disable humanoid display
				desc.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.None
			elseif desc:IsA("Animator") then
				-- Stop all existing animation tracks and destroy animator
				for _, track in ipairs(desc:GetPlayingAnimationTracks()) do
					track:Stop()
				end
				desc:Destroy()  -- Remove old animator, we'll create a fresh one
			end
		end

		-- Reset position to current rotation
		local cloneRoot = State.viewportCharClone:FindFirstChild("HumanoidRootPart")
		if cloneRoot then
			cloneRoot.CFrame = CFrame.new(0, 0, 0) * CFrame.Angles(0, math.rad(State.viewportCurrentRotationY), 0)
		end

		State.viewportCharClone.Parent = UI.worldModel

		-- Create fresh animator and load idle animation ONLY
		local humanoid = State.viewportCharClone:FindFirstChildOfClass("Humanoid")
		if humanoid then
			-- Create a fresh animator (no inherited tracks)
			local animator = Instance.new("Animator")
			animator.Parent = humanoid

			-- Load and play idle animation
			local anim = Instance.new("Animation")
			anim.AnimationId = "rbxassetid://115995667698768"
			local track = animator:LoadAnimation(anim)
			track.Looped = true
			track.Priority = Enum.AnimationPriority.Idle
			track:Play()
		end

		-- Position camera to see full body (front view)
		UI.viewportCamera.CFrame = CFrame.new(Vector3.new(2.15, 0, 7), Vector3.new(0, 0, 0))
	end
end

-- NOTE: Character viewport is STATIC - only updates when panel opens
-- No CharacterAdded connection to avoid movement updates

-- ============================================================================
-- STATUS CONTAINER (contains health bar and other status info)
-- ============================================================================

local function createStatusContainer()
	UI.statusContainer = Instance.new("Frame")
	UI.statusContainer.Name = "StatusContainer"
	UI.statusContainer.Size = UDim2.new(0.37, 0, 1, 0)  -- 37% width, full height
	UI.statusContainer.Position = UDim2.new(0.63, 0, 0, 0)  -- Right side after viewport
	UI.statusContainer.BackgroundTransparency = 1
	UI.statusContainer.BorderSizePixel = 0
	UI.statusContainer.ZIndex = 11
	UI.statusContainer.Parent = UI.PlayerContainer

	UI.healthBarContainer = Instance.new("Frame")
	UI.healthBarContainer.Name = "HealthBarContainer"
	UI.healthBarContainer.Size = UDim2.new(0.8, 0, 0, 9)
	UI.healthBarContainer.Position = UDim2.new(0.1, 0, 0.08, 0)
	UI.healthBarContainer.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	UI.healthBarContainer.BorderSizePixel = 0
	UI.healthBarContainer.ZIndex = 12
	UI.healthBarContainer.Parent = UI.statusContainer  -- Parent to StatusContainer

	UI.healthBarFill = Instance.new("Frame")
	UI.healthBarFill.Name = "HealthFill"
	UI.healthBarFill.Size = UDim2.new(1, 0, 1, 0)  -- Full health
	UI.healthBarFill.Position = UDim2.new(0, 0, 0, 0)
	UI.healthBarFill.AnchorPoint = Vector2.new(0, 0)
	UI.healthBarFill.BackgroundColor3 = Color3.fromRGB(255, 255, 255)  -- White
	UI.healthBarFill.BorderSizePixel = 0
	UI.healthBarFill.ZIndex = 12
	UI.healthBarFill.Parent = UI.healthBarContainer

	local healthFillCorner = Instance.new("UICorner")
	healthFillCorner.CornerRadius = UDim.new(0, 4)
	healthFillCorner.Parent = UI.healthBarFill

	-- Vertical divider between character model and health section
	local characterDivider = Instance.new("Frame")
	characterDivider.Name = "CharacterDivider"
	characterDivider.Size = UDim2.new(0, 1, 1, 0)
	characterDivider.Position = UDim2.new(0.55, 0, 0, 0)  -- Between viewport and status container
	characterDivider.BackgroundColor3 = Color3.fromRGB(80, 80, 120)
	characterDivider.BackgroundTransparency = 0.6
	characterDivider.BorderSizePixel = 0
	characterDivider.ZIndex = 11
	characterDivider.Parent = UI.PlayerContainer

	UI.healthLabel = Instance.new("TextLabel")
	UI.healthLabel.Name = "HealthLabel"
	UI.healthLabel.Size = UDim2.new(1, 0, 0, 20)
	UI.healthLabel.Position = UDim2.new(0, 0, 0, -18)  -- Lower position (closer to bar)
	UI.healthLabel.BackgroundTransparency = 1
	UI.healthLabel.Text = "Health 100/100"
	UI.healthLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
	UI.healthLabel.TextSize = 14
	UI.healthLabel.TextXAlignment = Enum.TextXAlignment.Right  -- Align to right
	UI.healthLabel.Font = Enum.Font.GothamBold
	UI.healthLabel.ZIndex = 12
	UI.healthLabel.Parent = UI.healthBarContainer
end

createStatusContainer()

-- Function to update health bar
local function updateHealthBar()
	local character = player.Character
	if not character then return end

	local humanoid = character:FindFirstChildOfClass("Humanoid")
	if not humanoid then return end

	local healthPercent = humanoid.Health / humanoid.MaxHealth
	UI.healthBarFill.Size = UDim2.new(healthPercent, -4, 1, -4)  -- Horizontal resize

	-- Update text label
	UI.healthLabel.Text = string.format("Health %d/%d", math.floor(humanoid.Health), math.floor(humanoid.MaxHealth))

	-- Color gradient: white at full, red at low
	if healthPercent > 0.5 then
		UI.healthBarFill.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	elseif healthPercent > 0.25 then
		UI.healthBarFill.BackgroundColor3 = Color3.fromRGB(255, 200, 150)
	else
		UI.healthBarFill.BackgroundColor3 = Color3.fromRGB(255, 100, 100)
	end
end

-- Connect health bar to actual health
-- Connect health bar to actual health
local function connectHealthBar()
	if State.healthConnection then
		State.healthConnection:Disconnect()
	end
	
	local character = player.Character
	if not character then return end
	
	local humanoid = character:FindFirstChildOfClass("Humanoid")
	if not humanoid then return end
	
	State.healthConnection = humanoid:GetPropertyChangedSignal("Health"):Connect(updateHealthBar)
	updateHealthBar()
end

player.CharacterAdded:Connect(function(char)
	task.wait(0.5)
	connectHealthBar()
end)

-- ============================================================================
-- GRID UTILITY FUNCTIONS
-- ============================================================================

local function canPlaceItem(width, height, startRow, startCol, excludeItemId)
	-- Check bounds
	if startRow < 1 or startCol < 1 then return false end
	if startRow + height - 1 > Config.GRID_ROWS then return false end
	if startCol + width - 1 > Config.GRID_COLS then return false end
	
	-- Check if cells are empty
	for r = startRow, startRow + height - 1 do
		for c = startCol, startCol + width - 1 do
			local occupant = Data.gridData[r][c]
			if occupant ~= nil and occupant ~= excludeItemId then
				return false
			end
		end
	end
	
	return true
end

-- Check if an item of given dimensions can fit ANYWHERE in inventory (tries both orientations)
canFitItemAnywhere = function(width, height)
	-- Try normal orientation
	for row = 1, Config.GRID_ROWS do
		for col = 1, Config.GRID_COLS do
			if canPlaceItem(width, height, row, col, nil) then
				return true
			end
		end
	end
	
	-- Try rotated if different dimensions
	if width ~= height then
		for row = 1, Config.GRID_ROWS do
			for col = 1, Config.GRID_COLS do
				if canPlaceItem(height, width, row, col, nil) then
					return true
				end
			end
		end
	end
	
	return false
end

local function placeItemInGrid(itemId, width, height, startRow, startCol)
	for r = startRow, startRow + height - 1 do
		-- Bounds check for row
		if r >= 1 and r <= Config.GRID_ROWS and Data.gridData[r] then
			for c = startCol, startCol + width - 1 do
				-- Bounds check for column
				if c >= 1 and c <= Config.GRID_COLS then
					Data.gridData[r][c] = itemId
				end
			end
		end
	end
end

local function removeItemFromGrid(itemId)
	for r = 1, Config.GRID_ROWS do
		for c = 1, Config.GRID_COLS do
			if Data.gridData[r][c] == itemId then
				Data.gridData[r][c] = nil
			end
		end
	end
end

-- ============================================================================
-- STORAGE GRID UTILITY FUNCTIONS
-- ============================================================================

local function initializeStorageGridData()
	Data.storageGridData = {}
	for r = 1, Config.STORAGE.GRID_ROWS do
		Data.storageGridData[r] = {}
		for c = 1, Config.STORAGE.GRID_COLS do
			Data.storageGridData[r][c] = nil
		end
	end
	Data.storageItems = {}
end

local function removeItemFromStorageGrid(itemId)
	for r = 1, Config.STORAGE.GRID_ROWS do
		for c = 1, Config.STORAGE.GRID_COLS do
			if Data.storageGridData[r] and Data.storageGridData[r][c] == itemId then
				Data.storageGridData[r][c] = nil
			end
		end
	end
end

local function placeItemInStorageGrid(itemId, width, height, startRow, startCol)
	for r = startRow, startRow + height - 1 do
		for c = startCol, startCol + width - 1 do
			if Data.storageGridData[r] then
				Data.storageGridData[r][c] = itemId
			end
		end
	end
end

local function canPlaceItemInStorage(width, height, startRow, startCol, excludeItemId)
	if startRow < 1 or startCol < 1 then return false end
	if startRow + height - 1 > Config.STORAGE.GRID_ROWS then return false end
	if startCol + width - 1 > Config.STORAGE.GRID_COLS then return false end
	
	for r = startRow, startRow + height - 1 do
		for c = startCol, startCol + width - 1 do
			if Data.storageGridData[r] then
				local occupant = Data.storageGridData[r][c]
				if occupant ~= nil and occupant ~= excludeItemId then
					return false
				end
			end
		end
	end
	return true
end

-- ============================================================================
-- CHEST GRID UTILITY FUNCTIONS (parallel to inventory grid)
-- ============================================================================

local function initializeChestGridData()
	Data.chestGridData = {}
	local chestConf = State.currentChestConfig or { gridRows = 6, gridCols = 6 }
	for r = 1, chestConf.gridRows do
		Data.chestGridData[r] = {}
		for c = 1, chestConf.gridCols do
			Data.chestGridData[r][c] = nil
		end
	end
	Data.chestItems = {}
end

local function canPlaceItemInChest(width, height, startRow, startCol, excludeItemId)
	-- Check bounds
	local chestConf = State.currentChestConfig or { gridRows = 6, gridCols = 6 }
	if startRow < 1 or startCol < 1 then return false end
	if startRow + height - 1 > chestConf.gridRows then return false end
	if startCol + width - 1 > chestConf.gridCols then return false end
	
	-- Check if cells are empty
	for r = startRow, startRow + height - 1 do
		for c = startCol, startCol + width - 1 do
			if Data.chestGridData[r] then
				local occupant = Data.chestGridData[r][c]
				if occupant ~= nil and occupant ~= excludeItemId then
					return false
				end
			end
		end
	end
	
	return true
end

local function placeItemInChestGrid(itemId, width, height, startRow, startCol)
	for r = startRow, startRow + height - 1 do
		for c = startCol, startCol + width - 1 do
			if Data.chestGridData[r] then
				Data.chestGridData[r][c] = itemId
			end
		end
	end
end

local function removeItemFromChestGrid(itemId)
	local chestConf = State.currentChestConfig or { gridRows = 6, gridCols = 6 }
	for r = 1, chestConf.gridRows do
		for c = 1, chestConf.gridCols do
			if Data.chestGridData[r] and Data.chestGridData[r][c] == itemId then
				Data.chestGridData[r][c] = nil
			end
		end
	end
end

-- SMART PLACEMENT for CHEST: Find best position for item at target cell (with rotation)
-- Same logic as findBestPlacement but for chest grid
local function findBestChestPlacement(width, height, targetRow, targetCol, excludeItemId)
	-- Try 1: Current orientation at target (exact position)
	if canPlaceItemInChest(width, height, targetRow, targetCol, excludeItemId) then
		return targetRow, targetCol, width, height, false
	end
	
	-- Try 2: Rotated orientation at target (exact position)
	if canPlaceItemInChest(height, width, targetRow, targetCol, excludeItemId) then
		return targetRow, targetCol, height, width, true
	end
	
	-- Try 3: Search nearby with NEGATIVE offsets prioritized
	local maxOffset = math.max(width, height)
	
	for totalOffset = 1, maxOffset * 2 do
		for offsetR = 0, math.min(totalOffset, maxOffset) do
			local offsetC = totalOffset - offsetR
			if offsetC <= maxOffset then
				-- Try all sign combinations: (-,-), (-,+), (+,-), (+,+)
				for _, signR in ipairs({-1, 1}) do
					for _, signC in ipairs({-1, 1}) do
						local tryRow = targetRow + (offsetR * signR)
						local tryCol = targetCol + (offsetC * signC)
						
						-- Try current orientation
						if canPlaceItemInChest(width, height, tryRow, tryCol, excludeItemId) then
							return tryRow, tryCol, width, height, false
						end
						
						-- Try rotated
						if canPlaceItemInChest(height, width, tryRow, tryCol, excludeItemId) then
							return tryRow, tryCol, height, width, true
						end
					end
				end
			end
		end
	end
	
	return nil, nil, nil, nil, nil  -- No valid position found
end

local function getGridPositionFromAbsolute(absX, absY)
	local containerPos = UI.gridContainer.AbsolutePosition
	local containerScale = UI.uiScale.Scale
	
	-- Account for UIScale on container position and size
	local scaledCellSize = (Config.CELL_SIZE + Config.CELL_PADDING) * containerScale
	
	local relX = absX - containerPos.X
	local relY = absY - containerPos.Y
	
	-- Use center-based rounding: add half cell size before floor for symmetric behavior
	-- This makes the cell switch when cursor crosses the CENTER of cell boundary
	local col = math.floor((relX + scaledCellSize / 2) / scaledCellSize) + 1
	local row = math.floor((relY + scaledCellSize / 2) / scaledCellSize) + 1
	
	return row, col
end

-- ============================================================================
-- ITEM VISUAL CREATION
-- ============================================================================

local function createItemFrame(itemConfig, width, height, row, col)
	local itemFrame = Instance.new("Frame")
	itemFrame.Name = itemConfig.id
	itemFrame.Size = UDim2.new(0, width * Config.CELL_SIZE + (width - 1) * Config.CELL_PADDING, 0, height * Config.CELL_SIZE + (height - 1) * Config.CELL_PADDING)
	itemFrame.Position = UDim2.new(0, (col - 1) * (Config.CELL_SIZE + Config.CELL_PADDING), 0, (row - 1) * (Config.CELL_SIZE + Config.CELL_PADDING))
	
	-- Use RarityFrameColors for background
	local frameColor = ItemConfig.GetRarityFrameColor(itemConfig.rarity or "Common")
	local frameTransparency = ItemConfig.GetRarityFrameTransparency()
	itemFrame.BackgroundColor3 = frameColor
	itemFrame.BackgroundTransparency = frameTransparency
	itemFrame.BorderSizePixel = 0
	itemFrame.ZIndex = 15
	itemFrame.Parent = UI.gridContainer
	
	-- Stroke color (using RarityColors for stroke/border)
	local strokeColor = ItemConfig.GetRarityColor(itemConfig.rarity or "Common")
	
	-- Gradient (based on frame color for visual effect)
	local darkerColor = Color3.fromRGB(
		math.floor(frameColor.R * 255 * 0.6),
		math.floor(frameColor.G * 255 * 0.6),
		math.floor(frameColor.B * 255 * 0.6)
	)
	local gradient = Instance.new("UIGradient")
	gradient.Color = ColorSequence.new({
		ColorSequenceKeypoint.new(0, frameColor),
		ColorSequenceKeypoint.new(1, darkerColor),
	})
	gradient.Rotation = 45
	gradient.Parent = itemFrame
	
	-- Stroke (using RarityColors for stroke/border)
	local stroke = Instance.new("UIStroke")
	stroke.Name = "ItemStroke"
	stroke.Color = strokeColor
	stroke.Thickness = 1
	stroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
	stroke.Parent = itemFrame
	
	-- Item Icon (ImageLabel if icon available, else fallback Frame)
	if itemConfig.icon and itemConfig.icon ~= "" and itemConfig.icon ~= "rbxassetid://0" then
		local iconImage = Instance.new("ImageLabel")
		iconImage.Name = "Icon"
		iconImage.Size = UDim2.new(1, 0, 1, 0)  -- Full size (scale 1x1)
		iconImage.Position = UDim2.new(0, 0, 0, 0)
		iconImage.BackgroundTransparency = 1
		iconImage.Image = itemConfig.icon
		iconImage.ScaleType = Enum.ScaleType.Fit
		iconImage.ZIndex = 16
		iconImage.Parent = itemFrame
	else
		-- Fallback: Placeholder shape icon (if no image)
		local icon = Instance.new("Frame")
		icon.Name = "Icon"
		icon.Size = UDim2.new(0.6, 0, 0.6, 0)
		icon.Position = UDim2.new(0.2, 0, 0.2, 0)
		icon.BackgroundColor3 = itemConfig.color or Color3.fromRGB(200, 200, 200)
		icon.BackgroundTransparency = 0.3
		icon.BorderSizePixel = 0
		icon.ZIndex = 16
		icon.Parent = itemFrame
	end
	
	-- Name label removed - info shown via long-press popup
	
	return itemFrame
end

-- ============================================================================
-- HIGHLIGHT SYSTEM
-- ============================================================================

local function clearHighlights()
	if State.highlightOverlay and State.highlightOverlay.Parent then
		State.highlightOverlay:Destroy()
		State.highlightOverlay = nil
	end
end

local function highlightSlots(startRow, startCol, width, height, isValid)
	clearHighlights()
	
	-- Don't show highlight if out of bounds
	if startRow < 1 or startCol < 1 or startRow > Config.GRID_ROWS or startCol > Config.GRID_COLS then
		return
	end
	
	local color = isValid and Color3.fromRGB(100, 255, 100) or Color3.fromRGB(255, 100, 100)
	
	-- Create single highlight overlay with item size
	State.highlightOverlay = Instance.new("Frame")
	State.highlightOverlay.Name = "HighlightOverlay"
	State.highlightOverlay.Size = UDim2.new(0, width * Config.CELL_SIZE + (width - 1) * Config.CELL_PADDING, 0, height * Config.CELL_SIZE + (height - 1) * Config.CELL_PADDING)
	State.highlightOverlay.Position = UDim2.new(0, (startCol - 1) * (Config.CELL_SIZE + Config.CELL_PADDING), 0, (startRow - 1) * (Config.CELL_SIZE + Config.CELL_PADDING))
	State.highlightOverlay.BackgroundColor3 = color
	State.highlightOverlay.BackgroundTransparency = 0.7
	State.highlightOverlay.BorderSizePixel = 0
	State.highlightOverlay.ZIndex = 14  -- Above slots but below items
	State.highlightOverlay.Parent = UI.gridContainer
	
	
	local overlayStroke = Instance.new("UIStroke")
	overlayStroke.Color = color
	overlayStroke.Thickness = 3
	overlayStroke.Parent = State.highlightOverlay
end

State.originalSlotOverlay = nil  -- Single overlay for original position highlight

local function highlightOriginalSlot(row, col, width, height)
	-- Clear previous overlay if exists
	if State.originalSlotOverlay and State.originalSlotOverlay.Parent then
		State.originalSlotOverlay:Destroy()
	end
	
	-- Create single yellow overlay frame covering entire item size
	State.originalSlotOverlay = Instance.new("Frame")
	State.originalSlotOverlay.Name = "OriginalSlotOverlay"
	State.originalSlotOverlay.Size = UDim2.new(0, width * Config.CELL_SIZE + (width - 1) * Config.CELL_PADDING, 0, height * Config.CELL_SIZE + (height - 1) * Config.CELL_PADDING)
	State.originalSlotOverlay.Position = UDim2.new(0, (col - 1) * (Config.CELL_SIZE + Config.CELL_PADDING), 0, (row - 1) * (Config.CELL_SIZE + Config.CELL_PADDING))
	State.originalSlotOverlay.BackgroundColor3 = Color3.fromRGB(255, 220, 100)  -- Yellow
	State.originalSlotOverlay.BackgroundTransparency = 0.8
	State.originalSlotOverlay.BorderSizePixel = 0
	State.originalSlotOverlay.ZIndex = 12  -- Above slots but below items
	State.originalSlotOverlay.Parent = UI.gridContainer
	
	
	local overlayStroke = Instance.new("UIStroke")
	overlayStroke.Color = Color3.fromRGB(255, 220, 100)  -- Yellow
	overlayStroke.Thickness = 2
	overlayStroke.Transparency = 0.3
	overlayStroke.Parent = State.originalSlotOverlay
end

local function resetOriginalSlotHighlight(row, col, width, height)
	-- Destroy the overlay
	if State.originalSlotOverlay and State.originalSlotOverlay.Parent then
		State.originalSlotOverlay:Destroy()
		State.originalSlotOverlay = nil
	end
end

-- ============================================================================
-- CHEST HIGHLIGHT SYSTEM (parallel to inventory highlights)
-- ============================================================================

State.chestHighlightOverlay = nil
State.chestOriginalSlotOverlay = nil

local function clearChestHighlights()
	if State.chestHighlightOverlay and State.chestHighlightOverlay.Parent then
		State.chestHighlightOverlay:Destroy()
		State.chestHighlightOverlay = nil
	end
end

local function highlightChestSlots(startRow, startCol, width, height, isValid)
	clearChestHighlights()
	
	-- Use dynamic chest config for bounds checking
	local chestConf = State.currentChestConfig or { gridRows = 6, gridCols = 6 }
	if startRow < 1 or startCol < 1 or startRow > chestConf.gridRows or startCol > chestConf.gridCols then
		return
	end
	
	local color = isValid and Color3.fromRGB(100, 255, 100) or Color3.fromRGB(255, 100, 100)
	local cellSize = Config.CHEST.CELL_SIZE
	local cellPadding = Config.CHEST.CELL_PADDING
	
	State.chestHighlightOverlay = Instance.new("Frame")
	State.chestHighlightOverlay.Name = "ChestHighlightOverlay"
	State.chestHighlightOverlay.Size = UDim2.new(0, width * cellSize + (width - 1) * cellPadding, 0, height * cellSize + (height - 1) * cellPadding)
	State.chestHighlightOverlay.Position = UDim2.new(0, (startCol - 1) * (cellSize + cellPadding), 0, (startRow - 1) * (cellSize + cellPadding))
	State.chestHighlightOverlay.BackgroundColor3 = color
	State.chestHighlightOverlay.BackgroundTransparency = 0.7
	State.chestHighlightOverlay.BorderSizePixel = 0
	State.chestHighlightOverlay.ZIndex = 14
	State.chestHighlightOverlay.Parent = UI.gridContainerChest
	
	local overlayStroke = Instance.new("UIStroke")
	overlayStroke.Color = color
	overlayStroke.Thickness = 3
	overlayStroke.Parent = State.chestHighlightOverlay
end

local function highlightChestOriginalSlot(row, col, width, height)
	if State.chestOriginalSlotOverlay and State.chestOriginalSlotOverlay.Parent then
		State.chestOriginalSlotOverlay:Destroy()
	end
	
	local cellSize = Config.CHEST.CELL_SIZE
	local cellPadding = Config.CHEST.CELL_PADDING
	
	State.chestOriginalSlotOverlay = Instance.new("Frame")
	State.chestOriginalSlotOverlay.Name = "ChestOriginalSlotOverlay"
	State.chestOriginalSlotOverlay.Size = UDim2.new(0, width * cellSize + (width - 1) * cellPadding, 0, height * cellSize + (height - 1) * cellPadding)
	State.chestOriginalSlotOverlay.Position = UDim2.new(0, (col - 1) * (cellSize + cellPadding), 0, (row - 1) * (cellSize + cellPadding))
	State.chestOriginalSlotOverlay.BackgroundColor3 = Color3.fromRGB(255, 220, 100)
	State.chestOriginalSlotOverlay.BackgroundTransparency = 0.8
	State.chestOriginalSlotOverlay.BorderSizePixel = 0
	State.chestOriginalSlotOverlay.ZIndex = 12
	State.chestOriginalSlotOverlay.Parent = UI.gridContainerChest
	
	local overlayStroke = Instance.new("UIStroke")
	overlayStroke.Color = Color3.fromRGB(255, 220, 100)
	overlayStroke.Thickness = 2
	overlayStroke.Transparency = 0.3
	overlayStroke.Parent = State.chestOriginalSlotOverlay
end

local function resetChestOriginalSlotHighlight()
	if State.chestOriginalSlotOverlay and State.chestOriginalSlotOverlay.Parent then
		State.chestOriginalSlotOverlay:Destroy()
		State.chestOriginalSlotOverlay = nil
	end
end

local function resetChestOriginalSlotHighlight()
	if State.chestOriginalSlotOverlay and State.chestOriginalSlotOverlay.Parent then
		State.chestOriginalSlotOverlay:Destroy()
		State.chestOriginalSlotOverlay = nil
	end
end

-- ============================================================================
-- STORAGE HIGHLIGHT SYSTEM (parallel to chest highlights)
-- ============================================================================

State.storageHighlightOverlay = nil
State.storageOriginalSlotOverlay = nil

local function clearStorageHighlights()
	if State.storageHighlightOverlay and State.storageHighlightOverlay.Parent then
		State.storageHighlightOverlay:Destroy()
		State.storageHighlightOverlay = nil
	end
end

local function highlightStorageSlots(startRow, startCol, width, height, isValid)
	clearStorageHighlights()
	
	if startRow < 1 or startCol < 1 or startRow > Config.STORAGE.GRID_ROWS or startCol > Config.STORAGE.GRID_COLS then return end
	
	local color = isValid and Color3.fromRGB(100, 255, 100) or Color3.fromRGB(255, 100, 100)
	
	State.storageHighlightOverlay = Instance.new("Frame")
	State.storageHighlightOverlay.Name = "StorageHighlightOverlay"
	State.storageHighlightOverlay.Size = UDim2.new(0, width * Config.STORAGE.CELL_SIZE + (width - 1) * Config.STORAGE.CELL_PADDING, 0, height * Config.STORAGE.CELL_SIZE + (height - 1) * Config.STORAGE.CELL_PADDING)
	State.storageHighlightOverlay.Position = UDim2.new(0, (startCol - 1) * (Config.STORAGE.CELL_SIZE + Config.STORAGE.CELL_PADDING), 0, (startRow - 1) * (Config.STORAGE.CELL_SIZE + Config.STORAGE.CELL_PADDING))
	State.storageHighlightOverlay.BackgroundColor3 = color
	State.storageHighlightOverlay.BackgroundTransparency = 0.7
	State.storageHighlightOverlay.BorderSizePixel = 0
	State.storageHighlightOverlay.ZIndex = 14
	State.storageHighlightOverlay.Parent = UI.storageGridFrame
	
	local stroke = Instance.new("UIStroke")
	stroke.Color = color
	stroke.Thickness = 3
	stroke.Parent = State.storageHighlightOverlay
end

local function highlightStorageOriginalSlot(row, col, width, height)
	if State.storageOriginalSlotOverlay and State.storageOriginalSlotOverlay.Parent then
		State.storageOriginalSlotOverlay:Destroy()
	end
	
	State.storageOriginalSlotOverlay = Instance.new("Frame")
	State.storageOriginalSlotOverlay.Name = "StorageOriginalSlotOverlay"
	State.storageOriginalSlotOverlay.Size = UDim2.new(0, width * Config.STORAGE.CELL_SIZE + (width - 1) * Config.STORAGE.CELL_PADDING, 0, height * Config.STORAGE.CELL_SIZE + (height - 1) * Config.STORAGE.CELL_PADDING)
	State.storageOriginalSlotOverlay.Position = UDim2.new(0, (col - 1) * (Config.STORAGE.CELL_SIZE + Config.STORAGE.CELL_PADDING), 0, (row - 1) * (Config.STORAGE.CELL_SIZE + Config.STORAGE.CELL_PADDING))
	State.storageOriginalSlotOverlay.BackgroundColor3 = Color3.fromRGB(255, 220, 100)
	State.storageOriginalSlotOverlay.BackgroundTransparency = 0.8
	State.storageOriginalSlotOverlay.BorderSizePixel = 0
	State.storageOriginalSlotOverlay.ZIndex = 12
	State.storageOriginalSlotOverlay.Parent = UI.storageGridFrame
	
	local stroke = Instance.new("UIStroke")
	stroke.Color = Color3.fromRGB(255, 220, 100)
	stroke.Thickness = 2
	stroke.Transparency = 0.3
	stroke.Parent = State.storageOriginalSlotOverlay
end

local function resetStorageOriginalSlotHighlight()
	if State.storageOriginalSlotOverlay and State.storageOriginalSlotOverlay.Parent then
		State.storageOriginalSlotOverlay:Destroy()
		State.storageOriginalSlotOverlay = nil
	end
end

-- ============================================================================
-- ITEM INFO POPUP SYSTEM (1.5s long press)
-- ============================================================================

State.itemInfoPopup = nil
State.longPressStartTime = nil
State.longPressItem = nil
Config.LONG_PRESS_DURATION = 0.4  -- seconds (increased for easier quick tap unselect)

local function closeItemInfoPopup()
	if State.itemInfoPopup and State.itemInfoPopup.Parent then
		State.itemInfoPopup:Destroy()
		State.itemInfoPopup = nil
	end
end

local function showItemInfoPopup(itemData)
	closeItemInfoPopup()
	
	local itemConfig = itemData.config
	local itemFrame = itemData.frame
	
	-- Calculate popup position using absolute position (to avoid ClipsDescendants)
	local itemAbsPos = itemFrame.AbsolutePosition
	local itemAbsSize = itemFrame.AbsoluteSize
	local mainPanelPos = UI.mainPanel.AbsolutePosition
	local scale = UI.uiScale.Scale
	
	-- Position popup to the right of item, relative to UI.mainPanel
	local popupX = (itemAbsPos.X + itemAbsSize.X + 10 - mainPanelPos.X) / scale
	local popupY = (itemAbsPos.Y - mainPanelPos.Y) / scale

	
	-- Create popup frame (horizontal layout, short height)
	State.itemInfoPopup = Instance.new("Frame")
	State.itemInfoPopup.Name = "ItemInfoPopup"
	State.itemInfoPopup.Size = UDim2.new(0, 220, 0, 100)
	State.itemInfoPopup.Position = UDim2.new(0, popupX, 0, popupY)  -- Right of item
	State.itemInfoPopup.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	State.itemInfoPopup.BorderSizePixel = 0
	State.itemInfoPopup.ZIndex = 100  -- Very high to be on top
	State.itemInfoPopup.Parent = UI.mainPanel  -- Parent to UI.mainPanel to avoid ClipsDescendants
	
	local popupStroke = Instance.new("UIStroke")
	popupStroke.Color = Color3.fromRGB(100, 80, 140)
	popupStroke.Thickness = 2
	popupStroke.Parent = State.itemInfoPopup
	
	-- Icon frame (top-left) - uses RarityFrameColors based on item rarity
	local iconFrame = Instance.new("Frame")
	iconFrame.Name = "IconFrame"
	iconFrame.Size = UDim2.new(0, 50, 0, 50)
	iconFrame.Position = UDim2.new(0, 10, 0, 10)
	iconFrame.BackgroundColor3 = ItemConfig.GetRarityFrameColor(itemConfig.rarity or "Common")
	iconFrame.BackgroundTransparency = ItemConfig.GetRarityFrameTransparency()
	iconFrame.BorderSizePixel = 0
	iconFrame.ZIndex = 51
	iconFrame.Parent = State.itemInfoPopup
	
	-- Stroke using RarityColors
	local iconStroke = Instance.new("UIStroke")
	iconStroke.Name = "IconStroke"
	iconStroke.Color = ItemConfig.GetRarityColor(itemConfig.rarity or "Common")
	iconStroke.Thickness = 1
	iconStroke.Parent = iconFrame
	
	-- Icon image (inside iconFrame) - full size to match frame
	if itemConfig.icon and itemConfig.icon ~= "" then
		local iconImage = Instance.new("ImageLabel")
		iconImage.Name = "IconImage"
		iconImage.Size = UDim2.new(1, 0, 1, 0)
		iconImage.BackgroundTransparency = 1
		iconImage.Image = itemConfig.icon
		iconImage.ScaleType = Enum.ScaleType.Fit
		iconImage.ZIndex = 52
		iconImage.Parent = iconFrame
	end
	
	-- Item name (white, next to icon)
	local nameLabel = Instance.new("TextLabel")
	nameLabel.Name = "ItemName"
	nameLabel.Size = UDim2.new(0, 180, 0, 22)
	nameLabel.Position = UDim2.new(0, 70, 0, 10)
	nameLabel.BackgroundTransparency = 1
	nameLabel.Text = itemConfig.name
	nameLabel.TextColor3 = Color3.new(1, 1, 1)
	nameLabel.TextSize = 16
	nameLabel.TextXAlignment = Enum.TextXAlignment.Left
	nameLabel.Font = Enum.Font.GothamBold
	nameLabel.ZIndex = 51
	nameLabel.Parent = State.itemInfoPopup
	
	-- Weight (below name)
	local weightLabel = Instance.new("TextLabel")
	weightLabel.Name = "WeightLabel"
	weightLabel.Size = UDim2.new(0, 180, 0, 16)
	weightLabel.Position = UDim2.new(0, 70, 0, 34)
	weightLabel.BackgroundTransparency = 1
	weightLabel.Text = "Weight: " .. (itemConfig.weight or "1.0") .. " kg"
	weightLabel.TextColor3 = Color3.fromRGB(150, 150, 180)
	weightLabel.TextSize = 12
	weightLabel.TextXAlignment = Enum.TextXAlignment.Left
	weightLabel.Font = Enum.Font.Gotham
	weightLabel.ZIndex = 51
	weightLabel.Parent = State.itemInfoPopup
	
	-- Divider
	local divider = Instance.new("Frame")
	divider.Name = "Divider"
	divider.Size = UDim2.new(1, -20, 0, 1)
	divider.Position = UDim2.new(0, 10, 0, 65)
	divider.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
	divider.BorderSizePixel = 0
	divider.ZIndex = 51
	divider.Parent = State.itemInfoPopup
	
	-- Description (below divider)
	local descLabel = Instance.new("TextLabel")
	descLabel.Name = "Description"
	descLabel.Size = UDim2.new(1, -20, 0, 25)
	descLabel.Position = UDim2.new(0, 10, 0, 70)
	descLabel.BackgroundTransparency = 1
	descLabel.Text = itemConfig.description or "No description available."
	descLabel.TextColor3 = Color3.fromRGB(180, 180, 200)
	descLabel.TextSize = 11
	descLabel.TextXAlignment = Enum.TextXAlignment.Left
	descLabel.TextWrapped = true
	descLabel.Font = Enum.Font.Gotham
	descLabel.ZIndex = 51
	descLabel.Parent = State.itemInfoPopup
	
	-- Close on click
	State.itemInfoPopup.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			closeItemInfoPopup()
		end
	end)
end

-- ============================================================================
-- SELECTION SYSTEM (Click-to-Select)
-- ============================================================================

local function clearSelection()
	if State.selectionHighlight and State.selectionHighlight.Parent then
		State.selectionHighlight:Destroy()
		State.selectionHighlight = nil
	end
	State.selectedItem = nil
	updateActionBar(nil)  -- Hide action bar
end

local function selectItem(itemData)
	-- Play selected sound
	local soundService = game:GetService("SoundService")
	local selectedSound = soundService:FindFirstChild("Selected")
	if selectedSound and selectedSound:IsA("Sound") then
		selectedSound:Play()
	end
	
	-- Clear previous selection
	clearSelection()
	
	State.selectedItem = itemData
	
	-- Create yellow selection highlight on the item frame
	State.selectionHighlight = Instance.new("Frame")
	State.selectionHighlight.Name = "SelectionHighlight"
	State.selectionHighlight.Size = UDim2.new(1, 0, 1, 0)  -- Same size as item frame
	State.selectionHighlight.Position = UDim2.new(0, 0, 0, 0)  -- Aligned with item frame
	State.selectionHighlight.BackgroundTransparency = 1
	State.selectionHighlight.BorderSizePixel = 0
	State.selectionHighlight.ZIndex = 20 -- Higher than icon (16)
	State.selectionHighlight.Parent = itemData.frame
	
	
	local highlightStroke = Instance.new("UIStroke")
	highlightStroke.Name = "SelectionStroke"
	highlightStroke.Color = Color3.fromRGB(255, 220, 100)  -- Yellow
	highlightStroke.Thickness = 1
	highlightStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
	highlightStroke.Parent = State.selectionHighlight
	
	-- Pulse animation for selection
	local function pulseAnimation()
		if not State.selectionHighlight or not State.selectionHighlight.Parent then return end
		local stroke = State.selectionHighlight:FindFirstChild("SelectionStroke")
		if stroke then
			Services.TweenService:Create(stroke, TweenInfo.new(0.5, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {
				Thickness = 4
			}):Play()
			task.delay(0.5, function()
				if stroke and stroke.Parent then
					Services.TweenService:Create(stroke, TweenInfo.new(0.5, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {
						Thickness = 2
					}):Play()
				end
			end)
		end
	end
	pulseAnimation()
	
	-- Update action bar with selected item
	updateActionBar(itemData)
	
	-- Highlight compatible armor slots if this is armor
	local itemConfig = itemData.config
	if itemConfig and itemConfig.isArmor and itemConfig.slotType then
		-- Highlight the compatible slot (only if not already equipped)
		for slotName, slotData in pairs(Data.armorSlots) do
			if slotName == itemConfig.slotType then
				-- This slot is compatible - but only highlight if NOT already equipped
				if not slotData.equipped then
					slotData.stroke.Color = Color3.fromRGB(100, 255, 100)
					Services.TweenService:Create(slotData.stroke, TweenInfo.new(0.3), {
						Thickness = 3
					}):Play()
				end
				-- If already equipped, don't highlight (keep current state)
			else
				-- Reset non-compatible slots
				if not slotData.equipped then
					slotData.stroke.Color = Color3.fromRGB(80, 80, 120)
					slotData.stroke.Thickness = 1
				end
			end
		end
	else
		-- Not armor - reset all slot highlights
		for slotName, slotData in pairs(Data.armorSlots) do
			if not slotData.equipped then
				slotData.stroke.Color = Color3.fromRGB(80, 80, 120)
				slotData.stroke.Thickness = 1
			end
		end
	end
end

-- SMART PLACEMENT: Find best position for item at target cell (with rotation)
-- Now searches UPWARD and LEFTWARD first, so clicking bottom of 1x4 space still works
local function findBestPlacement(itemData, targetRow, targetCol)
	local width = itemData.width
	local height = itemData.height
	local itemId = itemData.config.id
	
	-- Try 1: Current orientation at target (exact position)
	if canPlaceItem(width, height, targetRow, targetCol, itemId) then
		return targetRow, targetCol, width, height, false
	end
	
	-- Try 2: Rotated orientation at target (exact position)
	if canPlaceItem(height, width, targetRow, targetCol, itemId) then
		return targetRow, targetCol, height, width, true
	end
	
	-- Try 3: Search nearby with NEGATIVE offsets prioritized
	-- For 2x2 clicking cell 4 (row 2, col 2), we need to find (row 1, col 1)
	local maxOffset = math.max(width, height)
	
	-- Search all combinations: prioritize small offsets first
	for totalOffset = 1, maxOffset * 2 do
		for offsetR = 0, math.min(totalOffset, maxOffset) do
			local offsetC = totalOffset - offsetR
			if offsetC <= maxOffset then
				-- Try all sign combinations: (-,-), (-,+), (+,-), (+,+)
				for _, signR in ipairs({-1, 1}) do
					for _, signC in ipairs({-1, 1}) do
						local tryRow = targetRow + (offsetR * signR)
						local tryCol = targetCol + (offsetC * signC)
						
						-- Try current orientation
						if canPlaceItem(width, height, tryRow, tryCol, itemId) then
							return tryRow, tryCol, width, height, false
						end
						
						-- Try rotated
						if canPlaceItem(height, width, tryRow, tryCol, itemId) then
							return tryRow, tryCol, height, width, true
						end
					end
				end
			end
		end
	end
	
	return nil, nil, nil, nil, nil  -- No valid position found
end

-- Move selected item to target position (smart)
local function moveSelectedItemTo(targetRow, targetCol)
	if not State.selectedItem then return false end
	
	local itemData = State.selectedItem
	local itemId = itemData.config.id
	
	-- Remove from current position
	removeItemFromGrid(itemId)
	
	-- Find best placement
	local newRow, newCol, newWidth, newHeight, rotated = findBestPlacement(itemData, targetRow, targetCol)
	
	if newRow then
		-- Place at new position
		placeItemInGrid(itemId, newWidth, newHeight, newRow, newCol)
		
		-- Update item data
		itemData.row = newRow
		itemData.col = newCol
		itemData.width = newWidth
		itemData.height = newHeight
		if rotated then
			itemData.rotated = not itemData.rotated
		end
		
		-- Update visual
		itemData.frame.Size = UDim2.new(0, newWidth * Config.CELL_SIZE + (newWidth - 1) * Config.CELL_PADDING, 0, newHeight * Config.CELL_SIZE + (newHeight - 1) * Config.CELL_PADDING)
		itemData.frame.Position = UDim2.new(0, (newCol - 1) * (Config.CELL_SIZE + Config.CELL_PADDING), 0, (newRow - 1) * (Config.CELL_SIZE + Config.CELL_PADDING))
		
		-- Flash effect if rotated
		if rotated then
			local stroke = itemData.frame:FindFirstChild("ItemStroke")
			if stroke then
				local originalColor = stroke.Color
				stroke.Color = Color3.fromRGB(255, 255, 100)
				Services.TweenService:Create(stroke, TweenInfo.new(0.3), { Color = originalColor }):Play()
			end
		end
		
		-- Clear selection after successful move (deselect item)
		clearSelection()
		
		-- Fire Server Event to save position (Fixes Revert Bug)
		local updateEvent = Services.ReplicatedStorage:FindFirstChild("Remotes") and Services.ReplicatedStorage.Remotes:FindFirstChild("UpdateItemPosition")
		if updateEvent then
			updateEvent:FireServer(itemId, newRow, newCol, rotated)
		end
		
		return true
	else
		-- Couldn't place, restore original position
		placeItemInGrid(itemId, itemData.width, itemData.height, itemData.row, itemData.col)
		-- Clear any highlight that was shown
		clearHighlights()
		return false
	end
end

-- ============================================================================
-- DRAG AND DROP SYSTEM
-- ============================================================================

local function createDragGhost(itemData)
	local ghost = itemData.frame:Clone()
	ghost.Name = "DragGhost"
	ghost.ZIndex = 100
	ghost.BackgroundTransparency = 0.3
	ghost.Parent = UI.screenGui
	
	-- Add a UIScale to the ghost so we can control its size independently
	local ghostScale = Instance.new("UIScale")
	ghostScale.Name = "GhostScale"
	ghostScale.Scale = 1  -- Will be updated in startDrag
	ghostScale.Parent = ghost
	
	-- Make it follow cursor at absolute position
	ghost.AnchorPoint = Vector2.new(0.5, 0.5)
	
	return ghost
end

local function startDrag(itemId, inputPos)
	local itemData = Data.inventoryItems[itemId]
	if not itemData then return end
	
	-- Disable scrolling during drag (MOBILE TOUCH ONLY improvement)
	if UI.contentScroll and (State.activeTouchId or Services.UserInputService:GetLastInputType() == Enum.UserInputType.Touch) then
		UI.contentScroll.ScrollingEnabled = false
	end
	
	State.isDragging = true
	State.draggedItem = itemData
	State.dragSource = "inventory"
	State.dragSourceChestData = nil
	State.originalSlot = { row = itemData.row, col = itemData.col, width = itemData.width, height = itemData.height }
	
	selectItem(itemData)
	
	-- Create ghost (AnchorPoint 0.5, 0.5 in createDragGhost)
	State.dragGhost = createDragGhost(itemData)
	
	-- Position ghost CENTERED on mouse/touch using absolute location
	local scale = UI.uiScale.Scale
	local panelScale = UI.panelScale.Scale
	local mouseLoc = Services.UserInputService:GetMouseLocation()
	
	State.dragGhost.Position = UDim2.new(0, mouseLoc.X / scale, 0, mouseLoc.Y / scale)
	State.dragGhost.GhostScale.Scale = panelScale
	
	-- Hide original frame
	itemData.frame.Visible = false
	
	highlightOriginalSlot(State.originalSlot.row, State.originalSlot.col, State.originalSlot.width, State.originalSlot.height)
	removeItemFromGrid(itemId)
end

-- Start drag for a chest item
local function startChestDrag(chestItemData, itemFrame, inputPos)
	local tempItemData = {
		config = {
			id = chestItemData.id,
			name = chestItemData.name,
			icon = chestItemData.icon,
			weight = chestItemData.weight,
			price = chestItemData.price,
			rarity = chestItemData.rarity,
		},
		row = chestItemData.row,
		col = chestItemData.col,
		width = chestItemData.width,
		height = chestItemData.height,
		frame = itemFrame,
	}
	
	if UI.contentScroll and (State.activeTouchId or Services.UserInputService:GetLastInputType() == Enum.UserInputType.Touch) then
		UI.contentScroll.ScrollingEnabled = false
	end
	
	State.isDragging = true
	State.draggedItem = tempItemData
	State.dragSource = "chest"
	State.dragSourceChestData = chestItemData
	State.originalSlot = { row = chestItemData.row, col = chestItemData.col, width = chestItemData.width, height = chestItemData.height }
	
	State.dragGhost = createDragGhost(tempItemData)
	
	local scale = UI.uiScale.Scale
	local panelScale = UI.panelScale.Scale
	local mouseLoc = Services.UserInputService:GetMouseLocation()
	
	State.dragGhost.Position = UDim2.new(0, mouseLoc.X / scale, 0, mouseLoc.Y / scale)
	State.dragGhost.GhostScale.Scale = panelScale
	
	itemFrame.Visible = false
	highlightChestOriginalSlot(chestItemData.row, chestItemData.col, chestItemData.width, chestItemData.height)
	removeItemFromChestGrid(chestItemData.id)
end

local function startStorageDrag(storageItemData, itemFrame, inputPos)
	local tempItemData = {
		config = {
			id = storageItemData.id,
			name = storageItemData.name,
			icon = storageItemData.icon,
			weight = storageItemData.weight,
			price = storageItemData.price,
			rarity = storageItemData.rarity,
		},
		row = storageItemData.row,
		col = storageItemData.col,
		width = storageItemData.width,
		height = storageItemData.height,
		frame = itemFrame,
	}
	
	if UI.contentScroll and (State.activeTouchId or Services.UserInputService:GetLastInputType() == Enum.UserInputType.Touch) then
		UI.contentScroll.ScrollingEnabled = false
	end
	
	State.isDragging = true
	State.draggedItem = tempItemData
	State.dragSource = "storage"
	State.dragSourceChestData = nil -- Not chest
	State.originalSlot = { row = storageItemData.row, col = storageItemData.col, width = storageItemData.width, height = storageItemData.height }
	
	State.dragGhost = createDragGhost(tempItemData)
	
	local scale = UI.uiScale.Scale
	local panelScale = UI.panelScale.Scale
	local mouseLoc = Services.UserInputService:GetMouseLocation()
	
	State.dragGhost.Position = UDim2.new(0, mouseLoc.X / scale, 0, mouseLoc.Y / scale)
	State.dragGhost.GhostScale.Scale = panelScale
	
	itemFrame.Visible = false
	highlightStorageOriginalSlot(storageItemData.row, storageItemData.col, storageItemData.width, storageItemData.height)
	removeItemFromStorageGrid(storageItemData.id)
end

local function updateDrag()
	if not State.isDragging or not State.dragGhost then return end
	
	-- Use absolute mouse location for accuracy with IgnoreGuiInset
	local mousePos = Services.UserInputService:GetMouseLocation()
	local scale = UI.uiScale.Scale
	
	-- Position ghost CENTERED on cursor (Absolute scale)
	State.dragGhost.Position = UDim2.new(0, mousePos.X / scale, 0, mousePos.Y / scale)
	
	-- =====================================================
	-- AUTO-SCROLL DURING DRAG
	-- =====================================================
	local scrollAbsPos = UI.contentScroll.AbsolutePosition
	local scrollAbsSize = UI.contentScroll.AbsoluteSize
	local scrollTop = scrollAbsPos.Y
	local scrollBottom = scrollAbsPos.Y + scrollAbsSize.Y
	
	local dragY = mousePos.Y
	
	-- Calculate intensity and direction for auto-scroll
	local topEdge = scrollTop + Config.DRAG_SCROLL_EDGE_TOP
	local bottomEdge = scrollBottom - Config.DRAG_SCROLL_EDGE_BOTTOM
	
	if dragY < topEdge and dragY > (scrollTop - 50) then
		local intensity = math.clamp(1 - ((dragY - scrollTop) / Config.DRAG_SCROLL_EDGE_TOP), 0, 1)
		local scrollAmount = Config.DRAG_SCROLL_SPEED * intensity
		local newY = math.max(0, UI.contentScroll.CanvasPosition.Y - scrollAmount)
		UI.contentScroll.CanvasPosition = Vector2.new(UI.contentScroll.CanvasPosition.X, newY)
		State.isAutoScrolling = true
	elseif dragY > bottomEdge and dragY < (scrollBottom + 50) then
		local intensity = math.clamp((dragY - bottomEdge) / Config.DRAG_SCROLL_EDGE_BOTTOM, 0, 1)
		local scrollAmount = Config.DRAG_SCROLL_SPEED * intensity
		local maxY = math.max(0, UI.contentScroll.CanvasSize.Y.Offset - scrollAbsSize.Y)
		local newY = math.min(maxY, UI.contentScroll.CanvasPosition.Y + scrollAmount)
		UI.contentScroll.CanvasPosition = Vector2.new(UI.contentScroll.CanvasPosition.X, newY)
		State.isAutoScrolling = true
	else
		State.isAutoScrolling = false
	end
	
	State.lastDragPosition = mousePos
	
	-- Grid Logic: Use ghost's AbsolutePosition (Top-Left corner)
	local ghostAbsPos = State.dragGhost.AbsolutePosition
	local width = State.draggedItem.width
	local height = State.draggedItem.height
	local itemId = State.draggedItem.config.id
	
	local containerPos = UI.gridContainer.AbsolutePosition
	local containerSize = UI.gridContainer.AbsoluteSize
	local scaledCellSize = (Config.CELL_SIZE + Config.CELL_PADDING) * scale
	
	local relX = ghostAbsPos.X - containerPos.X
	local relY = ghostAbsPos.Y - containerPos.Y
	local col = math.floor(relX / scaledCellSize + 0.5) + 1
	local row = math.floor(relY / scaledCellSize + 0.5) + 1
	
	local isOverInventory = ghostAbsPos.X >= containerPos.X and ghostAbsPos.X <= (containerPos.X + containerSize.X)
		and ghostAbsPos.Y >= containerPos.Y and ghostAbsPos.Y <= (containerPos.Y + containerSize.Y)
	
	local isOverChest = false
	local chestRow, chestCol = 1, 1
	if UI.ChestContainer.Visible and UI.gridContainerChest then
		local chestContainerPos = UI.gridContainerChest.AbsolutePosition
		local chestContainerSize = UI.gridContainerChest.AbsoluteSize
		-- Use dynamic cell size (same as used in recreateChestGrid)
		local chestScaledCellSize = (Config.CHEST.CELL_SIZE + Config.CHEST.CELL_PADDING) * scale
		
		local chestRelX = ghostAbsPos.X - chestContainerPos.X
		local chestRelY = ghostAbsPos.Y - chestContainerPos.Y
		chestCol = math.floor(chestRelX / chestScaledCellSize + 0.5) + 1
		chestRow = math.floor(chestRelY / chestScaledCellSize + 0.5) + 1
		
		isOverChest = ghostAbsPos.X >= chestContainerPos.X and ghostAbsPos.X <= chestContainerPos.X + chestContainerSize.X
			and ghostAbsPos.Y >= chestContainerPos.Y and ghostAbsPos.Y <= chestContainerPos.Y + chestContainerSize.Y
	end
	
	-- Track which grid we're targeting
	State.dragTargetGrid = nil
	State.dragTargetRow = nil
	State.dragTargetCol = nil
	
	if isOverInventory then
		State.dragTargetGrid = "inventory"
		State.dragTargetRow = row
		State.dragTargetCol = col
		
		-- Clear chest/storage highlights when over inventory
		clearChestHighlights()
		clearStorageHighlights()
		
		-- Check if within inventory bounds
		local isOutsideGrid = row < 1 or col < 1 or row > Config.GRID_ROWS or col > Config.GRID_COLS
		if isOutsideGrid then
			clearHighlights()
			return
		end
		
		local canPlace = canPlaceItem(width, height, row, col, itemId)
		local finalWidth, finalHeight = width, height
		
		if not canPlace then
			canPlace = canPlaceItem(height, width, row, col, itemId)
			if canPlace then
				finalWidth, finalHeight = height, width
			end
		end
		
		if canPlace then
			highlightSlots(row, col, finalWidth, finalHeight, true)
		else
			clearHighlights()
		end
	elseif isOverChest then
		State.dragTargetGrid = "chest"
		State.dragTargetRow = chestRow
		State.dragTargetCol = chestCol
		
		clearHighlights()
		clearStorageHighlights()
		
		-- Use dynamic chest config for bounds checking
		local chestConf = State.currentChestConfig or { gridRows = 6, gridCols = 6 }
		local isOutsideChestGrid = chestRow < 1 or chestCol < 1 or chestRow > chestConf.gridRows or chestCol > chestConf.gridCols
		if isOutsideChestGrid then
			clearChestHighlights()
			return
		end
		
		local canPlace = canPlaceItemInChest(width, height, chestRow, chestCol, itemId)
		local finalWidth, finalHeight = width, height
		
		if not canPlace then
			canPlace = canPlaceItemInChest(height, width, chestRow, chestCol, itemId)
			if canPlace then
				finalWidth, finalHeight = height, width
			end
		end
		
		if canPlace then
			highlightChestSlots(chestRow, chestCol, finalWidth, finalHeight, true)
		else
			clearChestHighlights()
		end
	elseif State.isStorageOpen and UI.storageGridFrame then
		-- Check storage grid overlap
		local storageContainerPos = UI.storageGridFrame.AbsolutePosition
		local storageContainerSize = UI.storageGridFrame.AbsoluteSize
		local storageScaledCellSize = (Config.STORAGE.CELL_SIZE + Config.STORAGE.CELL_PADDING) * scale
		
		local storageRelX = ghostAbsPos.X - storageContainerPos.X
		local storageRelY = ghostAbsPos.Y - storageContainerPos.Y
		local storageCol = math.floor(storageRelX / storageScaledCellSize + 0.5) + 1
		local storageRow = math.floor(storageRelY / storageScaledCellSize + 0.5) + 1
		
		local isOverStorage = ghostAbsPos.X >= storageContainerPos.X and ghostAbsPos.X <= storageContainerPos.X + storageContainerSize.X
			and ghostAbsPos.Y >= storageContainerPos.Y and ghostAbsPos.Y <= storageContainerPos.Y + storageContainerSize.Y
			
		if isOverStorage then
			State.dragTargetGrid = "storage"
			State.dragTargetRow = storageRow
			State.dragTargetCol = storageCol
			
			clearHighlights()
			clearChestHighlights()
			
			local isOutsideStorageGrid = storageRow < 1 or storageCol < 1 or storageRow > Config.STORAGE.GRID_ROWS or storageCol > Config.STORAGE.GRID_COLS
			if isOutsideStorageGrid then
				clearStorageHighlights()
				return
			end
			
			local canPlace = canPlaceItemInStorage(width, height, storageRow, storageCol, itemId)
			local finalWidth, finalHeight = width, height
			
			if not canPlace then
				canPlace = canPlaceItemInStorage(height, width, storageRow, storageCol, itemId)
				if canPlace then
					finalWidth, finalHeight = height, width
				end
			end
			
			if canPlace then
				highlightStorageSlots(storageRow, storageCol, finalWidth, finalHeight, true)
			else
				clearStorageHighlights()
			end
		else
			clearHighlights()
			clearChestHighlights()
			clearStorageHighlights()
		end
	else
		clearHighlights()
		clearChestHighlights()
		clearStorageHighlights()
	end
end

-- Continuous auto-scroll while dragging (runs every frame)
Services.RunService.Heartbeat:Connect(function()
	if State.isDragging and State.isAutoScrolling and State.autoScrollDirection ~= 0 then
		local scrollAbsSize = UI.contentScroll.AbsoluteSize
		local scrollAmount = Config.DRAG_SCROLL_SPEED * State.autoScrollIntensity
		
		if State.autoScrollDirection == -1 then
			-- Scroll UP continuously
			local newY = math.max(0, UI.contentScroll.CanvasPosition.Y - scrollAmount)
			UI.contentScroll.CanvasPosition = Vector2.new(UI.contentScroll.CanvasPosition.X, newY)
		elseif State.autoScrollDirection == 1 then
			-- Scroll DOWN continuously
			local maxY = math.max(0, UI.contentScroll.CanvasSize.Y.Offset - scrollAbsSize.Y)
			local newY = math.min(maxY, UI.contentScroll.CanvasPosition.Y + scrollAmount)
			UI.contentScroll.CanvasPosition = Vector2.new(UI.contentScroll.CanvasPosition.X, newY)
		end
	end
end)

local function endDrag(inputPos)
	if not State.isDragging or not State.draggedItem or not State.dragGhost then return end
	
	-- Re-enable scrolling after drag (Mobile improvement)
	if UI.contentScroll then
		UI.contentScroll.ScrollingEnabled = true
	end
	
	-- Reset auto-scroll state
	State.isAutoScrolling = false
	State.autoScrollDirection = 0
	State.autoScrollIntensity = 0
	State.lastDragPosition = nil
	
	local width = State.draggedItem.width
	local height = State.draggedItem.height
	local rotated = State.draggedItem.rotated or false
	
	-- Use the target grid tracked during updateDrag
	local targetGrid = State.dragTargetGrid
	local row = State.dragTargetRow or 1
	local col = State.dragTargetCol or 1
	
	local placed = false
	local newWidth, newHeight = width, height
	
	if targetGrid == "inventory" then
		-- Check if can place in inventory
		if canPlaceItem(width, height, row, col, State.draggedItem.config.id) then
			placed = true
			newWidth, newHeight = width, height
		elseif canPlaceItem(height, width, row, col, State.draggedItem.config.id) then
			placed = true
			newWidth, newHeight = height, width
			rotated = not rotated
		end
	elseif targetGrid == "chest" then
		-- Check if can place in chest
		if canPlaceItemInChest(width, height, row, col, State.draggedItem.config.id) then
			placed = true
			newWidth, newHeight = width, height
		elseif canPlaceItemInChest(height, width, row, col, State.draggedItem.config.id) then
			placed = true
			newWidth, newHeight = height, width
			rotated = not rotated
		end
	elseif targetGrid == "storage" then
		-- Check if can place in storage
		if canPlaceItemInStorage(width, height, row, col, State.draggedItem.config.id) then
			placed = true
			newWidth, newHeight = width, height
		elseif canPlaceItemInStorage(height, width, row, col, State.draggedItem.config.id) then
			placed = true
			newWidth, newHeight = height, width
			rotated = not rotated
		end
	end
	
	if placed then
		if targetGrid == "inventory" then
			if State.dragSource == "chest" then
				-- Chest to inventory - collect item at specific position
				local collectEvent = Services.ReplicatedStorage:FindFirstChild("Remotes") and Services.ReplicatedStorage.Remotes:FindFirstChild("CollectItemAtPosition")
				if collectEvent then
					local chestPos = State.currentChestModel and State.currentChestModel.PrimaryPart and State.currentChestModel.PrimaryPart.Position
					-- Pass: itemName, chestPos, targetRow, targetCol, rotated
					local wasRotated = (newWidth ~= State.dragSourceChestData.width)
					collectEvent:FireServer(State.dragSourceChestData.name, chestPos, row, col, wasRotated)
				end
				if State.draggedItem.frame then
					State.draggedItem.frame:Destroy()
				end
				if chestLootItems and State.dragSourceChestData then
					chestLootItems[State.dragSourceChestData.id] = nil
				end
				if Data.chestItems and State.dragSourceChestData then
					Data.chestItems[State.dragSourceChestData.id] = nil
				end
			elseif State.dragSource == "storage" then
				-- Storage to Inventory
				local moveEvent = Services.ReplicatedStorage:FindFirstChild("Remotes") and Services.ReplicatedStorage.Remotes:FindFirstChild("MoveToInventory")
				if moveEvent then
					moveEvent:FireServer(State.draggedItem.config.id, row, col)
				end
				
				-- Optimistic cleanup from Storage
				if State.draggedItem.frame then
					State.draggedItem.frame:Destroy()
				end
				if Data.storageItems and Data.storageItems[State.draggedItem.config.id] then
					Data.storageItems[State.draggedItem.config.id] = nil
					removeItemFromStorageGrid(State.draggedItem.config.id)
				end
			else
				-- Inventory to inventory drag
				placeItemInGrid(State.draggedItem.config.id, newWidth, newHeight, row, col)
				
				State.draggedItem.row = row
				State.draggedItem.col = col
				State.draggedItem.width = newWidth
				State.draggedItem.height = newHeight
				State.draggedItem.rotated = rotated
				
				State.draggedItem.frame.Size = UDim2.new(0, newWidth * Config.CELL_SIZE + (newWidth - 1) * Config.CELL_PADDING, 0, newHeight * Config.CELL_SIZE + (newHeight - 1) * Config.CELL_PADDING)
				State.draggedItem.frame.Position = UDim2.new(0, (col - 1) * (Config.CELL_SIZE + Config.CELL_PADDING), 0, (row - 1) * (Config.CELL_SIZE + Config.CELL_PADDING))
				State.draggedItem.frame.Visible = true
				
				if newWidth ~= State.originalSlot.width or newHeight ~= State.originalSlot.height then
					local stroke = State.draggedItem.frame:FindFirstChild("ItemStroke")
					if stroke then
						local originalColor = stroke.Color
						stroke.Color = Color3.fromRGB(255, 255, 100)
						Services.TweenService:Create(stroke, TweenInfo.new(0.3), { Color = originalColor }):Play()
					end
				end
			end
		elseif targetGrid == "chest" then
			-- Placing in chest (chest-to-chest reposition)
			if State.dragSource == "chest" then
				-- Update chest grid data
				placeItemInChestGrid(State.draggedItem.config.id, newWidth, newHeight, row, col)
				
				-- Update the chest item data
				State.dragSourceChestData.row = row
				State.dragSourceChestData.col = col
				State.dragSourceChestData.width = newWidth
				State.dragSourceChestData.height = newHeight
				
				-- Update visual
				State.draggedItem.frame.Size = UDim2.new(0, newWidth * Config.CHEST.CELL_SIZE + (newWidth - 1) * Config.CHEST.CELL_PADDING, 0, newHeight * Config.CHEST.CELL_SIZE + (newHeight - 1) * Config.CHEST.CELL_PADDING)
				State.draggedItem.frame.Position = UDim2.new(0, (col - 1) * (Config.CHEST.CELL_SIZE + Config.CHEST.CELL_PADDING), 0, (row - 1) * (Config.CHEST.CELL_SIZE + Config.CHEST.CELL_PADDING))
				State.draggedItem.frame.Visible = true
				
				-- Sync position to server
				local updateEvent = Services.ReplicatedStorage:FindFirstChild("Remotes") and Services.ReplicatedStorage.Remotes:FindFirstChild("UpdateChestItemPosition")
				if updateEvent and State.currentChestModel then
					updateEvent:FireServer(State.dragSourceChestData.id, State.currentChestModel, row, col, newWidth, newHeight)
				end
				
				-- Flash animation if rotated
				if newWidth ~= State.originalSlot.width or newHeight ~= State.originalSlot.height then
					local stroke = State.draggedItem.frame:FindFirstChild("ItemStroke")
					if stroke then
						local originalColor = stroke.Color
						stroke.Color = Color3.fromRGB(255, 255, 100)
						Services.TweenService:Create(stroke, TweenInfo.new(0.3), { Color = originalColor }):Play()
					end
				end
			elseif State.dragSource == "storage" then
				-- Storage to Chest - deposit item
				local depositEvent = Services.ReplicatedStorage:FindFirstChild("Remotes") and Services.ReplicatedStorage.Remotes:FindFirstChild("DepositItemToChest")
				if depositEvent and State.currentChestModel then
					local uniqueItemId = State.draggedItem.config.id
					depositEvent:FireServer(uniqueItemId, State.currentChestModel, row, col, width, height)
				end
				
				-- Remove from local STORAGE data
				if State.draggedItem.frame then
					State.draggedItem.frame:Destroy()
				end
				if Data.storageItems and Data.storageItems[State.draggedItem.config.id] then
					Data.storageItems[State.draggedItem.config.id] = nil
					removeItemFromStorageGrid(State.draggedItem.config.id)
				end
			else
				-- Inventory to chest - deposit item
				-- Fire event to tell server to move this item to chest
				-- Send unique instanceId (config.id) which matches server's item.id
				local depositEvent = Services.ReplicatedStorage:FindFirstChild("Remotes") and Services.ReplicatedStorage.Remotes:FindFirstChild("DepositItemToChest")
				if depositEvent and State.currentChestModel then
					-- Use unique instanceId for exact matching (e.g., "Bandage_12345678_1")
					local uniqueItemId = State.draggedItem.config.id
					-- Pass current width/height to fix auto-rotate bug
					-- Pass chestModel INSTANCE to resolve ambiguity
					depositEvent:FireServer(uniqueItemId, State.currentChestModel, row, col, width, height)
				end
				-- Server will sync both inventory and chest back, so just destroy frame for now
				if State.draggedItem.frame then
					State.draggedItem.frame:Destroy()
				end
				-- Remove from local inventory data  
				if Data.inventoryItems then
					Data.inventoryItems[State.draggedItem.config.id] = nil
					removeItemFromGrid(State.draggedItem.config.id)
				end
			end
		elseif targetGrid == "storage" then
			if State.dragSource == "storage" then
				-- Storage to Storage (Move within storage)
				placeItemInStorageGrid(State.draggedItem.config.id, newWidth, newHeight, row, col)
				
				-- Update logical data
				if Data.storageItems[State.draggedItem.config.id] then
					Data.storageItems[State.draggedItem.config.id].row = row
					Data.storageItems[State.draggedItem.config.id].col = col
					Data.storageItems[State.draggedItem.config.id].width = newWidth
					Data.storageItems[State.draggedItem.config.id].height = newHeight
				end
				
				-- Update visual
				State.draggedItem.frame.Size = UDim2.new(0, newWidth * Config.STORAGE.CELL_SIZE + (newWidth - 1) * Config.STORAGE.CELL_PADDING, 0, newHeight * Config.STORAGE.CELL_SIZE + (newHeight - 1) * Config.STORAGE.CELL_PADDING)
				State.draggedItem.frame.Position = UDim2.new(0, (col - 1) * (Config.STORAGE.CELL_SIZE + Config.STORAGE.CELL_PADDING), 0, (row - 1) * (Config.STORAGE.CELL_SIZE + Config.STORAGE.CELL_PADDING))
				State.draggedItem.frame.Visible = true
				
				-- Fire server event update storage position (TODO: implement UpdateStoragePosition if needed, for now move works implicitly)
				-- Actually better to fire MoveToStorage logic with updated coordinates if we treat it as re-move? No, we need UpdateStorageItemPosition.
				-- For now, let's just assume MoveToStorage handles updates or add UpdateStorageItemPosition later.
				-- Wait, Implementation Plan says "Update MoveToStorage to accept targetRow/Col". So we use that.
				
				if Events.MoveToStorage then
					Events.MoveToStorage:FireServer(State.draggedItem.config.id, row, col)
				end
				
			else
				-- Inventory to Storage
				if Events.MoveToStorage then
					Events.MoveToStorage:FireServer(State.draggedItem.config.id, row, col)
				end
				
				if State.draggedItem.frame then
					State.draggedItem.frame:Destroy()
				end
				if Data.inventoryItems then
					Data.inventoryItems[State.draggedItem.config.id] = nil
					removeItemFromGrid(State.draggedItem.config.id)
				end
			end
		end
	else
		-- Return to original position
		if State.dragSource == "chest" then
			-- Place back in chest grid
			placeItemInChestGrid(State.draggedItem.config.id, State.originalSlot.width, State.originalSlot.height, State.originalSlot.row, State.originalSlot.col)
			if State.draggedItem.frame then
				State.draggedItem.frame.Visible = true
			end
		elseif State.dragSource == "storage" then
			-- Place back in storage grid
			placeItemInStorageGrid(State.draggedItem.config.id, State.originalSlot.width, State.originalSlot.height, State.originalSlot.row, State.originalSlot.col)
			if State.draggedItem.frame then
				State.draggedItem.frame.Visible = true
			end
		else
			-- Return inventory item to original
			placeItemInGrid(State.draggedItem.config.id, State.originalSlot.width, State.originalSlot.height, State.originalSlot.row, State.originalSlot.col)
			State.draggedItem.row = State.originalSlot.row
			State.draggedItem.col = State.originalSlot.col
			State.draggedItem.width = State.originalSlot.width
			State.draggedItem.height = State.originalSlot.height
			State.draggedItem.frame.Visible = true
		end
	end
	
	-- Cleanup
	if State.dragGhost then
		State.dragGhost:Destroy()
		State.dragGhost = nil
	end
	
	clearHighlights()
	clearChestHighlights()
	clearStorageHighlights()
	
	if State.dragSource == "inventory" then
		resetOriginalSlotHighlight(State.originalSlot.row, State.originalSlot.col, State.originalSlot.width, State.originalSlot.height)
	elseif State.dragSource == "chest" then
		resetChestOriginalSlotHighlight()
	elseif State.dragSource == "storage" then
		resetStorageOriginalSlotHighlight()
	end
	
	State.isDragging = false
	State.draggedItem = nil
	State.dragSource = nil
	State.dragSourceChestData = nil
	State.dragTargetGrid = nil
	State.dragTargetRow = nil
	State.dragTargetCol = nil
end

-- ============================================================================
-- INPUT HANDLING
-- ============================================================================

State.activeTouchId = nil  -- Track active touch to prevent multiple drags
State.tapStartTime = 0
State.tapStartPos = Vector2.new(0, 0)
Config.TAP_THRESHOLD_TIME = 0.2  -- seconds
Config.TAP_THRESHOLD_DISTANCE = 10  -- pixels

local function setupItemInput(itemFrame, itemId)
	local dragStarted = false
	local isMouseDown = false  -- Track if mouse/touch is currently pressed
	local longPressThread = nil  -- For long-press detection
	local lastTapTime = 0  -- For double-tap detection (deposit to chest)

	
	-- Handle input began on item frame
	itemFrame.InputBegan:Connect(function(input, gameProcessed)
		-- Prevent if already dragging
		if State.isDragging then return end
		
	if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			local currentItemData = Data.inventoryItems[itemId]
			
			-- Record tap start
			isMouseDown = true  -- Mark as pressed
			State.tapStartTime = tick()
			State.tapStartPos = Vector2.new(input.Position.X, input.Position.Y)
			dragStarted = false
			
			-- Start long-press timer for info popup
			if currentItemData then
				longPressThread = task.spawn(function()
					task.wait(Config.LONG_PRESS_DURATION)
					-- Only show if still pressed and not dragging
					if isMouseDown and not dragStarted and not State.isDragging then
						showItemInfoPopup(currentItemData)
					end
				end)
			end
			
			if input.UserInputType == Enum.UserInputType.Touch then
				State.activeTouchId = input
			end
		end
	end)
	
	itemFrame.InputChanged:Connect(function(input, gameProcessed)
		if State.isDragging then return end
		if not isMouseDown then return end  -- Only process if mouse/touch is held
		
		if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
			local currentPos = Vector2.new(input.Position.X, input.Position.Y)
			local distance = (currentPos - State.tapStartPos).Magnitude
			
			-- If moved beyond threshold, start drag (cancel long-press)
			if not dragStarted and distance > Config.TAP_THRESHOLD_DISTANCE then
				dragStarted = true
				-- Cancel long-press if dragging
				if longPressThread then
					task.cancel(longPressThread)
					longPressThread = nil
				end
				closeItemInfoPopup()  -- Close any popup
				clearSelection()  -- Clear selection when starting drag
				startDrag(itemId, currentPos)
			end
		end
	end)
	
	itemFrame.InputEnded:Connect(function(input, gameProcessed)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			-- Only process if we started on this item (isMouseDown)
			if not isMouseDown then return end
			
			local elapsed = tick() - State.tapStartTime
			local currentPos = Vector2.new(input.Position.X, input.Position.Y)
			local distance = (currentPos - State.tapStartPos).Magnitude
			
		-- If short tap without much movement and not currently dragging
			-- Increased thresholds for easier unselect
			local now = tick()
			
			-- CRITICAL: Cancel long-press timer BEFORE checking for double-tap
			-- This prevents popup from showing during double-tap
			if longPressThread then
				task.cancel(longPressThread)
				longPressThread = nil
			end
			
			if elapsed < 0.5 and distance < 20 and not State.isDragging and not dragStarted then
				local itemData = Data.inventoryItems[itemId]
				if itemData then
					-- Check for DOUBLE TAP (quick deposit to chest)
					if now - lastTapTime < 0.3 and UI.ChestContainer.Visible and State.currentChestModel then
						-- DOUBLE TAP: Deposit to chest - find first available slot
						local deposited = false
						for r = 1, Config.CHEST.GRID_ROWS do
							for c = 1, Config.CHEST.GRID_COLS do
								if canPlaceItemInChest(itemData.width, itemData.height, r, c, nil) then
									-- Found a slot - deposit item
									local depositEvent = Services.ReplicatedStorage:FindFirstChild("Remotes") and Services.ReplicatedStorage.Remotes:FindFirstChild("DepositItemToChest")
									if depositEvent then
										-- Pass chestModel INSTANCE
										depositEvent:FireServer(itemData.config.id, State.currentChestModel, r, c, itemData.width, itemData.height)
									end
									deposited = true
									-- Remove from local data
									removeItemFromGrid(itemData.config.id)
									Data.inventoryItems[itemData.config.id] = nil
									if itemData.frame then
										itemData.frame:Destroy()
									end
									deposited = true
									break
								end
							end
							if deposited then break end
						end
						if not deposited then
							-- Flash red if failed
							-- local stroke = itemFrame:FindFirstChild("ItemStroke") ...
						end
					elseif now - lastTapTime < 0.3 and State.isStorageOpen then
						-- DOUBLE TAP: Move to storage
						if Events.MoveToStorage then
							Events.MoveToStorage:FireServer(itemId, nil, nil) -- Let server find first empty slot
						end
						
						-- Optimistic update: Remove from local inventory
						-- CRITICAL: Use current frame from Data.inventoryItems, not closure parameter
						local currentItemData = Data.inventoryItems[itemId]
						if currentItemData and currentItemData.frame then
							currentItemData.frame:Destroy()
						end
						removeItemFromGrid(itemId)
						Data.inventoryItems[itemId] = nil
						
						closeItemInfoPopup()
						clearSelection()
						
						lastTapTime = 0
						return
						-- End of storage move
					else
						-- SINGLE TAP: Toggle selection
						if State.selectedItem and State.selectedItem.config.id == itemData.config.id then
							-- Deselect if clicking same item
							clearSelection()
						else
							-- Select this item
							selectItem(itemData)
						end
						lastTapTime = now
					end
				end
			end

			
			dragStarted = false
			isMouseDown = false  -- Reset mouse/touch state
			
			-- Cancel long-press thread and close popup when releasing
			if longPressThread then
				task.cancel(longPressThread)
				longPressThread = nil
			end
			closeItemInfoPopup()  -- Auto-close popup on release
		end
	end)
end

-- Setup grid slot click for moving selected item (inventory-to-inventory or chest-to-inventory)
local function setupGridSlotInput(slot, row, col)
	slot.InputBegan:Connect(function(input, gameProcessed)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			-- If item is selected, try to move it here
			if State.selectedItem and not State.isDragging then
				-- Check if this cell is empty (not occupied by another item)
				local cellOccupant = Data.gridData[row] and Data.gridData[row][col]
				
				if State.selectedItem.isChestItem then
					-- CHEST TO INVENTORY: Use smart placement
					local itemWidth = State.selectedItem.width or 1
					local itemHeight = State.selectedItem.height or 1
					
					-- Create temp item data for findBestPlacement
					local tempItemData = {
						width = itemWidth,
						height = itemHeight,
						config = State.selectedItem.config
					}
					
					-- Find best placement (with rotation and nearby search)
					local newRow, newCol, newWidth, newHeight, rotated = findBestPlacement(tempItemData, row, col)
					
					if newRow then
						-- Collect item from chest to specific inventory position
						local collectEvent = Services.ReplicatedStorage:FindFirstChild("Remotes") and Services.ReplicatedStorage.Remotes:FindFirstChild("CollectItemAtPosition")
						if collectEvent and State.currentChestModel then
							local chestPos = State.currentChestModel.PrimaryPart and State.currentChestModel.PrimaryPart.Position
							collectEvent:FireServer(State.selectedItem.config.name, chestPos, newRow, newCol, rotated)
						end
						
						-- Remove from chest grid data
						removeItemFromChestGrid(State.selectedItem.config.id)
						Data.chestItems[State.selectedItem.config.id] = nil
						if State.selectedItem.frame then
							State.selectedItem.frame:Destroy()
						end
						
						-- Clear selection
						clearSelection()
					else
						-- Flash red on failure
						local originalColor = slot.BackgroundColor3
						slot.BackgroundColor3 = Color3.fromRGB(100, 40, 40)
						Services.TweenService:Create(slot, TweenInfo.new(0.3), { BackgroundColor3 = originalColor }):Play()
					end

				elseif State.selectedItem.isStorageItem then
					-- STORAGE TO INVENTORY: Use smart placement
					local itemWidth = State.selectedItem.width or 1
					local itemHeight = State.selectedItem.height or 1
					
					-- Create temp item data for findBestPlacement
					local tempItemData = {
						width = itemWidth,
						height = itemHeight,
						config = State.selectedItem.config
					}
					
					-- Find best placement (with rotation and nearby search)
					local newRow, newCol, newWidth, newHeight, rotated = findBestPlacement(tempItemData, row, col)
					
					if newRow then
						-- Move item from storage to specific inventory position
						if Events.MoveToInventory then
							Events.MoveToInventory:FireServer(State.selectedItem.config.id, newRow, newCol, rotated)
						end
						
						-- Optimistic update: Remove from storage
						local currentItemData = Data.storageItems[State.selectedItem.config.id]
						if currentItemData and currentItemData.frame then
							currentItemData.frame:Destroy()
						end
						removeItemFromStorageGrid(State.selectedItem.config.id)
						Data.storageItems[State.selectedItem.config.id] = nil
						
						-- Clear selection
						clearSelection()
					else
						-- Flash red on failure
						local originalColor = slot.BackgroundColor3
						slot.BackgroundColor3 = Color3.fromRGB(100, 40, 40)
						Services.TweenService:Create(slot, TweenInfo.new(0.3), { BackgroundColor3 = originalColor }):Play()
					end

				else
					-- INVENTORY TO INVENTORY: Original move logic
					if cellOccupant == nil or cellOccupant == State.selectedItem.config.id then
						local success = moveSelectedItemTo(row, col)
						if not success then
							-- Flash red on failure
							local originalColor = slot.BackgroundColor3
							slot.BackgroundColor3 = Color3.fromRGB(100, 40, 40)
							Services.TweenService:Create(slot, TweenInfo.new(0.3), { BackgroundColor3 = originalColor }):Play()
						end
					end
				end
			end
		end
	end)
end


-- Setup chest grid slot click for moving items (inventory-to-chest or chest-to-chest)
-- Uses SMART PLACEMENT with rotation and nearby search
setupChestSlotInput = function(slot, row, col)
	slot.InputBegan:Connect(function(input, gameProcessed)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			-- If item is selected and chest is visible
			if State.selectedItem and not State.isDragging and UI.ChestContainer.Visible and State.currentChestModel then
				local itemWidth = State.selectedItem.width or 1
				local itemHeight = State.selectedItem.height or 1
				
				if State.selectedItem.isChestItem then
					-- CHEST TO CHEST: Use smart placement
					-- Remove from old position first for placement check
					removeItemFromChestGrid(State.selectedItem.config.id)
					
					-- Find best placement (with rotation and nearby search)
					local newRow, newCol, newWidth, newHeight, rotated = findBestChestPlacement(itemWidth, itemHeight, row, col, State.selectedItem.config.id)
					
					if newRow then
						-- Place in new position
						placeItemInChestGrid(State.selectedItem.config.id, newWidth, newHeight, newRow, newCol)
						
						-- Update visual position and size (if rotated)
						if State.selectedItem.frame then
							State.selectedItem.frame.Size = UDim2.new(0, newWidth * Config.CHEST.CELL_SIZE + (newWidth - 1) * Config.CHEST.CELL_PADDING, 0, newHeight * Config.CHEST.CELL_SIZE + (newHeight - 1) * Config.CHEST.CELL_PADDING)
							State.selectedItem.frame.Position = UDim2.new(0, (newCol - 1) * (Config.CHEST.CELL_SIZE + Config.CHEST.CELL_PADDING), 0, (newRow - 1) * (Config.CHEST.CELL_SIZE + Config.CHEST.CELL_PADDING))
						end
						
						-- Update data
						State.selectedItem.row = newRow
						State.selectedItem.col = newCol
						State.selectedItem.width = newWidth
						State.selectedItem.height = newHeight
						if Data.chestItems[State.selectedItem.config.id] then
							Data.chestItems[State.selectedItem.config.id].row = newRow
							Data.chestItems[State.selectedItem.config.id].col = newCol
							Data.chestItems[State.selectedItem.config.id].width = newWidth
							Data.chestItems[State.selectedItem.config.id].height = newHeight
						end
						
						-- Sync to server
						local updateEvent = Services.ReplicatedStorage:FindFirstChild("Remotes") and Services.ReplicatedStorage.Remotes:FindFirstChild("UpdateChestItemPosition")
						if updateEvent then
							updateEvent:FireServer(State.selectedItem.config.id, State.currentChestModel, newRow, newCol, newWidth, newHeight)
						end
						
						-- Clear selection
						clearSelection()
					else
						-- Restore original position if no valid placement found
						placeItemInChestGrid(State.selectedItem.config.id, itemWidth, itemHeight, State.selectedItem.row, State.selectedItem.col)
						-- Flash red on failure
						local originalColor = slot.BackgroundColor3
						slot.BackgroundColor3 = Color3.fromRGB(100, 40, 40)
						Services.TweenService:Create(slot, TweenInfo.new(0.3), { BackgroundColor3 = originalColor }):Play()
					end
				else
					-- INVENTORY TO CHEST: Use smart placement
					local newRow, newCol, newWidth, newHeight, rotated = findBestChestPlacement(itemWidth, itemHeight, row, col, nil)
					
					if newRow then
						-- Mark that this is a deposit update, not first chest open
						State.isFirstChestSync = false
						
						-- Deposit item to chest
						local depositEvent = Services.ReplicatedStorage:FindFirstChild("Remotes") and Services.ReplicatedStorage.Remotes:FindFirstChild("DepositItemToChest")
						if depositEvent then
							depositEvent:FireServer(State.selectedItem.config.id, State.currentChestModel, newRow, newCol, newWidth, newHeight)
						end
						
						-- Remove from local inventory data
						removeItemFromGrid(State.selectedItem.config.id)
						Data.inventoryItems[State.selectedItem.config.id] = nil
						if State.selectedItem.frame then
							State.selectedItem.frame:Destroy()
						end
						
						-- Clear selection
						clearSelection()
					else
						-- Flash red on failure (can't place due to size)
						local originalColor = slot.BackgroundColor3
						slot.BackgroundColor3 = Color3.fromRGB(100, 40, 40)
						Services.TweenService:Create(slot, TweenInfo.new(0.3), { BackgroundColor3 = originalColor }):Play()
					end
				end
			end
		end
	end)
end





-- NOTE: Chest grid input handlers are now set up dynamically in recreateChestGrid()
-- when a chest is opened, based on the chest's configuration


-- Connect input handlers to all inventory grid slots (enables tap-to-move)
for row = 1, Config.GRID_ROWS do
	for col = 1, Config.GRID_COLS do
		local slot = Data.gridSlots[row] and Data.gridSlots[row][col]
		if slot then
			setupGridSlotInput(slot, row, col)
		end
	end
end


-- Global touch/mouse move handler

Services.UserInputService.InputChanged:Connect(function(input, gameProcessed)
	if not State.isDragging then return end
	
	if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
		if input.UserInputType == Enum.UserInputType.Touch then
			-- Only satisfy if tracking this touch
			if State.activeTouchId and input == State.activeTouchId then
				updateDrag()
			elseif State.activeTouchId == nil then
				updateDrag()
			end
		else
			updateDrag()
		end
	end
end)

-- Global touch/mouse end handler
Services.UserInputService.InputEnded:Connect(function(input, gameProcessed)
	-- Always close popup on mouse/touch release (even if not dragging)
	if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
		closeItemInfoPopup()  -- Cleanup popup on any release
	end
	
	if not State.isDragging then return end
	
	if input.UserInputType == Enum.UserInputType.MouseButton1 then
		endDrag(Vector2.new(input.Position.X, input.Position.Y))
		State.activeTouchId = nil
	elseif input.UserInputType == Enum.UserInputType.Touch then
		-- Only end drag if this is the active touch
		if State.activeTouchId == nil or input == State.activeTouchId then
			endDrag(Vector2.new(input.Position.X, input.Position.Y))
			State.activeTouchId = nil
		end
	end
end)

-- ============================================================================
-- STATS UPDATE
-- ============================================================================

local function updateStatsUI()
	local totalWeight = 0
	local totalValue = 0
	
	for _, itemData in pairs(Data.inventoryItems) do
		if itemData.config then
			totalWeight = totalWeight + (itemData.config.weight or 0)
			totalValue = totalValue + (itemData.config.price or 0)
		end
	end
	
	if UI.weightLabel then
		UI.weightLabel.Text = string.format("%.1f/65.0 kg", totalWeight)
		-- Change color based on weight
		if totalWeight > 55 then
			UI.weightLabel.TextColor3 = Color3.fromRGB(255, 100, 100)
		elseif totalWeight > 40 then
			UI.weightLabel.TextColor3 = Color3.fromRGB(255, 200, 100)
		else
			UI.weightLabel.TextColor3 = Color3.fromRGB(200, 200, 220)
		end
	end
	
	if UI.equipmentValueLabel then
		UI.equipmentValueLabel.Text = "Equipment Value: " .. tostring(totalValue)
	end
end

-- ============================================================================
-- SERVER INVENTORY SYNC
-- ============================================================================

local function loadInventoryFromServer(inventoryData)
	-- Clear selection
	clearSelection()
	
	-- Clear existing items
	for id, itemData in pairs(Data.inventoryItems) do
		if itemData.frame then
			itemData.frame:Destroy()
		end
		removeItemFromGrid(id)
	end
	Data.inventoryItems = {}
	
	-- Setup grid slot inputs (for click-to-move)
	if Data.gridSlots then
		for row = 1, Config.GRID_ROWS do
			if Data.gridSlots[row] then
				for col = 1, Config.GRID_COLS do
					local slot = Data.gridSlots[row][col]
					if slot then
						setupGridSlotInput(slot, row, col)
					end
				end
			end
		end
	end
	
	-- Load items from server data
	if inventoryData and inventoryData.items then
		for i, itemInfo in ipairs(inventoryData.items) do
			-- Use itemId from server for config lookup, or fallback to name
			local itemType = itemInfo.itemId or itemInfo.name
			local baseConfig = ItemConfig[itemType] or ItemConfig.GetItem(itemType)
			
			-- Merge base config with server-provided unique data
			local config = {
				id = itemInfo.id,  -- Use unique instance ID directly from server (e.g. "Bandage_12345678_1")
				itemId = itemType,  -- Original item type ID for config lookups
				name = itemInfo.name,
				width = itemInfo.width or (baseConfig and baseConfig.width) or 1,
				height = itemInfo.height or (baseConfig and baseConfig.height) or 1,
				color = baseConfig and baseConfig.color or Color3.fromRGB(itemInfo.color and itemInfo.color[1] or 200, itemInfo.color and itemInfo.color[2] or 200, itemInfo.color and itemInfo.color[3] or 200),
				weight = itemInfo.weight or (baseConfig and baseConfig.weight) or 0.15,
				price = itemInfo.price or (baseConfig and baseConfig.price) or 50,
				icon = (baseConfig and baseConfig.icon) or itemInfo.icon or "",
				rarity = (baseConfig and baseConfig.rarity) or itemInfo.rarity or "Common",
				description = (baseConfig and baseConfig.description) or "A useful item.",
				-- Armor specific fields
				isArmor = baseConfig and baseConfig.isArmor or false,
				armorType = baseConfig and baseConfig.armorType,
				armorSet = baseConfig and baseConfig.armorSet,
				slotType = baseConfig and baseConfig.slotType,
				modelPath = baseConfig and baseConfig.modelPath,
			}
			
			if canPlaceItem(config.width, config.height, itemInfo.row, itemInfo.col, nil) then
				local frame = createItemFrame(config, config.width, config.height, itemInfo.row, itemInfo.col)
				
				local itemData = {
					config = config,
					row = itemInfo.row,
					col = itemInfo.col,
					width = config.width,
					height = config.height,
					rotated = itemInfo.rotated or false,
					frame = frame,
				}
				
				Data.inventoryItems[config.id] = itemData
				placeItemInGrid(config.id, config.width, config.height, itemInfo.row, itemInfo.col)
				setupItemInput(frame, config.id)
			else
				-- Debug: Item couldn't be placed - log why

				
				-- Try to place anyway since server validated the position
				-- The grid state might be out of sync
				local frame = createItemFrame(config, config.width, config.height, itemInfo.row, itemInfo.col)
				
				local itemData = {
					config = config,
					row = itemInfo.row,
					col = itemInfo.col,
					width = config.width,
					height = config.height,
					rotated = itemInfo.rotated or false,
					frame = frame,
				}
				
				Data.inventoryItems[config.id] = itemData
				placeItemInGrid(config.id, config.width, config.height, itemInfo.row, itemInfo.col)
				setupItemInput(frame, config.id)
			end
		end
	end
	
	-- Update weight and value display
	updateStatsUI()
end


-- ============================================================================
-- LOOT POPUP UI (Multi-Item Scrollable)
-- ============================================================================

State.lootPopup = nil
State.nearbyItems = {}  -- Track all items in range
State.lootHighlights = {}  -- Multiple highlights for multiple items
State.isCollecting = false
State.collectedItems = {}
local ITEM_ROW_HEIGHT = 50  -- Height of each item row in pixels
local MIN_VISIBLE_ITEMS = 2  -- Minimum items visible without scrolling

-- Helper function to check if an item can fit in inventory
local function canItemFitInInventory(itemInstance)
	local itemName = itemInstance.Name
	local itemIconConfig = ItemConfig[itemName] or ItemConfig.GetItem(itemName)
	local itemWidth = (itemIconConfig and itemIconConfig.width) or itemInstance:GetAttribute("Width") or 1
	local itemHeight = (itemIconConfig and itemIconConfig.height) or itemInstance:GetAttribute("Height") or 1
	
	-- Try normal orientation
	for row = 1, Config.GRID_ROWS do
		for col = 1, Config.GRID_COLS do
			if canPlaceItem(itemWidth, itemHeight, row, col, nil) then
				return true
			end
		end
	end
	
	-- Try rotated orientation
	if itemWidth ~= itemHeight then
		for row = 1, Config.GRID_ROWS do
			for col = 1, Config.GRID_COLS do
				if canPlaceItem(itemHeight, itemWidth, row, col, nil) then
					return true
				end
			end
		end
	end
	
	return false
end

local function getItemPosition(item)
	if item:IsA("Model") then
		if item.PrimaryPart then
			return item.PrimaryPart.Position
		end
		local part = item:FindFirstChildWhichIsA("BasePart", true)
		if part then
			return part.Position
		end
	elseif item:IsA("BasePart") then
		return item.Position
	end
	return nil
end

local function collectItem(itemInstance)
	if not itemInstance or State.isCollecting or State.collectedItems[itemInstance] then return end
	
	-- Check if item can fit in inventory BEFORE doing anything
	local canFit = canItemFitInInventory(itemInstance)
	if not canFit then
		-- Flash red to indicate backpack full - but don't collect
		return
	end
	
	State.isCollecting = true
	local itemToCollect = itemInstance.Name
	State.collectedItems[itemInstance] = true
	
	-- Remove highlight for this item
	if State.lootHighlights[itemInstance] then
		State.lootHighlights[itemInstance]:Destroy()
		State.lootHighlights[itemInstance] = nil
	end
	
	-- Remove from State.nearbyItems
	for i, item in ipairs(State.nearbyItems) do
		if item == itemInstance then
			table.remove(State.nearbyItems, i)
			break
		end
	end
	
	-- Play animation (only if item can fit)
	local character = player.Character
	if character then
		local humanoid = character:FindFirstChildOfClass("Humanoid")
		if humanoid then
			local animFolder = Services.ReplicatedStorage:FindFirstChild("Anim")
			if animFolder then
				local actionTrigger = animFolder:FindFirstChild("ActionTrigger")
				if actionTrigger then
					local animator = humanoid:FindFirstChildOfClass("Animator")
					if animator then
						local track = animator:LoadAnimation(actionTrigger)
						track.Looped = false
						track:Play()
					end
				end
			end
		end
	end
	
	-- Delay then fire server event
	task.delay(0.5, function()
		if Events.CollectItem then
			local itemPos = getItemPosition(itemInstance)
			Events.CollectItem:FireServer(itemToCollect, itemPos)
		end
		State.isCollecting = false
	end)
end

local function createLootPopup(items)
	-- Remove existing popup
	if State.lootPopup then
		State.lootPopup:Destroy()
		State.lootPopup = nil
	end
	
	if #items == 0 then return end
	
	local itemCount = #items
	local visibleItems = math.min(itemCount, MIN_VISIBLE_ITEMS)
	local popupHeight = 30 + (visibleItems * ITEM_ROW_HEIGHT)  -- TopBar + items
	
	-- Create popup frame (ZIndex 5, below UI.mainPanel's 10)
	State.lootPopup = Instance.new("Frame")
	State.lootPopup.Name = "LootPopup"
	State.lootPopup.Size = UDim2.new(0, 220, 0, popupHeight)
	State.lootPopup.Position = UDim2.new(0.5, 50, 0.5, 30)
	State.lootPopup.AnchorPoint = Vector2.new(0, 0)
	State.lootPopup.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	State.lootPopup.BorderSizePixel = 0
	State.lootPopup.ZIndex = 5  -- Below UI.mainPanel (10) so inventory is always on top
	State.lootPopup.Parent = UI.screenGui
	
	local popupStroke = Instance.new("UIStroke")
	popupStroke.Color = Color3.fromRGB(100, 80, 140)
	popupStroke.Thickness = 2
	popupStroke.Parent = State.lootPopup
	
	local popupCorner = Instance.new("UICorner")
	popupCorner.CornerRadius = UDim.new(0, 8)
	popupCorner.Parent = State.lootPopup
	
	-- TopBar with count
	local topBar = Instance.new("Frame")
	topBar.Name = "TopBar"
	topBar.Size = UDim2.new(1, 0, 0, 28)
	topBar.Position = UDim2.new(0, 0, 0, 0)
	topBar.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	topBar.BorderSizePixel = 0
	topBar.ZIndex = 6
	topBar.Parent = State.lootPopup
	
	local topBarCorner = Instance.new("UICorner")
	topBarCorner.CornerRadius = UDim.new(0, 8)
	topBarCorner.Parent = topBar
	
	local topBarLabel = Instance.new("TextLabel")
	topBarLabel.Size = UDim2.new(1, -10, 1, 0)
	topBarLabel.Position = UDim2.new(0, 10, 0, 0)
	topBarLabel.BackgroundTransparency = 1
	topBarLabel.Text = "Loot (" .. itemCount .. ")"
	topBarLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
	topBarLabel.TextXAlignment = Enum.TextXAlignment.Left
	topBarLabel.TextSize = 14
	topBarLabel.Font = Enum.Font.GothamBold
	topBarLabel.ZIndex = 7
	topBarLabel.Parent = topBar
	
	-- Scrollable item list
	local scrollFrame = Instance.new("ScrollingFrame")
	scrollFrame.Name = "ItemList"
	scrollFrame.Size = UDim2.new(1, -4, 1, -30)
	scrollFrame.Position = UDim2.new(0, 2, 0, 29)
	scrollFrame.BackgroundTransparency = 1
	scrollFrame.BorderSizePixel = 0
	scrollFrame.ScrollBarThickness = 6
	scrollFrame.ScrollBarImageColor3 = Color3.fromRGB(100, 100, 130)
	scrollFrame.CanvasSize = UDim2.new(0, 0, 0, itemCount * ITEM_ROW_HEIGHT)
	scrollFrame.ZIndex = 6
	scrollFrame.Parent = State.lootPopup
	
	local listLayout = Instance.new("UIListLayout")
	listLayout.SortOrder = Enum.SortOrder.LayoutOrder
	listLayout.Padding = UDim.new(0, 2)
	listLayout.Parent = scrollFrame
	
	-- Create item rows
	for i, item in ipairs(items) do
		local itemName = item.Name
		local itemWeight = item:GetAttribute("Weight") or 0.15
		local itemPrice = item:GetAttribute("Price") or 50
		
		local itemRow = Instance.new("TextButton")
		itemRow.Name = "ItemRow_" .. i
		itemRow.Size = UDim2.new(1, -8, 0, ITEM_ROW_HEIGHT - 4)
		itemRow.LayoutOrder = i
		itemRow.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
		itemRow.BorderSizePixel = 0
		itemRow.Text = ""
		itemRow.AutoButtonColor = true
		itemRow.ZIndex = 7
		itemRow.Parent = scrollFrame
		
		local rowCorner = Instance.new("UICorner")
		rowCorner.CornerRadius = UDim.new(0, 4)
		rowCorner.Parent = itemRow
		
		-- Icon frame
		local iconFrame = Instance.new("Frame")
		iconFrame.Size = UDim2.new(0, 38, 0, 38)
		iconFrame.Position = UDim2.new(0, 4, 0.5, -19)
		iconFrame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
		iconFrame.BorderSizePixel = 0
		iconFrame.ZIndex = 8
		iconFrame.Parent = itemRow
		
		local iconCorner = Instance.new("UICorner")
		iconCorner.CornerRadius = UDim.new(0, 4)
		iconCorner.Parent = iconFrame
		
		-- Get item icon from ItemConfig
		local itemIconConfig = ItemConfig[itemName] or ItemConfig.GetItem(itemName)
		if itemIconConfig and itemIconConfig.icon and itemIconConfig.icon ~= "" then
			local iconImage = Instance.new("ImageLabel")
			iconImage.Name = "Icon"
			iconImage.Size = UDim2.new(1, 0, 1, 0)
			iconImage.BackgroundTransparency = 1
			iconImage.Image = itemIconConfig.icon
			iconImage.ScaleType = Enum.ScaleType.Fit
			iconImage.ZIndex = 9
			iconImage.Parent = iconFrame
		end
		
		-- Name
		local nameLabel = Instance.new("TextLabel")
		nameLabel.Size = UDim2.new(1, -55, 0, 18)
		nameLabel.Position = UDim2.new(0, 48, 0, 4)
		nameLabel.BackgroundTransparency = 1
		nameLabel.Text = itemName .. " (" .. string.format("%.2f", itemWeight) .. " KG)"
		nameLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
		nameLabel.TextXAlignment = Enum.TextXAlignment.Left
		nameLabel.TextSize = 11
		nameLabel.Font = Enum.Font.GothamBold
		nameLabel.ZIndex = 8
		nameLabel.Parent = itemRow
		
		-- Price
		local priceLabel = Instance.new("TextLabel")
		priceLabel.Size = UDim2.new(1, -55, 0, 16)
		priceLabel.Position = UDim2.new(0, 48, 0, 24)
		priceLabel.BackgroundTransparency = 1
		priceLabel.Text = "Price: $" .. tostring(itemPrice)
		priceLabel.TextColor3 = Color3.fromRGB(180, 180, 140)
		priceLabel.TextXAlignment = Enum.TextXAlignment.Left
		priceLabel.TextSize = 10
		priceLabel.Font = Enum.Font.Gotham
		priceLabel.ZIndex = 8
		priceLabel.Parent = itemRow
		
		-- Backpack Full Overlay (red, visible when item can't fit)
		local fullOverlay = Instance.new("Frame")
		fullOverlay.Name = "BackpackFullOverlay"
		fullOverlay.Size = UDim2.new(1, 0, 1, 0)
		fullOverlay.Position = UDim2.new(0, 0, 0, 0)
		fullOverlay.BackgroundColor3 = Color3.fromRGB(100, 20, 20)  -- Dark red
		fullOverlay.BackgroundTransparency = 0.65
		fullOverlay.BorderSizePixel = 0
		fullOverlay.ZIndex = 10  -- Above all other elements
		fullOverlay.Parent = itemRow
		
		local overlayCorner = Instance.new("UICorner")
		overlayCorner.CornerRadius = UDim.new(0, 4)
		overlayCorner.Parent = fullOverlay
		
		-- Check if item can fit in backpack
		local itemWidth = item:GetAttribute("Width") or 1
		local itemHeight = item:GetAttribute("Height") or 1
		-- Also check from ItemConfig
		if itemIconConfig then
			itemWidth = itemIconConfig.width or itemWidth
			itemHeight = itemIconConfig.height or itemHeight
		end
		
		-- Try to find a spot for this item
		local canFit = false
		for row = 1, Config.GRID_ROWS do
			for col = 1, Config.GRID_COLS do
				if canPlaceItem(itemWidth, itemHeight, row, col, nil) then
					canFit = true
					break
				end
			end
			if canFit then break end
		end
		
		-- Show red overlay and disable button if can't fit
		fullOverlay.Visible = not canFit
		itemRow.Active = canFit  -- Disable button when backpack full
		itemRow.AutoButtonColor = canFit  -- Remove hover effect when disabled
		
		-- Click handler for this row (with guard check)
		itemRow.MouseButton1Click:Connect(function()
			-- Double-check if item can still fit (inventory may have changed)
			if not canItemFitInInventory(item) then
				return  -- Backpack full, do nothing
			end
			
			collectItem(item)
			-- Update popup after collection
			if #State.nearbyItems > 0 then
				createLootPopup(State.nearbyItems)
			else
				if State.lootPopup then
					State.lootPopup:Destroy()
					State.lootPopup = nil
				end
			end
		end)
	end
	
	return State.lootPopup
end

local function closeLootPopup()
	if State.lootPopup then
		State.lootPopup:Destroy()
		State.lootPopup = nil
	end
	-- Clear all highlights
	for item, highlight in pairs(State.lootHighlights) do
		if highlight then
			highlight:Destroy()
		end
	end
	State.lootHighlights = {}
	State.nearbyItems = {}
end

-- ============================================================================
-- PROXIMITY DETECTION LOOP (Multi-Item)
-- ============================================================================

Services.RunService.Heartbeat:Connect(function()
	local character = player.Character
	if not character then
		closeLootPopup()
		return
	end
	
	local hrp = character:FindFirstChild("HumanoidRootPart")
	if not hrp then
		closeLootPopup()
		return
	end
	
	local itemsFolder = workspace:FindFirstChild("Items")
	local lootsFolder = workspace:FindFirstChild("Loots")
	
	-- If neither folder exists, close popup
	if not itemsFolder and not lootsFolder then
		closeLootPopup()
		return
	end
	
	-- Find ALL items in range from both Items and Loots folders
	local currentNearbyItems = {}
	
	-- Helper function to check items in a folder
	local function scanFolderForItems(folder)
		if not folder then return end
		for _, item in ipairs(folder:GetChildren()) do
			-- Skip chest models (they have their own interaction system)
			-- Check if this model is a configured chest type
			if item:IsA("Model") then
				local isChest = ChestConfig and ChestConfig.GetChest(item.Name) ~= nil
				if isChest then
					continue
				end
			end
			
			if not State.collectedItems[item] then
				local itemPos = getItemPosition(item)
				if itemPos then
					local distance = (hrp.Position - itemPos).Magnitude
					if distance <= Config.DROPPED_ITEM_DISTANCE then
						table.insert(currentNearbyItems, item)
					end
				end
			end
		end
	end
	
	-- Scan both folders
	scanFolderForItems(itemsFolder)
	scanFolderForItems(lootsFolder)
	
	-- Sort by distance (closest first)
	table.sort(currentNearbyItems, function(a, b)
		local posA = getItemPosition(a)
		local posB = getItemPosition(b)
		if posA and posB then
			return (hrp.Position - posA).Magnitude < (hrp.Position - posB).Magnitude
		end
		return false
	end)
	
	-- Check if items changed
	local itemsChanged = #currentNearbyItems ~= #State.nearbyItems
	if not itemsChanged then
		for i, item in ipairs(currentNearbyItems) do
			if State.nearbyItems[i] ~= item then
				itemsChanged = true
				break
			end
		end
	end
	
	if itemsChanged and not State.isCollecting then
		State.nearbyItems = currentNearbyItems
		
		-- Clear old highlights
		for item, highlight in pairs(State.lootHighlights) do
			if highlight then
				highlight:Destroy()
			end
		end
		State.lootHighlights = {}
		
		if #State.nearbyItems > 0 then
			-- Add highlights to all nearby items
			for _, item in ipairs(State.nearbyItems) do
				local highlight = Instance.new("Highlight")
				highlight.Name = "LootHighlight"
				highlight.FillColor = Color3.fromRGB(100, 200, 100)
				highlight.FillTransparency = 0.7
				highlight.OutlineColor = Color3.fromRGB(150, 255, 150)
				highlight.OutlineTransparency = 0.3
				highlight.Parent = item
				State.lootHighlights[item] = highlight
			end
			
			createLootPopup(State.nearbyItems)
		else
			closeLootPopup()
		end
	elseif #currentNearbyItems == 0 and #State.nearbyItems > 0 then
		closeLootPopup()
	end
end)

-- ============================================================================
-- SERVER SYNC EVENT HANDLER
-- ============================================================================

if Events.SyncInventory then
	Events.SyncInventory.OnClientEvent:Connect(function(inventoryData)
		loadInventoryFromServer(inventoryData)
		
		-- Refresh loot popup to update backpack full overlay status
		if State.lootPopup and #State.nearbyItems > 0 then
			createLootPopup(State.nearbyItems)
		end
	end)
end

-- Handle inventory full notification
if Events.InventoryFull then
	Events.InventoryFull.OnClientEvent:Connect(function(itemName)
		-- Remove item from State.collectedItems so it can be picked up again later
		for item, _ in pairs(State.collectedItems) do
			if item.Name == itemName then
				State.collectedItems[item] = nil
				break
			end
		end
		
		-- Flash red on UI.mainPanel to indicate backpack is full
		local originalColor = UI.mainPanel.BackgroundColor3
		UI.mainPanel.BackgroundColor3 = Color3.fromRGB(100, 30, 30)
		task.delay(0.3, function()
			UI.mainPanel.BackgroundColor3 = originalColor
		end)
	end)
end

-- Handle armor sync from server
if Events.ArmorSync then
	Events.ArmorSync.OnClientEvent:Connect(function(armorData)
		-- Check if this is a checkResult response
		if armorData and armorData.checkResult ~= nil then
			-- Server responded to check_space action
			return
		end
		
		
		-- Update each armor slot based on server data
		local equippedArmor = armorData
		for slotName, slotData in pairs(Data.armorSlots) do
			local equippedItemId = equippedArmor and equippedArmor[slotName]
			
			if equippedItemId then
				-- Armor is equipped in this slot
				local armorConfig = ItemConfig[equippedItemId] or ItemConfig.GetItem(equippedItemId)
				if armorConfig then
					slotData.equippedIcon.Image = armorConfig.icon
					slotData.equippedIcon.Visible = true
					slotData.icon.Visible = false
					slotData.equipped = equippedItemId
					slotData.stroke.Color = Color3.fromRGB(100, 255, 100)
				end
			else
				-- No armor in this slot
				slotData.equippedIcon.Visible = false
				slotData.equippedIcon.Image = ""
				slotData.icon.Visible = true
				slotData.equipped = nil
				slotData.stroke.Color = Color3.fromRGB(80, 80, 120)
				slotData.stroke.Thickness = 1
			end
		end
	end)
end

-- ============================================================================
-- PANEL OPEN/CLOSE
-- ============================================================================

-- Helper function to play inventory animations
local function playInventoryAnimation(animName, looped)
	local character = player.Character
	if not character then return nil end
	
	local humanoid = character:FindFirstChildOfClass("Humanoid")
	if not humanoid then return nil end
	
	local animFolder = Services.ReplicatedStorage:FindFirstChild("Anim")
	if not animFolder then return nil end
	
	local animAsset = animFolder:FindFirstChild(animName)
	if not animAsset then return nil end
	
	-- Stop current animation if playing
	if State.currentInventoryAnimTrack and State.currentInventoryAnimTrack.IsPlaying then
		State.currentInventoryAnimTrack:Stop()
	end
	
	local animator = humanoid:FindFirstChildOfClass("Animator")
	if not animator then
		animator = Instance.new("Animator")
		animator.Parent = humanoid
	end
	
	local animTrack = animator:LoadAnimation(animAsset)
	animTrack.Looped = looped or false
	animTrack.Priority = Enum.AnimationPriority.Action4
	animTrack:Play()
	
	State.currentInventoryAnimTrack = animTrack
	return animTrack
end

-- Forward declaration for closePanel (needed for movement listener)
local closePanel
local cancelLooting

cancelLooting = function()
	if not State.isLootingChest then return end
	
	State.isLootingChest = false
	
	-- Stop looting animation
	if State.currentInventoryAnimTrack then
		 State.currentInventoryAnimTrack:Stop()
		 State.currentInventoryAnimTrack = nil
	end
	
	-- Cancel delayed panel open
	if State.lootingDelayTask then
		task.cancel(State.lootingDelayTask)
		State.lootingDelayTask = nil
	end
	
	-- Disconnect movement listener
	if State.lootingMoveConnection then
		State.lootingMoveConnection:Disconnect()
		State.lootingMoveConnection = nil
	end

	-- Re-enable scrolling if interrupted (Mobile improvement)
	if UI.contentScroll then
		UI.contentScroll.ScrollingEnabled = true
	end
	
	-- Reset opening button if visible
	if UI.chestOpenButton then
		UI.chestOpenButton.Visible = false
	end
	if UI.chestOpenLabel then
		UI.chestOpenLabel.Text = "OPEN"
	end
	if UI.chestOpenProgress then
		UI.chestOpenProgress.Size = UDim2.new(0, 0, 1, 0)
	end
	if State.openingProgressTween then
		State.openingProgressTween:Cancel()
		State.openingProgressTween = nil
	end
	
end

local function openPanel(fromChest)
	State.isPanelOpen = true
	
	-- Handle chest vs inventory mode
	if fromChest and State.isLootingChest then
		-- Chest looting mode - show ChestContainer, hide others
		UI.PlayerContainer.Visible = false
		UI.ChestContainer.Visible = true
		-- Hide Storage as well
		if UI.storageContainer then
			UI.storageContainer.Visible = false
		end
		State.isStorageOpen = false
		-- Don't play CheckInventoryIdle for chest looting (OpenChestIdle is played separately)
	else
		-- Normal inventory mode
		UI.PlayerContainer.Visible = true
		UI.ChestContainer.Visible = false
		-- Hide Storage as well
		if UI.storageContainer then
			UI.storageContainer.Visible = false
		end
		State.isStorageOpen = false
		State.isLootingChest = false
		-- Play CheckInventoryIdle animation (looped)
		playInventoryAnimation("CheckInventoryIdle", true)
	end
	
	-- Setup movement listener to auto-close when player moves
	local character = player.Character
	if character then
		local humanoid = character:FindFirstChildOfClass("Humanoid")
		if humanoid then
			-- Disconnect previous connection if any
			if State.movementConnection then
				State.movementConnection:Disconnect()
				State.movementConnection = nil
			end
			
			-- Connect to Running signal - fires when player starts moving
			State.movementConnection = humanoid.Running:Connect(function(speed)
				if speed > 0.1 and State.isPanelOpen then
					-- Player started moving - close inventory
					closePanel()
				end
			end)
		end
	end
	
	-- Enable blur
	if UI.blurEffect then
		UI.blurEffect.Enabled = true
	end
	
	-- Reset for instant display (no animation)
	UI.mainPanel.BackgroundTransparency = 0
	UI.mainPanel.AnchorPoint = Vector2.new(0.5, 0.5)
	UI.mainPanel.Position = UDim2.new(0.5, 0, 0.5, 0)
	UI.mainPanel.Visible = true
	UI.panelScale.Scale = 1  -- Full size immediately
	
	-- Show touch blocker for mobile (prevents camera movement)
	UI.touchBlocker.Visible = true
	
	-- Enable Modal to sink touch input (prevents camera movement on mobile)
	UI.mainPanel.Active = true

	
	-- Setup based on mode
	if not State.isLootingChest then
		-- Inventory mode: Setup grid slot inputs for click-to-move
		if Data.gridSlots then
			for row = 1, Config.GRID_ROWS do
				if Data.gridSlots[row] then
					for col = 1, Config.GRID_COLS do
						local slot = Data.gridSlots[row][col]
						if slot then
							setupGridSlotInput(slot, row, col)
						end
					end
				end
			end
		end
		
		-- Update character viewport and health bar
		updateCharacterViewport()
		connectHealthBar()
	end
end

closePanel = function()
	State.isPanelOpen = false
	
	-- Re-enable scrolling if interrupted (Mobile improvement)
	if UI.contentScroll then
		UI.contentScroll.ScrollingEnabled = true
	end
	
	-- Disconnect movement listener
	if State.movementConnection then
		State.movementConnection:Disconnect()
		State.movementConnection = nil
	end
	
	-- Cancel looting progress if any
	if State.isLootingChest then
		cancelLooting()
	end
	
	-- Clear chest grid data and visuals for security (prevent hacking)
	if State.currentChestModel then
		-- Clear chest item frames
		for _, itemFrame in pairs(chestLootItems or {}) do
			if itemFrame and itemFrame.Parent then
				itemFrame:Destroy()
			end
		end
		chestLootItems = {}
		
		-- Clear chest grid data
		Data.chestGridData = {}
		Data.chestItems = {}
		
		-- Clear chest state
		State.currentChestModel = nil
		State.currentChestConfig = nil
		State.isLootingChest = false
	end
	
	-- Clear selection and close any popups
	clearSelection()
	closeItemInfoPopup()
	
	-- Stop current inventory animation
	if State.currentInventoryAnimTrack and State.currentInventoryAnimTrack.IsPlaying then
		State.currentInventoryAnimTrack:Stop()
	end
	
	-- Hide touch blocker
	UI.touchBlocker.Visible = false
	
	-- Cleanup any active drag state
	if State.isDragging then
		if State.dragGhost then
			State.dragGhost:Destroy()
			State.dragGhost = nil
		end
		clearHighlights()
		if State.draggedItem then
			State.draggedItem.frame.Visible = true
			resetOriginalSlotHighlight(State.originalSlot.row, State.originalSlot.col, State.originalSlot.width, State.originalSlot.height)
			-- Return item to original position
			placeItemInGrid(State.draggedItem.config.id, State.originalSlot.width, State.originalSlot.height, State.originalSlot.row, State.originalSlot.col)
			State.draggedItem.row = State.originalSlot.row
			State.draggedItem.col = State.originalSlot.col
		end
		State.isDragging = false
		State.draggedItem = nil
		State.activeTouchId = nil
	end
	
	-- Close instantly (no animation)
	UI.mainPanel.Visible = false
	if UI.blurEffect then
		UI.blurEffect.Enabled = false
	end
end

-- ============================================================================
-- BUTTON CONNECTIONS
-- ============================================================================

UI.invButton.MouseButton1Click:Connect(function()
	-- Play inventory sound
	local soundService = game:GetService("SoundService")
	local inventorySound = soundService:FindFirstChild("Inventory")
	if inventorySound and inventorySound:IsA("Sound") then
		inventorySound:Play()
	end
	
	if State.isPanelOpen then
		closePanel()
	else
		openPanel()
	end
end)

UI.closeButton.MouseButton1Click:Connect(function()
	-- Play close sound
	local soundService = game:GetService("SoundService")
	local closeSound = soundService:FindFirstChild("InventoryClose")
	if closeSound and closeSound:IsA("Sound") then
		closeSound:Play()
	end
	closePanel()
end)

-- Hover effects
UI.invButton.MouseEnter:Connect(function()
	Services.TweenService:Create(UI.invButton, TweenInfo.new(0.15), {BackgroundColor3 = Color3.fromRGB(45, 45, 75)}):Play()
end)
UI.invButton.MouseLeave:Connect(function()
	Services.TweenService:Create(UI.invButton, TweenInfo.new(0.15), {BackgroundColor3 = Color3.fromRGB(25, 25, 45)}):Play()
end)

UI.closeButton.MouseEnter:Connect(function()
	Services.TweenService:Create(UI.closeButton, TweenInfo.new(0.15), {BackgroundColor3 = Color3.fromRGB(220, 70, 70)}):Play()
end)
UI.closeButton.MouseLeave:Connect(function()
	Services.TweenService:Create(UI.closeButton, TweenInfo.new(0.15), {BackgroundColor3 = Color3.fromRGB(180, 50, 50)}):Play()
end)

-- ============================================================================
-- CHEST LOOT DETECTION SYSTEM
-- ============================================================================

-- Chest Open Button UI (Container Button)
UI.chestOpenButton = Instance.new("TextButton")
UI.chestOpenButton.Name = "ChestOpenButton"
UI.chestOpenButton.Size = UDim2.new(0, 150, 0, 40)
UI.chestOpenButton.Position = UDim2.new(0.5, 50, 0.5, 30) -- Match lootPopup position
UI.chestOpenButton.AnchorPoint = Vector2.new(0, 0)
UI.chestOpenButton.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
UI.chestOpenButton.BackgroundTransparency = 0.6
UI.chestOpenButton.BorderSizePixel = 0
UI.chestOpenButton.Text = "" -- Empty text, using label instead
UI.chestOpenButton.AutoButtonColor = false
UI.chestOpenButton.Visible = false
UI.chestOpenButton.ZIndex = 50
UI.chestOpenButton.Parent = UI.screenGui

local chestButtonCorner = Instance.new("UICorner")
chestButtonCorner.CornerRadius = UDim.new(0, 8)
chestButtonCorner.Parent = UI.chestOpenButton

local chestButtonStroke = Instance.new("UIStroke")
chestButtonStroke.Color = Color3.fromRGB(100, 80, 140) -- Match lootPopup color
chestButtonStroke.Thickness = 2
chestButtonStroke.Parent = UI.chestOpenButton

-- Image/Icon on the left
local chestOpenIcon = Instance.new("ImageLabel")
chestOpenIcon.Name = "Icon"
chestOpenIcon.Size = UDim2.new(0, 30, 0, 30)
chestOpenIcon.Position = UDim2.new(0, 6, 0.5, -15)
chestOpenIcon.BackgroundTransparency = 1
chestOpenIcon.Image = "rbxassetid://91638685038954"
chestOpenIcon.ScaleType = Enum.ScaleType.Fit
chestOpenIcon.ZIndex = 51
chestOpenIcon.Parent = UI.chestOpenButton

-- Open Label on the right
UI.chestOpenLabel = Instance.new("TextLabel")
UI.chestOpenLabel.Name = "OpenLabel"
UI.chestOpenLabel.Size = UDim2.new(1, -45, 1, 0)
UI.chestOpenLabel.Position = UDim2.new(0, 40, 0, 0)
UI.chestOpenLabel.BackgroundTransparency = 1
UI.chestOpenLabel.Text = "OPEN"
UI.chestOpenLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
UI.chestOpenLabel.TextSize = 16
UI.chestOpenLabel.Font = Enum.Font.GothamBold
UI.chestOpenLabel.ZIndex = 51
UI.chestOpenLabel.Parent = UI.chestOpenButton

-- Progress bar for opening animation (fills from left to right)
UI.chestOpenProgress = Instance.new("Frame")
UI.chestOpenProgress.Name = "ProgressBar"
UI.chestOpenProgress.Size = UDim2.new(0, 0, 1, 0)  -- Starts at 0 width
UI.chestOpenProgress.Position = UDim2.new(0, 0, 0, 0)
UI.chestOpenProgress.BackgroundColor3 = Color3.fromRGB(50, 150, 80)
UI.chestOpenProgress.BackgroundTransparency = 0.5
UI.chestOpenProgress.BorderSizePixel = 0
UI.chestOpenProgress.ZIndex = 49  -- Behind button content
UI.chestOpenProgress.Parent = UI.chestOpenButton

local progressCorner = Instance.new("UICorner")
progressCorner.CornerRadius = UDim.new(0, 8)
progressCorner.Parent = UI.chestOpenProgress

-- Chest detection state
State.nearbyChest = nil

-- Function to check distance to chests
local function findNearbyChest()
	local character = player.Character
	if not character then return nil end
	
	local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
	if not humanoidRootPart then return nil end
	
	local playerPos = humanoidRootPart.Position
	
	-- Check for chests in Workspace.Loots
	local lootsFolder = workspace:FindFirstChild("Loots")
	if not lootsFolder then return nil end
	
	local closestChest = nil
	local closestDistance = math.huge
	
	for _, chestModel in ipairs(lootsFolder:GetChildren()) do
		if chestModel:IsA("Model") then
			local chestPrimaryPart = chestModel.PrimaryPart or chestModel:FindFirstChildWhichIsA("BasePart")
			if chestPrimaryPart then
				-- Get chest-specific activation distance from ChestConfig
				local chestConf = ChestConfig and ChestConfig.GetChest(chestModel.Name)
				local maxDistance = (chestConf and chestConf.activationDistance) or 8  -- Default to 8
				
				local distance = (playerPos - chestPrimaryPart.Position).Magnitude
				if distance < maxDistance and distance < closestDistance then
					closestDistance = distance
					closestChest = chestModel
				end
			end
		end
	end
	
	return closestChest
end

-- Helper to play animation on physical chest model in workspace
local function playPhysicalChestAnimation(chestModel, animName, looped)
	local animFolder = Services.ReplicatedStorage:FindFirstChild("Anim")
	local lootAnims = animFolder and animFolder:FindFirstChild("Loots")
	if not lootAnims then return end
	
	local chestType = chestModel.Name
	local chestAnims = lootAnims:FindFirstChild(chestType)
	if not chestAnims then return end
	
	local anim = chestAnims:FindFirstChild(animName)
	if not anim or not anim:IsA("Animation") then return end
	
	local animationController = chestModel:FindFirstChildOfClass("AnimationController") or chestModel:FindFirstChild("Humanoid")
	if not animationController then
		animationController = Instance.new("AnimationController")
		animationController.Parent = chestModel
	end
	
	local animator = animationController:FindFirstChildOfClass("Animator") or Instance.new("Animator", animationController)
	
	-- Check if already playing the exact same animation to avoid resets
	for _, track in ipairs(animator:GetPlayingAnimationTracks()) do
		if track.Animation == anim then
			return track
		end
	end
	
	local track = animator:LoadAnimation(anim)
	track.Priority = animName == "Idle" and Enum.AnimationPriority.Idle or Enum.AnimationPriority.Action
	track.Looped = looped or false
	track:Play()
	
	return track
end

-- Centralized logic to handle physical chest visuals (Global Sync)
local function handlePhysicalChestState(chestModel, isInitial)
	local isOpen = chestModel:GetAttribute("Open") == true
	local wasOpenedLocally = chestModel:GetAttribute("LocallyAnimated") == true
	
	if isOpen then
		if not wasOpenedLocally and not isInitial then
			-- TRANSITION: First time seeing it open in real-time
			local animFolder = Services.ReplicatedStorage:FindFirstChild("Anim")
			local lootAnims = animFolder and animFolder:FindFirstChild("Loots")
			if lootAnims then
				local openSound = lootAnims:FindFirstChild("OpenSound")
				if openSound and openSound:IsA("Sound") then
					openSound:Play()
				end
			end
			
			-- Mark as animated to prevent re-opening if player walks away and back
			chestModel:SetAttribute("LocallyAnimated", true)
			
			-- Play Open -> Idle sequence (Idle REQUIRED to hold open position)
			local openTrack = playPhysicalChestAnimation(chestModel, "Open", false)
			if openTrack then
				openTrack.Stopped:Once(function()
					-- Idle MUST loop to keep chest in open pose
					playPhysicalChestAnimation(chestModel, "Idle", true)
				end)
			else
				playPhysicalChestAnimation(chestModel, "Idle", true)
			end
		else
			-- INITIAL or ALREADY ANIMATED: Ensure Idle is playing to hold pose
			if not wasOpenedLocally then
				chestModel:SetAttribute("LocallyAnimated", true)
			end
			-- Idle keeps the chest visually open
			playPhysicalChestAnimation(chestModel, "Idle", true)
		end
	end
end

-- Setup listeners for all chests
local function setupChestAttributeListeners()
	local lootsFolder = workspace:FindFirstChild("Loots")
	if not lootsFolder then return end
	
	local function observeChest(chest)
		if chest:IsA("Model") then
			-- Initial check (jump to Idle if already open)
			handlePhysicalChestState(chest, true)
			-- Listen for changes (play Open transition)
			chest:GetAttributeChangedSignal("Open"):Connect(function()
				handlePhysicalChestState(chest, false)
			end)
		end
	end
	
	-- Observe existing chests
	for _, child in ipairs(lootsFolder:GetChildren()) do
		observeChest(child)
	end
	
	-- Observe new chests (if they spawn)
	lootsFolder.ChildAdded:Connect(observeChest)
end

-- Start listeners
task.spawn(setupChestAttributeListeners)

local function openChest(chestModel)
	if State.isPanelOpen then return end
	
	local chestType = chestModel.Name
	local chestConf = ChestConfig and ChestConfig.GetChest(chestType)
	
	if not chestConf then
		chestConf = {
			name = "Unknown Chest",
			openingDelay = 5,
			gridRows = 4,
			gridCols = 5,
		}
	end
	
	-- Update state
	State.isLootingChest = true
	State.currentChestModel = chestModel
	State.currentChestConfig = chestConf
	
	-- Recreate chest grid based on this chest's configuration
	recreateChestGrid()
	
	-- OPTIMIZATION: If chest is already opened locally, skip wait
	local isAlreadyOpened = chestModel:GetAttribute("Open") == true
	if isAlreadyOpened then
		-- Request server to open (to get loot)
		if Events.OpenChest then
			-- Only trigger reveal animation if this is a DIFFERENT chest
			if State.lastOpenedChest ~= chestModel then
				State.isFirstChestSync = true
				State.lastOpenedChest = chestModel
			end
			Events.OpenChest:FireServer(chestModel)
		end
		-- Play OpenChestIdle animation since we're skipping the wait
		playInventoryAnimation("OpenChestIdle", true)
		-- handlePhysicalChestState will ensure Idle is playing
		openPanel(true)
		return
	end
	
	-- Setup movement listener for looting phase
	local character = player.Character
	if character then
		local humanoid = character:FindFirstChildOfClass("Humanoid")
		if humanoid then
			if State.lootingMoveConnection then
				State.lootingMoveConnection:Disconnect()
			end
			State.lootingMoveConnection = humanoid.Running:Connect(function(speed)
				if speed > 0.1 and State.isLootingChest then
					cancelLooting()
				end
			end)
		end
	end

	UI.chestNameLabel.Text = chestConf.name
	
	-- Start player looting animation (The circular inventory progress/arms)
	-- ONLY if not already opened (Mobile/UX Fix: skip search for open chests)
	local openTrack = nil
	if not isAlreadyOpened then
		openTrack = playInventoryAnimation("OpenChest", false)
		if openTrack then
			openTrack.Stopped:Once(function()
				if State.isLootingChest then
					playInventoryAnimation("OpenChestIdle", true)
				end
			end)
		end
		
		-- Show "Opening..." on the button with progress animation
		if UI.chestOpenButton and UI.chestOpenLabel and UI.chestOpenProgress then
			-- Change button text
			UI.chestOpenLabel.Text = "Opening..."
			UI.chestOpenButton.Visible = true
			
			-- Reset and animate progress bar (left to right)
			UI.chestOpenProgress.Size = UDim2.new(0, 0, 1, 0)
			
			local progressTween = Services.TweenService:Create(
				UI.chestOpenProgress,
				TweenInfo.new(chestConf.openingDelay, Enum.EasingStyle.Linear),
				{ Size = UDim2.new(1, 0, 1, 0) }
			)
			progressTween:Play()
			
			-- Store tween for cancellation
			State.openingProgressTween = progressTween
		end
	else
		UI.chestOpenButton.Visible = false
	end
	
	-- Wait for opening delay
	State.lootingDelayTask = task.delay(chestConf.openingDelay, function()
		if not State.isLootingChest then return end
		
		-- Reset and hide the opening button
		if UI.chestOpenButton then
			UI.chestOpenButton.Visible = false
		end
		if UI.chestOpenLabel then
			UI.chestOpenLabel.Text = "OPEN"
		end
		if UI.chestOpenProgress then
			UI.chestOpenProgress.Size = UDim2.new(0, 0, 1, 0)
		end
		if State.openingProgressTween then
			State.openingProgressTween:Cancel()
			State.openingProgressTween = nil
		end
		
		-- REQUEST SERVER TO OPEN (Server will set "Open" attribute)
		-- Visuals (Sound/Anim) will trigger via handlePhysicalChestState listener
		if Events.OpenChest then
			-- Only trigger reveal animation if this is a DIFFERENT chest
			if State.lastOpenedChest ~= chestModel then
				State.isFirstChestSync = true
				State.lastOpenedChest = chestModel
			end
			Events.OpenChest:FireServer(chestModel)
		end
		
		if State.lootingMoveConnection then
			State.lootingMoveConnection:Disconnect()
			State.lootingMoveConnection = nil
		end
		
		State.lootingDelayTask = nil
		
		-- openPanel will be called by SyncChestLoot event handler
	end)
end

-- Chest Open button click handler
UI.chestOpenButton.MouseButton1Click:Connect(function()
	if State.nearbyChest then
		openChest(State.nearbyChest)
	end
end)

-- Chest detection loop
Services.RunService.Heartbeat:Connect(function()
	-- Security: If panel is open and looting a chest, check if still in range
	if State.isPanelOpen and State.isLootingChest and State.currentChestModel then
		local character = player.Character
		if character then
			local hrp = character:FindFirstChild("HumanoidRootPart")
			local chestPart = State.currentChestModel.PrimaryPart or State.currentChestModel:FindFirstChildWhichIsA("BasePart")
			if hrp and chestPart then
				local chestConf = State.currentChestConfig
				local maxDistance = (chestConf and chestConf.activationDistance) or 8
				local distance = (hrp.Position - chestPart.Position).Magnitude
				if distance > maxDistance + 2 then  -- Small buffer
					-- Force close panel - player walked away
					closePanel()
					return
				end
			end
		end
	end
	
	if State.isPanelOpen then
		UI.chestOpenButton.Visible = false
		return
	end
	
	local foundChest = findNearbyChest()
	
	if foundChest then
		State.nearbyChest = foundChest
		UI.chestOpenButton.Visible = true
	else
		State.nearbyChest = nil
		UI.chestOpenButton.Visible = false
	end
end)

-- Hover effects for chest button
UI.chestOpenButton.MouseEnter:Connect(function()
	Services.TweenService:Create(UI.chestOpenButton, TweenInfo.new(0.15), {BackgroundColor3 = Color3.fromRGB(30, 30, 30), BackgroundTransparency = 0.6}):Play()
end)
UI.chestOpenButton.MouseLeave:Connect(function()
	Services.TweenService:Create(UI.chestOpenButton, TweenInfo.new(0.15), {BackgroundColor3 = Color3.fromRGB(0, 0, 0), BackgroundTransparency = 0.6}):Play()
end)

-- ============================================================================
-- STORAGE SYSTEM (Mirrors Chest System)
-- ============================================================================

local storageLootItems = {} -- Track visual frames

-- Helper: Clear visual grid
local function clearStorageGridVisuals()
	for _, itemFrame in pairs(storageLootItems) do
		if itemFrame then itemFrame:Destroy() end
	end
	storageLootItems = {}
end

-- Create Storage Item Frame (Visual) - Mirrors createChestItemFrame
local function createStorageItemFrame(itemData)
	local itemFrame = Instance.new("Frame")
	itemFrame.Name = itemData.id
	itemFrame.Size = UDim2.new(0, itemData.width * Config.STORAGE.CELL_SIZE + (itemData.width - 1) * Config.STORAGE.CELL_PADDING, 
	                           0, itemData.height * Config.STORAGE.CELL_SIZE + (itemData.height - 1) * Config.STORAGE.CELL_PADDING)
	itemFrame.Position = UDim2.new(0, (itemData.col - 1) * (Config.STORAGE.CELL_SIZE + Config.STORAGE.CELL_PADDING), 
	                               0, (itemData.row - 1) * (Config.STORAGE.CELL_SIZE + Config.STORAGE.CELL_PADDING))
	
	-- Appearance (same as inventory/chest)
	local frameColor = ItemConfig.GetRarityFrameColor(itemData.rarity or "Common")
	itemFrame.BackgroundColor3 = frameColor
	itemFrame.BackgroundTransparency = ItemConfig.GetRarityFrameTransparency()
	itemFrame.BorderSizePixel = 0
	itemFrame.ZIndex = 15
	itemFrame.Active = true
	itemFrame.Parent = UI.storageGridFrame -- Must be defined in createStoragePanel or similar
	
	local stroke = Instance.new("UIStroke")
	stroke.Color = ItemConfig.GetRarityColor(itemData.rarity or "Common")
	stroke.Thickness = 1
	stroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
	stroke.Parent = itemFrame
	
	-- Gradient
	local darkerColor = Color3.fromRGB(frameColor.R*255*0.6, frameColor.G*255*0.6, frameColor.B*255*0.6)
	local gradient = Instance.new("UIGradient")
	gradient.Color = ColorSequence.new({ColorSequenceKeypoint.new(0, frameColor), ColorSequenceKeypoint.new(1, darkerColor)})
	gradient.Rotation = 45
	gradient.Parent = itemFrame
	
	-- Icon
	if itemData.icon and itemData.icon ~= "" and itemData.icon ~= "rbxassetid://0" then
		local icon = Instance.new("ImageLabel")
		icon.Size = UDim2.new(1,0,1,0)
		icon.BackgroundTransparency = 1
		icon.Image = itemData.icon
		icon.ScaleType = Enum.ScaleType.Fit
		icon.ZIndex = 16
		icon.Parent = itemFrame
	end
	
	-- Input Handling (matches createChestItemFrame pattern)
	local dragStarted = false
	local isPressed = false
	local longPressThread = nil
	local lastTapTime = 0
	local tapStartTime = 0
	local tapStartPos = nil
	
	itemFrame.InputBegan:Connect(function(input, gameProcessed)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			if State.isDragging then return end
			
			isPressed = true
			dragStarted = false
			tapStartTime = tick()
			tapStartPos = Vector2.new(input.Position.X, input.Position.Y)
			
			-- Long press for drag
			longPressThread = task.spawn(function()
				task.wait(Config.LONG_PRESS_DURATION or 0.4)
				if isPressed and not dragStarted and not State.isDragging then
					dragStarted = true
					startStorageDrag(itemData, itemFrame, Services.UserInputService:GetMouseLocation())
				end
			end)
			
			if input.UserInputType == Enum.UserInputType.Touch then
				State.activeTouchId = input
			end
		end
	end)
	
	itemFrame.InputChanged:Connect(function(input, gameProcessed)
		if not isPressed or State.isDragging then return end
		
		if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
			if tapStartPos then
				local currentPos = Vector2.new(input.Position.X, input.Position.Y)
				local distance = (currentPos - tapStartPos).Magnitude
				
				if not dragStarted and distance > (Config.TAP_THRESHOLD_DISTANCE or 10) then
					dragStarted = true
					if longPressThread then
						task.cancel(longPressThread)
						longPressThread = nil
					end
					startStorageDrag(itemData, itemFrame, Services.UserInputService:GetMouseLocation())
				end
			end
		end
	end)
	
	itemFrame.InputEnded:Connect(function(input, gameProcessed)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			if not isPressed then return end
			
			local now = tick()
			
			if not dragStarted and tapStartPos then
				local elapsed = now - tapStartTime
				local currentPos = Vector2.new(input.Position.X, input.Position.Y)
				local distance = (currentPos - tapStartPos).Magnitude
				
				if elapsed < 0.4 and distance < 20 then
					if now - lastTapTime < 0.3 then
						-- DOUBLE TAP: Move to inventory (requires selection first)
						if State.selectedItem and State.selectedItem.config.id == itemData.config.id then
							if Events.MoveToInventory then
								Events.MoveToInventory:FireServer(itemData.id, nil, nil)
							end
							
							if Data.storageItems[itemData.id] then
								Data.storageItems[itemData.id] = nil
								removeItemFromStorageGrid(itemData.id)
							end
							itemFrame:Destroy()
							
							lastTapTime = 0
							clearSelection()
						else
							-- Double-tap but not selected? Select it
							local pseudoData = {
								config = itemData.config,
								row = itemData.row, col = itemData.col,
								width = itemData.width, height = itemData.height,
								frame = itemFrame,
								isStorageItem = true
							}
							selectItem(pseudoData)
							lastTapTime = now
						end
					else
						-- SINGLE TAP: Selection
						local pseudoData = {
							config = itemData.config,
							row = itemData.row, col = itemData.col,
							width = itemData.width, height = itemData.height,
							frame = itemFrame,
							isStorageItem = true
						}
						
						if State.selectedItem and State.selectedItem.config.id == itemData.config.id then
							-- Already selected - toggle off (unselect)
							clearSelection()
						else
							selectItem(pseudoData)
						end
						lastTapTime = now
					end
				end
			end
			
			isPressed = false
			tapStartPos = nil
			dragStarted = false
			if longPressThread then
				task.cancel(longPressThread)
				longPressThread = nil
			end
		end
	end)
	
	return itemFrame
end

-- Setup Storage Slot Input (Inventory -> Storage via click/smart placement)
local function setupStorageSlotInput(slot, row, col)
	slot.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			if State.selectedItem and not State.isDragging then
				-- Check if storage slot is empty
				-- Need Data.storageGridData to be populated
				if not Data.storageGridData[row] or not Data.storageGridData[row][col] then
					-- If Inventory Item Selected -> Move to Storage (Grid click)
					if not State.selectedItem.isStorageItem and not State.selectedItem.isChestItem then
						-- Inventory to Storage
						if Events.MoveToStorage then
							-- Smart placement check can go here or let server handle
							Events.MoveToStorage:FireServer(State.selectedItem.config.id, row, col)
							
							-- Optimistic cleanup
							removeItemFromGrid(State.selectedItem.config.id)
							Data.inventoryItems[State.selectedItem.config.id] = nil
							if State.selectedItem.frame then State.selectedItem.frame:Destroy() end
							clearSelection()
						end
					elseif State.selectedItem.isStorageItem then
						-- Storage to Storage (Move within storage) - Use smart placement
						local itemWidth = State.selectedItem.width or 1
						local itemHeight = State.selectedItem.height or 1
						local itemId = State.selectedItem.config.id
						
						-- Remove from current position temporarily
						removeItemFromStorageGrid(itemId)
						
						-- Try to place at target position with rotation support
						local canPlace = canPlaceItemInStorage(itemWidth, itemHeight, row, col, itemId)
						local finalRow, finalCol, finalWidth, finalHeight = row, col, itemWidth, itemHeight
						local rotated = false
						
						if not canPlace and itemWidth ~= itemHeight then
							-- Try rotated
							if canPlaceItemInStorage(itemHeight, itemWidth, row, col, itemId) then
								canPlace = true
								finalWidth = itemHeight
								finalHeight = itemWidth
								rotated = true
							end
						end
						
						if canPlace then
							-- Update item position
							State.selectedItem.row = finalRow
							State.selectedItem.col = finalCol
							State.selectedItem.width = finalWidth
							State.selectedItem.height = finalHeight
							
							-- Update in Data.storageItems
							if Data.storageItems[itemId] then
								Data.storageItems[itemId].row = finalRow
								Data.storageItems[itemId].col = finalCol
								Data.storageItems[itemId].width = finalWidth
								Data.storageItems[itemId].height = finalHeight
							end
							
							-- Place in new position
							placeItemInStorageGrid(itemId, finalWidth, finalHeight, finalRow, finalCol)
							
							-- Update frame position
							if State.selectedItem.frame then
								State.selectedItem.frame.Size = UDim2.new(0, finalWidth * Config.STORAGE.CELL_SIZE + (finalWidth - 1) * Config.STORAGE.CELL_PADDING, 
								                                          0, finalHeight * Config.STORAGE.CELL_SIZE + (finalHeight - 1) * Config.STORAGE.CELL_PADDING)
								State.selectedItem.frame.Position = UDim2.new(0, (finalCol - 1) * (Config.STORAGE.CELL_SIZE + Config.STORAGE.CELL_PADDING), 
								                                               0, (finalRow - 1) * (Config.STORAGE.CELL_SIZE + Config.STORAGE.CELL_PADDING))
							end
							
							-- Notify server
							if Events.UpdateStorageItemPosition then
								Events.UpdateStorageItemPosition:FireServer(itemId, finalRow, finalCol, rotated)
							end
							
							clearSelection()
						else
							-- Can't place, restore original position
							placeItemInStorageGrid(itemId, itemWidth, itemHeight, State.selectedItem.row, State.selectedItem.col)
							
							-- Flash red
							local originalColor = slot.BackgroundColor3
							slot.BackgroundColor3 = Color3.fromRGB(100, 40, 40)
							Services.TweenService:Create(slot, TweenInfo.new(0.3), { BackgroundColor3 = originalColor }):Play()
						end
					end
				end
			end
		end
	end)
end

-- ============================================================================
-- CHEST LOOT SYNC HANDLER
-- ============================================================================

local chestLootItems = {}  -- Track items displayed in chest grid

-- Clear chest grid items
local function clearChestGrid()
	for _, itemFrame in pairs(chestLootItems) do
		if itemFrame and itemFrame.Parent then
			itemFrame:Destroy()
		end
	end
	chestLootItems = {}
	State.isRevealSequenceRunning = false
end

-- Create chest item frame (similar to inventory item)
local function createChestItemFrame(itemData)
	local itemFrame = Instance.new("Frame")
	itemFrame.Name = itemData.id
	
	-- Use dynamic chest config for cell size/padding (fallback to default if not set)
	local chestConf = State.currentChestConfig or { gridRows = 6, gridCols = 6 }
	local cellSize = Config.CHEST.CELL_SIZE
	local cellPadding = Config.CHEST.CELL_PADDING
	
	itemFrame.Size = UDim2.new(0, itemData.width * cellSize + (itemData.width - 1) * cellPadding, 
	                           0, itemData.height * cellSize + (itemData.height - 1) * cellPadding)
	itemFrame.Position = UDim2.new(0, (itemData.col - 1) * (cellSize + cellPadding), 
	                               0, (itemData.row - 1) * (cellSize + cellPadding))
	
	-- Use RarityFrameColors for background
	local frameColor = ItemConfig.GetRarityFrameColor(itemData.rarity or "Common")
	local frameTransparency = ItemConfig.GetRarityFrameTransparency()
	itemFrame.BackgroundColor3 = frameColor
	itemFrame.BackgroundTransparency = frameTransparency
	itemFrame.BorderSizePixel = 0
	itemFrame.ZIndex = 15
	itemFrame.Active = true  -- Frame needs Active=true for robust input began
	itemFrame.Parent = UI.gridContainerChest
	
	-- Stroke color (using RarityColors for stroke/border)
	local strokeColor = ItemConfig.GetRarityColor(itemData.rarity or "Common")
	
	-- Gradient (based on frame color for visual effect)
	local darkerColor = Color3.fromRGB(
		math.floor(frameColor.R * 255 * 0.6),
		math.floor(frameColor.G * 255 * 0.6),
		math.floor(frameColor.B * 255 * 0.6)
	)
	local gradient = Instance.new("UIGradient")
	gradient.Color = ColorSequence.new({
		ColorSequenceKeypoint.new(0, frameColor),
		ColorSequenceKeypoint.new(1, darkerColor),
	})
	gradient.Rotation = 45
	gradient.Parent = itemFrame
	
	-- Stroke (using RarityColors for stroke/border) - hidden initially for reveal
	local stroke = Instance.new("UIStroke")
	stroke.Name = "ItemStroke"
	stroke.Color = strokeColor
	stroke.Thickness = 1
	stroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
	stroke.Transparency = 1  -- Hidden during reveal
	stroke.Parent = itemFrame
	
	-- Icon
	local iconImage = nil
	if itemData.icon and itemData.icon ~= "" and itemData.icon ~= "rbxassetid://0" then
		iconImage = Instance.new("ImageLabel")
		iconImage.Name = "Icon"
		iconImage.Size = UDim2.new(1, 0, 1, 0)
		iconImage.Position = UDim2.new(0, 0, 0, 0)
		iconImage.BackgroundTransparency = 1
		iconImage.Image = itemData.icon
		iconImage.ScaleType = Enum.ScaleType.Fit
		iconImage.ZIndex = 16
		iconImage.Parent = itemFrame
	end
	
	-- SIMPLE LOGIC: 
	-- isFirstChestSync = true (chest first open) â†’ mystery box + hidden icon
	-- isFirstChestSync = false (deposit update) â†’ no mystery box, icon visible
	if State.isFirstChestSync then
		-- First chest open: hide icon, show mystery box
		if iconImage then
			iconImage.Visible = false
		end
		stroke.Transparency = 1  -- Hide stroke during reveal
		
		local mysteryBox = Instance.new("ImageLabel")
		mysteryBox.Name = "MysteryBox"
		mysteryBox.Size = UDim2.new(1, 0, 1, 0)
		mysteryBox.Position = UDim2.new(0, 0, 0, 0)
		mysteryBox.BackgroundTransparency = 1
		mysteryBox.Image = ItemConfig.GetMysteryBoxAsset(itemData.width or 1, itemData.height or 1)
		mysteryBox.ScaleType = Enum.ScaleType.Fit
		mysteryBox.ZIndex = 17
		mysteryBox.Parent = itemFrame
		
		itemFrame:SetAttribute("IsRevealing", true)
	else
		-- Deposit update: show icon immediately, no mystery box
		if iconImage then
			iconImage.Visible = true
		end
		stroke.Transparency = 0
		itemFrame:SetAttribute("IsRevealing", false)
	end
	

	
	-- Standardized Input Handling for Mobile (Match Inventory logic)
	local dragStarted = false
	local isPressed = false
	local longPressThread = nil
	local lastTapTime = 0
	
	itemFrame.InputBegan:Connect(function(input, gameProcessed)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			-- Block interaction during reveal animation
			if itemFrame:GetAttribute("IsRevealing") then return end
			if State.isDragging then return end
			
			isPressed = true
			dragStarted = false
			tapStartTime = tick()
			tapStartPos = Vector2.new(input.Position.X, input.Position.Y)
			
			-- Start same long-press pattern as inventory
			longPressThread = task.spawn(function()
				task.wait(Config.LONG_PRESS_DURATION)
				if isPressed and not dragStarted and not State.isDragging then
					-- For chest items, we just trigger the drag after duration too
					dragStarted = true
					startChestDrag(itemData, itemFrame, Services.UserInputService:GetMouseLocation())
				end
			end)
			
			if input.UserInputType == Enum.UserInputType.Touch then
				State.activeTouchId = input
			end
		end
	end)
	
	itemFrame.InputChanged:Connect(function(input, gameProcessed)
		if not isPressed or State.isDragging then return end
		
		if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
			if tapStartPos then
				local currentPos = Vector2.new(input.Position.X, input.Position.Y)
				local distance = (currentPos - tapStartPos).Magnitude
				
				-- If moved beyond threshold, start drag (cancel long-press)
				if not dragStarted and distance > Config.TAP_THRESHOLD_DISTANCE then
					dragStarted = true
					if longPressThread then
						task.cancel(longPressThread)
						longPressThread = nil
					end
					startChestDrag(itemData, itemFrame, Services.UserInputService:GetMouseLocation())
				end
			end
		end
	end)
	
	itemFrame.InputEnded:Connect(function(input, gameProcessed)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			if not isPressed then return end
			
			local now = tick()
			-- Let global InputEnded handler manage endDrag to prevent premature snap-back
			if not dragStarted and tapStartPos then
				-- Handle double-tap or selection (only if not dragging)
				local elapsed = now - tapStartTime
				local currentPos = Vector2.new(input.Position.X, input.Position.Y)
				local distance = (currentPos - tapStartPos).Magnitude
				
				if elapsed < 0.4 and distance < 20 then
					if now - lastTapTime < 0.3 then
						-- DOUBLE TAP: Collect - but first check if inventory has space
						local itemWidth = itemData.width or 1
						local itemHeight = itemData.height or 1
						
						-- Check if inventory has space for this item
						if not canFitItemAnywhere(itemWidth, itemHeight) then
							-- No space in inventory - don't collect, keep item in chest
							lastTapTime = 0
							return
						end
						
						-- Has space - proceed with collection
						if Events.CollectItem then
							local chestPos = State.currentChestModel and State.currentChestModel.PrimaryPart and State.currentChestModel.PrimaryPart.Position
							Events.CollectItem:FireServer(itemData.name, chestPos)
							
							-- CRITICAL: Clear chest grid data (real-time update fix)
							removeItemFromChestGrid(itemData.id)
							Data.chestItems[itemData.id] = nil
							
							itemFrame:Destroy()
						end
						lastTapTime = 0
					else
						-- SINGLE TAP: Selection
						local pseudoItemData = {
							config = {
								id = itemData.id,
								name = itemData.name,
								icon = itemData.icon,
								weight = itemData.weight,
								price = itemData.price,
								rarity = itemData.rarity,
							},
							row = itemData.row,
							col = itemData.col,
							width = itemData.width,
							height = itemData.height,
							frame = itemFrame,
							isChestItem = true
						}
						
						if State.selectedItem and State.selectedItem.config.id == itemData.id then
							clearSelection()
						else
							selectItem(pseudoItemData)
						end
						lastTapTime = now
					end
				end
			end
			
			isPressed = false
			tapStartPos = nil
			dragStarted = false
			if longPressThread then
				task.cancel(longPressThread)
				longPressThread = nil
			end
		end
	end)
	
	return itemFrame
end

-- Reveal a single chest item with animated search icon
local function revealChestItem(itemFrame, itemData)
	if not itemFrame or not itemFrame.Parent then return end
	
	-- Get reveal delay based on rarity
	local revealDelay = ItemConfig.GetRevealDelay(itemData.rarity or "Common")
	
	-- Create search icon
	local searchIcon = Instance.new("ImageLabel")
	searchIcon.Name = "SearchIcon"
	searchIcon.Size = UDim2.new(1, 0, 1, 0)
	searchIcon.Position = UDim2.new(0, 0, 0, 0)
	searchIcon.AnchorPoint = Vector2.new(0.5, 0.5)
	searchIcon.BackgroundTransparency = 1
	searchIcon.Image = "rbxassetid://102779162979818"
	searchIcon.ScaleType = Enum.ScaleType.Fit
	searchIcon.ZIndex = 18  -- Above mystery box
	searchIcon.Parent = itemFrame
	
	-- Animate search icon in circular orbit (smaller radius)
	local orbitRadius = math.min(itemFrame.AbsoluteSize.X, itemFrame.AbsoluteSize.Y) * 0.075
	local orbitSpeed = 2  -- seconds per full rotation
	
	local orbitConnection
	local startTime = tick()
	orbitConnection = Services.RunService.Heartbeat:Connect(function()
		if not searchIcon.Parent then
			orbitConnection:Disconnect()
			return
		end
		
		local elapsed = tick() - startTime
		local angle = (elapsed / orbitSpeed) * math.pi * 2
		
		-- Calculate orbit position (circular motion around center)
		local offsetX = math.cos(angle) * orbitRadius
		local offsetY = math.sin(angle) * orbitRadius
		
		searchIcon.Position = UDim2.new(0.5, offsetX, 0.5, offsetY)
	end)
	
	-- Wait for reveal delay
	task.wait(revealDelay)
	
	-- Stop orbit animation
	if orbitConnection then
		orbitConnection:Disconnect()
	end
	
	-- Remove search icon
	if searchIcon and searchIcon.Parent then
		searchIcon:Destroy()
	end
	
	-- Find and remove mystery box
	local mysteryBox = itemFrame:FindFirstChild("MysteryBox")
	if mysteryBox then
		mysteryBox:Destroy()
	end
	
	-- Show actual icon
	local icon = itemFrame:FindFirstChild("Icon")
	if icon then
		icon.Visible = true
	end
	
	-- Show stroke (rarity border)
	local stroke = itemFrame:FindFirstChild("ItemStroke")
	if stroke then
		stroke.Transparency = 0
	end
	
	-- Enable interactions
	itemFrame:SetAttribute("IsRevealing", false)
end

-- Start sequential reveal animation for all chest items
local function startChestRevealSequence()
	if State.isRevealSequenceRunning then
		return
	end
	
	State.isRevealSequenceRunning = true
	task.spawn(function()
		-- Get all chest items and sort by position
		local itemsToReveal = {}
		for itemId, itemData in pairs(Data.chestItems) do
			local frame = chestLootItems[itemId]
			-- Only include items that have MysteryBox (need to be revealed)
			if frame and frame.Parent and frame:FindFirstChild("MysteryBox") then
				table.insert(itemsToReveal, {
					frame = frame,
					data = itemData,
				})
			end
		end
		
		-- Sort by position (row then column)
		table.sort(itemsToReveal, function(a, b)
			if a.data.row == b.data.row then
				return a.data.col < b.data.col
			else
				return a.data.row < b.data.row
			end
		end)
		
		-- Animate each item sequentially
		for _, item in ipairs(itemsToReveal) do
			if item.frame and item.frame.Parent then
				revealChestItem(item.frame, item.data.config)
			end
		end
		
		State.isRevealSequenceRunning = false
	end)
end


-- Handle chest loot sync from server
if Events.SyncChestLoot then
	Events.SyncChestLoot.OnClientEvent:Connect(function(chestData)
		if not chestData or not chestData.items then 
			return 
		end
		
		-- ALWAYS clear grid first to prevent any duplication
		clearChestGrid()
		initializeChestGridData()
		
		-- Create all items from server data
		for _, itemData in ipairs(chestData.items) do
			local frame = createChestItemFrame(itemData)
			chestLootItems[itemData.id] = frame
			
			Data.chestItems[itemData.id] = {
				config = {
					id = itemData.id,
					name = itemData.name,
					icon = itemData.icon,
					weight = itemData.weight,
					price = itemData.price,
					rarity = itemData.rarity,
				},
				row = itemData.row,
				col = itemData.col,
				width = itemData.width,
				height = itemData.height,
				frame = frame,
			}
			
			placeItemInChestGrid(itemData.id, itemData.width, itemData.height, itemData.row, itemData.col)
		end
		
		-- Only run reveal animation on first sync
		if State.isFirstChestSync then
			startChestRevealSequence()
			State.isFirstChestSync = false
		end
		
		
		-- UI Trigger: If the player currently waiting for this chest gets loot, open the panel
		if State.isLootingChest then
			-- Cancel any pending delay task
			if State.lootingDelayTask then
				task.cancel(State.lootingDelayTask)
				State.lootingDelayTask = nil
			end
			
			-- Stop current inventory animation
			if State.currentInventoryAnimTrack then
				State.currentInventoryAnimTrack:Stop()
			end
			
			-- Clean up looting connection
			if State.lootingMoveConnection then
				State.lootingMoveConnection:Disconnect()
				State.lootingMoveConnection = nil
			end
			
			-- Open panel for everyone who requested it (if not already showing)
			if not State.isPanelOpen then
				openPanel(true)
			end
			
			-- Reset looting flag
			State.isLootingChest = false
		end
	end)
end

-- ============================================================================
-- STORAGE SYSTEM
-- ============================================================================

local function initializeStorageGridData()
	Data.storageGridData = {}
	for row = 1, Config.STORAGE.GRID_ROWS do
		Data.storageGridData[row] = {}
		for col = 1, Config.STORAGE.GRID_COLS do
			Data.storageGridData[row][col] = nil
		end
	end
end

initializeStorageGridData()

local function placeItemInStorageGrid(itemId, width, height, row, col)
	for r = row, row + height - 1 do
		for c = col, col + width - 1 do
			if Data.storageGridData[r] then
				Data.storageGridData[r][c] = itemId
			end
		end
	end
end

local function removeItemFromStorageGrid(itemId)
	for r = 1, Config.STORAGE.GRID_ROWS do
		for c = 1, Config.STORAGE.GRID_COLS do
			if Data.storageGridData[r] and Data.storageGridData[r][c] == itemId then
				Data.storageGridData[r][c] = nil
			end
		end
	end
end

local function canPlaceInStorageGrid(row, col, width, height, excludeId)
	if row < 1 or col < 1 then return false end
	if row + height - 1 > Config.STORAGE.GRID_ROWS then return false end
	if col + width - 1 > Config.STORAGE.GRID_COLS then return false end
	
	for r = row, row + height - 1 do
		for c = col, col + width - 1 do
			local occupant = Data.storageGridData[r] and Data.storageGridData[r][c]
			if occupant and occupant ~= excludeId then
				return false
			end
		end
	end
	return true
end

UI.storageContainer = Instance.new("Frame")
UI.storageContainer.Name = "StorageContainer"
UI.storageContainer.Size = UDim2.new(0.49, 0, 1, -60)
UI.storageContainer.Position = UDim2.new(0.5, 0, 0, 50)
UI.storageContainer.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
UI.storageContainer.BackgroundTransparency = 0.5
UI.storageContainer.ClipsDescendants = true
UI.storageContainer.Visible = false
UI.storageContainer.Active = true
UI.storageContainer.ZIndex = 10
UI.storageContainer.Parent = UI.mainPanel

local storageContainerCorner = Instance.new("UICorner")
storageContainerCorner.CornerRadius = UDim.new(0, 8)
storageContainerCorner.Parent = UI.storageContainer

local storageContainerStroke = Instance.new("UIStroke")
storageContainerStroke.Color = Color3.fromRGB(70, 70, 100)
storageContainerStroke.Thickness = 1
storageContainerStroke.Parent = UI.storageContainer

local storageTitle = Instance.new("TextLabel")
storageTitle.Name = "StorageTitle"
storageTitle.Size = UDim2.new(0.5, 0, 0, 30)
storageTitle.Position = UDim2.new(0.02, 0, 0.02, 0)
storageTitle.BackgroundTransparency = 1
storageTitle.Text = "ðŸ“¦ STORAGE"
storageTitle.TextColor3 = Color3.fromRGB(100, 180, 255)
storageTitle.TextSize = 18
storageTitle.TextXAlignment = Enum.TextXAlignment.Left
storageTitle.Font = Enum.Font.GothamBold
storageTitle.ZIndex = 12
storageTitle.Parent = UI.storageContainer

UI.storageGridFrame = Instance.new("Frame")
UI.storageGridFrame.Name = "StorageGridFrame"
local storageGridWidth = Config.STORAGE.GRID_COLS * Config.STORAGE.CELL_SIZE + (Config.STORAGE.GRID_COLS - 1) * Config.STORAGE.CELL_PADDING
local storageGridHeight = Config.STORAGE.GRID_ROWS * Config.STORAGE.CELL_SIZE + (Config.STORAGE.GRID_ROWS - 1) * Config.STORAGE.CELL_PADDING
UI.storageGridFrame.Size = UDim2.new(0, storageGridWidth, 0, storageGridHeight)
UI.storageGridFrame.Position = UDim2.new(0.06, 0, 0.09, 0)
UI.storageGridFrame.AnchorPoint = Vector2.new(0, 0)
UI.storageGridFrame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
UI.storageGridFrame.BackgroundTransparency = 0.5
UI.storageGridFrame.ZIndex = 11
UI.storageGridFrame.Active = true
UI.storageGridFrame.Parent = UI.storageContainer

Data.storageGridSlots = {}

for row = 1, Config.STORAGE.GRID_ROWS do
	Data.storageGridSlots[row] = {}
	for col = 1, Config.STORAGE.GRID_COLS do
		local slot = Instance.new("Frame")
		slot.Name = "StorageSlot_" .. row .. "_" .. col
		slot.Size = UDim2.new(0, Config.STORAGE.CELL_SIZE, 0, Config.STORAGE.CELL_SIZE)
		slot.Position = UDim2.new(0, (col - 1) * (Config.STORAGE.CELL_SIZE + Config.STORAGE.CELL_PADDING), 0, (row - 1) * (Config.STORAGE.CELL_SIZE + Config.STORAGE.CELL_PADDING))
		slot.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
		slot.BackgroundTransparency = 1
		slot.BorderSizePixel = 0
		slot.ZIndex = 12
		slot.Parent = UI.storageGridFrame
		
		local slotStroke = Instance.new("UIStroke")
		slotStroke.Name = "SlotStroke"
		slotStroke.Color = Color3.fromRGB(60, 60, 80)
		slotStroke.Thickness = 1
		slotStroke.Parent = slot
		
		Data.storageGridSlots[row][col] = slot
		
		-- Connect Input Handler
		setupStorageSlotInput(slot, row, col)
	end
end

-- Handle Storage Sync
if Events.SyncStorage then
	Events.SyncStorage.OnClientEvent:Connect(function(storageData)
		clearStorageGridVisuals()
		initializeStorageGridData()
		
		if not storageData or not storageData.items then return end
		
		for _, itemInfo in ipairs(storageData.items) do
			-- Get base config from ItemConfig if available
			local baseConfig = ItemConfig[itemInfo.itemId or itemInfo.name] or ItemConfig.GetItem(itemInfo.itemId or itemInfo.name)
			
			-- Reconstruct item data for creation with FULL config
			local itemData = {
				id = itemInfo.id,
				config = {
					id = itemInfo.id,
					itemId = itemInfo.itemId or itemInfo.name,
					name = itemInfo.name,
					icon = itemInfo.icon or (baseConfig and baseConfig.icon) or "",
					rarity = itemInfo.rarity or (baseConfig and baseConfig.rarity) or "Common",
					width = itemInfo.width or (baseConfig and baseConfig.width) or 1,
					height = itemInfo.height or (baseConfig and baseConfig.height) or 1,
					weight = itemInfo.weight or (baseConfig and baseConfig.weight) or 0.15,
					price = itemInfo.price or (baseConfig and baseConfig.price) or 50,
					description = (baseConfig and baseConfig.description) or "A stored item."
				},
				name = itemInfo.name,
				itemId = itemInfo.itemId or itemInfo.name,
				icon = itemInfo.icon or (baseConfig and baseConfig.icon) or "",
				rarity = itemInfo.rarity or (baseConfig and baseConfig.rarity) or "Common",
				row = itemInfo.row,
				col = itemInfo.col,
				width = itemInfo.width or (baseConfig and baseConfig.width) or 1,
				height = itemInfo.height or (baseConfig and baseConfig.height) or 1,
				weight = itemInfo.weight or (baseConfig and baseConfig.weight) or 0.15,
				price = itemInfo.price or (baseConfig and baseConfig.price) or 50
			}
			
			local frame = createStorageItemFrame(itemData)
			storageLootItems[itemData.id] = frame
			Data.storageItems[itemData.id] = itemData
			placeItemInStorageGrid(itemData.id, itemData.width, itemData.height, itemData.row, itemData.col)
		end
	end)
end

-- ============================================================================
-- STORAGE INTERACTION LOGIC (Restored)
-- ============================================================================

UI.storageOpenButton = Instance.new("TextButton")
UI.storageOpenButton.Name = "StorageOpenButton"
UI.storageOpenButton.Size = UDim2.new(0, 150, 0, 40)
UI.storageOpenButton.Position = UDim2.new(0.5, 100, 0.5, 40) -- More to the right and up
UI.storageOpenButton.AnchorPoint = Vector2.new(0, 0)
UI.storageOpenButton.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
UI.storageOpenButton.BackgroundTransparency = 0.6
UI.storageOpenButton.BorderSizePixel = 0
UI.storageOpenButton.Text = ""
UI.storageOpenButton.AutoButtonColor = false
UI.storageOpenButton.Visible = false
UI.storageOpenButton.ZIndex = 50
UI.storageOpenButton.Parent = UI.screenGui

local storageButtonCorner = Instance.new("UICorner")
storageButtonCorner.CornerRadius = UDim.new(0, 8)
storageButtonCorner.Parent = UI.storageOpenButton

local storageButtonStroke = Instance.new("UIStroke")
storageButtonStroke.Color = Color3.fromRGB(100, 150, 200)
storageButtonStroke.Thickness = 2
storageButtonStroke.Parent = UI.storageOpenButton

local storageOpenIcon = Instance.new("ImageLabel")
storageOpenIcon.Name = "Icon"
storageOpenIcon.Size = UDim2.new(0, 30, 0, 30)
storageOpenIcon.Position = UDim2.new(0, 6, 0.5, -15)
storageOpenIcon.BackgroundTransparency = 1
storageOpenIcon.Image = "rbxassetid://91638685038954"
storageOpenIcon.ScaleType = Enum.ScaleType.Fit
storageOpenIcon.ZIndex = 51
storageOpenIcon.Parent = UI.storageOpenButton

local storageOpenLabel = Instance.new("TextLabel")
storageOpenLabel.Name = "OpenLabel"
storageOpenLabel.Size = UDim2.new(1, -45, 1, 0)
storageOpenLabel.Position = UDim2.new(0, 40, 0, 0)
storageOpenLabel.BackgroundTransparency = 1
storageOpenLabel.Text = "STORAGE"
storageOpenLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
storageOpenLabel.TextSize = 16
storageOpenLabel.Font = Enum.Font.GothamBold
storageOpenLabel.ZIndex = 51
storageOpenLabel.Parent = UI.storageOpenButton

-- Progress bar for opening animation (similar to chest)
UI.storageOpenProgress = Instance.new("Frame")
UI.storageOpenProgress.Name = "OpenProgress"
UI.storageOpenProgress.Size = UDim2.new(0, 0, 1, 0) -- Starts empty
UI.storageOpenProgress.Position = UDim2.new(0, 0, 0, 0)
UI.storageOpenProgress.BackgroundColor3 = Color3.fromRGB(80, 160, 255)
UI.storageOpenProgress.BackgroundTransparency = 0.5
UI.storageOpenProgress.BorderSizePixel = 0
UI.storageOpenProgress.ZIndex = 50 -- Below text
UI.storageOpenProgress.Parent = UI.storageOpenButton

local storageProgressCorner = Instance.new("UICorner")
storageProgressCorner.CornerRadius = UDim.new(0, 8)
storageProgressCorner.Parent = UI.storageOpenProgress

local function findNearbyStorage()
	local character = player.Character
	if not character then return nil end
	
	local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
	if not humanoidRootPart then return nil end
	
	local playerPos = humanoidRootPart.Position
	
	local safeZone = workspace:FindFirstChild("SafeZone")
	if not safeZone then return nil end
	
	local storage = safeZone:FindFirstChild("Storage")
	if not storage then return nil end
	
	local trigger = storage:FindFirstChild("TriggerStorage")
	if not trigger or not trigger:IsA("BasePart") then return nil end
	
	local distance = (playerPos - trigger.Position).Magnitude
	if distance < 10 then
		return trigger
	end
	
	return nil
end

local function openStoragePanel()
	if State.isPanelOpen and not State.isStorageOpen then return end
	
	State.isStorageOpen = true
	
	UI.storageContainer.Visible = true
	
	-- Hide Chest Container when Storage is open
	if UI.ChestContainer then
		UI.ChestContainer.Visible = false
	end
	
	if UI.PlayerContainer then
		UI.PlayerContainer.Visible = false
	end
	
	if not State.isPanelOpen then
		if UI.blurEffect then
			UI.blurEffect.Enabled = true
		end
		
		-- Reset UI properties for full display
		UI.mainPanel.BackgroundTransparency = 0
		UI.mainPanel.AnchorPoint = Vector2.new(0.5, 0.5)
		UI.mainPanel.Position = UDim2.new(0.5, 0, 0.5, 0)
		UI.mainPanel.Visible = true
		UI.panelScale.Scale = 1  -- Ensure full size
		
		State.isPanelOpen = true
		UI.touchBlocker.Visible = true
		
		-- Also ensure Active is true
		UI.mainPanel.Active = true
	end
end

local function closeStoragePanel()
	State.isStorageOpen = false
	UI.storageContainer.Visible = false
	
	if UI.PlayerContainer then
		UI.PlayerContainer.Visible = true
	end
end

State.storageOpeningTween = nil

UI.storageOpenButton.MouseButton1Click:Connect(function()
	if State.nearbyStorage then
		-- Already opening?
		if State.storageOpeningTween then return end
		
		-- Start opening animation (1 second)
		storageOpenLabel.Text = "Opening..."
		UI.storageOpenProgress.Size = UDim2.new(0, 0, 1, 0)
		
		local progressTween = Services.TweenService:Create(
			UI.storageOpenProgress,
			TweenInfo.new(1, Enum.EasingStyle.Linear),
			{ Size = UDim2.new(1, 0, 1, 0) }
		)
		State.storageOpeningTween = progressTween
		progressTween:Play()
		
		progressTween.Completed:Connect(function(playbackState)
			if playbackState == Enum.PlaybackState.Completed then
				openStoragePanel()
				storageOpenLabel.Text = "STORAGE"
				UI.storageOpenProgress.Size = UDim2.new(0, 0, 1, 0)
			end
			State.storageOpeningTween = nil
		end)
	end
end)

Services.RunService.Heartbeat:Connect(function()
	if State.isPanelOpen and State.isStorageOpen and State.nearbyStorage then
		local character = player.Character
		if character then
			local hrp = character:FindFirstChild("HumanoidRootPart")
			if hrp and State.nearbyStorage and State.nearbyStorage:IsA("BasePart") then
				local distance = (hrp.Position - State.nearbyStorage.Position).Magnitude
				if distance > 12 then
					closeStoragePanel()
					closePanel()
					return
				end
			end
		end
	end
	
	if State.isPanelOpen then
		UI.storageOpenButton.Visible = false
		return
	end
	
	if State.isLootingChest then
		UI.storageOpenButton.Visible = false
		return
	end
	
	local foundStorage = findNearbyStorage()
	
	if foundStorage then
		State.nearbyStorage = foundStorage
		UI.storageOpenButton.Visible = true
	else
		State.nearbyStorage = nil
		UI.storageOpenButton.Visible = false
	end
end)