PROMPT 1: CORE MODULES EXTRACTION
Target: 500-1000 lines per module | Consolidate related logic
PROMPT 1: StateAndDataManager Module ⚠️ MEDIUM RISK
TASK: Extract State management, Data structures, and Grid utility functions into single comprehensive module

OBJECTIVE: Create StateAndDataManager.lua that handles:
1. All State variables (isDragging, selectedItem, etc)
2. All Data structures (gridData, inventoryItems, etc)
3. Grid utility functions (canPlaceItem, placeItemInGrid, etc)
4. Initialization functions

TARGET FILE: StateAndDataManager.lua
ESTIMATED SIZE: ~600-800 lines

SOURCE CODE SECTIONS TO EXTRACT:

SECTION 1: Configuration (Lines 14-58)
- Config table with all constants
- PRESERVE ALL numeric values exactly

SECTION 2: Data Structures (Lines 60-65)
- Data.gridData, inventoryItems, chestGridData, etc
- Initialize with proper dimensions

SECTION 3: State Variables (Lines 67-118)
- All State.* variables
- isDragging, draggedItem, selectedItem, etc

SECTION 4: Grid Utility Functions (Lines ~1200-1500, scattered)
- canPlaceItem (CRITICAL - preserve exact logic!)
- placeItemInGrid
- removeItemFromGrid
- canPlaceItemInChest
- placeItemInChestGrid
- removeItemFromChestGrid
- canPlaceItemInStorage
- placeItemInStorageGrid
- removeItemFromStorageGrid
- canFitItemAnywhere
- findBestChestPlacement
- getGridPositionFromAbsolute

⚠️⚠️⚠️ CRITICAL PRESERVATION RULES ⚠️⚠️⚠️

1. COLLISION DETECTION LOGIC - DO NOT MODIFY:
   - Boundary checks MUST stay exact
   - Loop ranges MUST be identical
   - excludeItemId logic MUST be preserved
   - Grid bounds checking formulas MUST NOT change

2. STATE MANAGEMENT:
   - ALL State properties must be included
   - Initial values MUST match exactly
   - Property names CANNOT change (used everywhere!)

3. GRID FORMULAS - PRESERVE EXACTLY:
```lua
-- EXAMPLE: This exact logic MUST be preserved:
if startRow < 1 or startCol < 1 then return false end
if startRow + height - 1 > Config.GRID_ROWS then return false end
if startCol + width - 1 > Config.GRID_COLS then return false end
OUTPUT STRUCTURE:
-- StateAndDataManager.lua
-- Manages State, Data structures, and Grid operations
-- CRITICAL: Grid collision logic is sensitive - test thoroughly!

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RigsBackpackConfig = require(ReplicatedStorage:WaitForChild("RigsBackpackConfig"))
local ItemConfig = require(ReplicatedStorage:WaitForChild("ItemConfig"))

local StateAndDataManager = {}

-- ============================================================================
-- CONFIGURATION
-- ============================================================================

local currentRig = RigsBackpackConfig.GetRig("Default")

StateAndDataManager.Config = {
	-- Grid Configuration (from RigsBackpackConfig)
	GRID_COLS = currentRig.gridCols,
	GRID_ROWS = currentRig.gridRows,
	CELL_SIZE = currentRig.cellSize,
	CELL_PADDING = currentRig.cellPadding,
	
	-- Item Drop Configuration
	DROPPED_ITEM_DISTANCE = 5,
	
	-- Auto-scroll Configuration (CRITICAL: Affects drag feel)
	DRAG_SCROLL_EDGE_TOP = 120,
	DRAG_SCROLL_EDGE_BOTTOM = 50,
	DRAG_SCROLL_SPEED = 12,
	
	-- Layout Configuration
	ARMOR_SLOT_SIZE = 50,
	PANEL_PADDING = 20,
	
	-- UI Element Sizes
	UI = {
		invBtnSize = UDim2.new(0, 57, 0, 66),
		invBtnPos = UDim2.new(0, 15, 0.5, 39),
		invEmojiSize = 28,
		invLabelSize = 12,
		titleTextSize = 18,
		closeBtnSize = UDim2.new(0, 32, 0, 32),
	},
	
	-- Chest Grid Configuration
	CHEST = {
		GRID_ROWS = 6,
		GRID_COLS = 6,
		CELL_SIZE = 50,
		CELL_PADDING = 4,
	},
	
	-- Storage Grid Configuration
	STORAGE = {
		GRID_ROWS = 11,
		GRID_COLS = 6,
		CELL_SIZE = 50,
		CELL_PADDING = 4,
	},
	
	-- Input Timing (CRITICAL: User experience)
	LONG_PRESS_DURATION = 0.4,
	TAP_THRESHOLD_TIME = 0.2,
	TAP_THRESHOLD_DISTANCE = 10,
}

-- ============================================================================
-- DATA STRUCTURES
-- ============================================================================

StateAndDataManager.Data = {
	gridData = {},
	inventoryItems = {},
	chestGridData = {},
	chestItems = {},
	storageGridData = {},
	storageItems = {},
	gridSlots = {},
	chestGridSlots = {},
	armorSlots = {},
}

-- ============================================================================
-- STATE VARIABLES
-- ============================================================================

StateAndDataManager.State = {
	-- Drag System
	isDragging = false,
	draggedItem = nil,
	dragGhost = nil,
	originalSlot = { row = 0, col = 0 },
	lastDragPosition = nil,
	dragSource = nil,
	dragSourceChestData = nil,
	
	-- Selection System
	selectedItem = nil,
	selectionHighlight = nil,
	actionBarSelectedItem = nil,
	
	-- Auto-scroll
	isAutoScrolling = false,
	autoScrollDirection = 0,
	autoScrollIntensity = 0,
	
	-- Panel State
	isPanelOpen = false,
	
	-- Chest System
	isLootingChest = false,
	currentChestModel = nil,
	currentChestConfig = nil,
	isFirstChestSync = true,
	lastOpenedChest = nil,
	
	-- Storage System
	isStorageOpen = false,
	nearbyStorage = nil,
	
	-- Viewport
	viewportCurrentRotationY = 180,
	viewportIsRotating = false,
	viewportLastMousePos = nil,
	viewportCharClone = nil,
	
	-- Animations
	currentInventoryAnimTrack = nil,
	isRevealSequenceRunning = false,
	
	-- Input
	longPressStartTime = nil,
	longPressItem = nil,
	activeTouchId = nil,
	tapStartTime = 0,
	tapStartPos = Vector2.new(0, 0),
	
	-- Highlights
	highlightOverlay = nil,
	originalSlotOverlay = nil,
	chestHighlightOverlay = nil,
	chestOriginalSlotOverlay = nil,
	storageHighlightOverlay = nil,
	storageOriginalSlotOverlay = nil,
	
	-- Popups
	itemInfoPopup = nil,
	
	-- Connections
	movementConnection = nil,
	lootingDelayTask = nil,
	lootingMoveConnection = nil,
	healthConnection = nil,
}

-- ============================================================================
-- INITIALIZATION FUNCTIONS
-- ============================================================================

-- Initialize inventory grid data
function StateAndDataManager.initializeGridData()
	StateAndDataManager.Data.gridData = {}
	for row = 1, StateAndDataManager.Config.GRID_ROWS do
		StateAndDataManager.Data.gridData[row] = {}
		for col = 1, StateAndDataManager.Config.GRID_COLS do
			StateAndDataManager.Data.gridData[row][col] = nil
		end
	end
end

-- Initialize chest grid data (dynamic size)
function StateAndDataManager.initializeChestGridData()
	StateAndDataManager.Data.chestGridData = {}
	local chestConf = StateAndDataManager.State.currentChestConfig or { gridRows = 6, gridCols = 6 }
	for r = 1, chestConf.gridRows do
		StateAndDataManager.Data.chestGridData[r] = {}
		for c = 1, chestConf.gridCols do
			StateAndDataManager.Data.chestGridData[r][c] = nil
		end
	end
	StateAndDataManager.Data.chestItems = {}
end

-- Initialize storage grid data
function StateAndDataManager.initializeStorageGridData()
	StateAndDataManager.Data.storageGridData = {}
	for r = 1, StateAndDataManager.Config.STORAGE.GRID_ROWS do
		StateAndDataManager.Data.storageGridData[r] = {}
		for c = 1, StateAndDataManager.Config.STORAGE.GRID_COLS do
			StateAndDataManager.Data.storageGridData[r][c] = nil
		end
	end
	StateAndDataManager.Data.storageItems = {}
end

-- ============================================================================
-- GRID UTILITY FUNCTIONS - INVENTORY
-- ============================================================================

-- Check if item can be placed at position (CRITICAL - DO NOT MODIFY LOGIC)
function StateAndDataManager.canPlaceItem(width, height, startRow, startCol, excludeItemId)
	-- Boundary checks (PRESERVE EXACT LOGIC)
	if startRow < 1 or startCol < 1 then return false end
	if startRow + height - 1 > StateAndDataManager.Config.GRID_ROWS then return false end
	if startCol + width - 1 > StateAndDataManager.Config.GRID_COLS then return false end
	
	-- Check if cells are empty (PRESERVE EXACT LOGIC)
	for r = startRow, startRow + height - 1 do
		for c = startCol, startCol + width - 1 do
			local occupant = StateAndDataManager.Data.gridData[r][c]
			if occupant ~= nil and occupant ~= excludeItemId then
				return false
			end
		end
	end
	
	return true
end

-- Place item in grid (PRESERVE EXACT LOGIC)
function StateAndDataManager.placeItemInGrid(itemId, width, height, startRow, startCol)
	for r = startRow, startRow + height - 1 do
		-- Bounds check for row
		if r >= 1 and r <= StateAndDataManager.Config.GRID_ROWS and StateAndDataManager.Data.gridData[r] then
			for c = startCol, startCol + width - 1 do
				-- Bounds check for column
				if c >= 1 and c <= StateAndDataManager.Config.GRID_COLS then
					StateAndDataManager.Data.gridData[r][c] = itemId
				end
			end
		end
	end
end

-- Remove item from grid
function StateAndDataManager.removeItemFromGrid(itemId)
	for r = 1, StateAndDataManager.Config.GRID_ROWS do
		for c = 1, StateAndDataManager.Config.GRID_COLS do
			if StateAndDataManager.Data.gridData[r][c] == itemId then
				StateAndDataManager.Data.gridData[r][c] = nil
			end
		end
	end
end

-- Check if item can fit ANYWHERE in inventory (tries rotation)
function StateAndDataManager.canFitItemAnywhere(width, height)
	-- Try normal orientation
	for row = 1, StateAndDataManager.Config.GRID_ROWS do
		for col = 1, StateAndDataManager.Config.GRID_COLS do
			if StateAndDataManager.canPlaceItem(width, height, row, col, nil) then
				return true
			end
		end
	end
	
	-- Try rotated if different dimensions
	if width ~= height then
		for row = 1, StateAndDataManager.Config.GRID_ROWS do
			for col = 1, StateAndDataManager.Config.GRID_COLS do
				if StateAndDataManager.canPlaceItem(height, width, row, col, nil) then
					return true
				end
			end
		end
	end
	
	return false
end

-- ============================================================================
-- GRID UTILITY FUNCTIONS - CHEST
-- ============================================================================

-- Check if item can be placed in chest (PRESERVE EXACT LOGIC)
function StateAndDataManager.canPlaceItemInChest(width, height, startRow, startCol, excludeItemId)
	local chestConf = StateAndDataManager.State.currentChestConfig or { gridRows = 6, gridCols = 6 }
	if startRow < 1 or startCol < 1 then return false end
	if startRow + height - 1 > chestConf.gridRows then return false end
	if startCol + width - 1 > chestConf.gridCols then return false end
	
	for r = startRow, startRow + height - 1 do
		for c = startCol, startCol + width - 1 do
			if StateAndDataManager.Data.chestGridData[r] then
				local occupant = StateAndDataManager.Data.chestGridData[r][c]
				if occupant ~= nil and occupant ~= excludeItemId then
					return false
				end
			end
		end
	end
	
	return true
end

-- Place item in chest grid
function StateAndDataManager.placeItemInChestGrid(itemId, width, height, startRow, startCol)
	for r = startRow, startRow + height - 1 do
		for c = startCol, startCol + width - 1 do
			if StateAndDataManager.Data.chestGridData[r] then
				StateAndDataManager.Data.chestGridData[r][c] = itemId
			end
		end
	end
end

-- Remove item from chest grid
function StateAndDataManager.removeItemFromChestGrid(itemId)
	local chestConf = StateAndDataManager.State.currentChestConfig or { gridRows = 6, gridCols = 6 }
	for r = 1, chestConf.gridRows do
		for c = 1, chestConf.gridCols do
			if StateAndDataManager.Data.chestGridData[r] and StateAndDataManager.Data.chestGridData[r][c] == itemId then
				StateAndDataManager.Data.chestGridData[r][c] = nil
			end
		end
	end
end

-- Find best placement in chest with rotation support (PRESERVE LOGIC)
function StateAndDataManager.findBestChestPlacement(width, height, targetRow, targetCol, excludeItemId)
	-- Try 1: Current orientation at target
	if StateAndDataManager.canPlaceItemInChest(width, height, targetRow, targetCol, excludeItemId) then
		return targetRow, targetCol, width, height, false
	end
	
	-- Try 2: Rotated at target
	if StateAndDataManager.canPlaceItemInChest(height, width, targetRow, targetCol, excludeItemId) then
		return targetRow, targetCol, height, width, true
	end
	
	-- Try 3: Search nearby with NEGATIVE offsets prioritized
	local maxOffset = math.max(width, height)
	
	for totalOffset = 1, maxOffset * 2 do
		for offsetR = 0, math.min(totalOffset, maxOffset) do
			local offsetC = totalOffset - offsetR
			if offsetC <= maxOffset then
				for _, signR in ipairs({-1, 1}) do
					for _, signC in ipairs({-1, 1}) do
						local tryRow = targetRow + (offsetR * signR)
						local tryCol = targetCol + (offsetC * signC)
						
						-- Try current orientation
						if StateAndDataManager.canPlaceItemInChest(width, height, tryRow, tryCol, excludeItemId) then
							return tryRow, tryCol, width, height, false
						end
						
						-- Try rotated
						if StateAndDataManager.canPlaceItemInChest(height, width, tryRow, tryCol, excludeItemId) then
							return tryRow, tryCol, height, width, true
						end
					end
				end
			end
		end
	end
	
	return nil, nil, nil, nil, nil
end

-- ============================================================================
-- GRID UTILITY FUNCTIONS - STORAGE
-- ============================================================================

-- Check if item can be placed in storage
function StateAndDataManager.canPlaceItemInStorage(width, height, startRow, startCol, excludeItemId)
	if startRow < 1 or startCol < 1 then return false end
	if startRow + height - 1 > StateAndDataManager.Config.STORAGE.GRID_ROWS then return false end
	if startCol + width - 1 > StateAndDataManager.Config.STORAGE.GRID_COLS then return false end
	
	for r = startRow, startRow + height - 1 do
		for c = startCol, startCol + width - 1 do
			if StateAndDataManager.Data.storageGridData[r] then
				local occupant = StateAndDataManager.Data.storageGridData[r][c]
				if occupant ~= nil and occupant ~= excludeItemId then
					return false
				end
			end
		end
	end
	return true
end

-- Place item in storage grid
function StateAndDataManager.placeItemInStorageGrid(itemId, width, height, startRow, startCol)
	for r = startRow, startRow + height - 1 do
		for c = startCol, startCol + width - 1 do
			if StateAndDataManager.Data.storageGridData[r] then
				StateAndDataManager.Data.storageGridData[r][c] = itemId
			end
		end
	end
end

-- Remove item from storage grid
function StateAndDataManager.removeItemFromStorageGrid(itemId)
	for r = 1, StateAndDataManager.Config.STORAGE.GRID_ROWS do
		for c = 1, StateAndDataManager.Config.STORAGE.GRID_COLS do
			if StateAndDataManager.Data.storageGridData[r] and StateAndDataManager.Data.storageGridData[r][c] == itemId then
				StateAndDataManager.Data.storageGridData[r][c] = nil
			end
		end
	end
end

-- ============================================================================
-- COORDINATE CONVERSION
-- ============================================================================

-- Convert absolute screen position to grid position (PRESERVE EXACT LOGIC)
function StateAndDataManager.getGridPositionFromAbsolute(absX, absY, gridContainer, uiScale)
	if not gridContainer or not uiScale then return nil, nil end
	
	local containerPos = gridContainer.AbsolutePosition
	local containerScale = uiScale.Scale
	
	local scaledCellSize = (StateAndDataManager.Config.CELL_SIZE + StateAndDataManager.Config.CELL_PADDING) * containerScale
	
	local relX = absX - containerPos.X
	local relY = absY - containerPos.Y
	
	-- Center-based rounding for symmetric behavior
	local col = math.floor((relX + scaledCellSize / 2) / scaledCellSize) + 1
	local row = math.floor((relY + scaledCellSize / 2) / scaledCellSize) + 1
	
	return row, col
end

-- ============================================================================
-- STATE GETTERS/SETTERS (Safe access patterns)
-- ============================================================================

function StateAndDataManager.getState(key)
	return StateAndDataManager.State[key]
end

function StateAndDataManager.setState(key, value)
	StateAndDataManager.State[key] = value
end

function StateAndDataManager.getData(key)
	return StateAndDataManager.Data[key]
end

-- Initialize all data structures
function StateAndDataManager.initialize()
	StateAndDataManager.initializeGridData()
	StateAndDataManager.initializeChestGridData()
	StateAndDataManager.initializeStorageGridData()
end

return StateAndDataManager
⚠️⚠️⚠️ VALIDATION CHECKLIST - TEST EACH ONE ⚠️⚠️⚠️
GRID COLLISION TESTS:
✅ Place 1x1 item in empty grid → should work
✅ Place 2x2 item at grid boundary → should detect out of bounds
✅ Place item overlapping existing item → should return false
✅ Place item with excludeItemId matching occupant → should work
✅ canFitItemAnywhere with 3x2 item in full grid → should return false
✅ Rotation test: 2x3 item fits as 3x2 → should detect and allow
CHEST GRID TESTS:
✅ Same tests as inventory but with chest dimensions
✅ findBestChestPlacement finds nearest valid spot
✅ Handles negative offsets correctly
STORAGE GRID TESTS:
✅ Same validation as inventory/chest
STATE ACCESS TESTS:
✅ getState/setState work correctly
✅ All State properties accessible
✅ No typos in property names
INITIALIZATION TESTS:
✅ Grid data initialized with correct dimensions
✅ All grids start with nil values
✅ Re-initialization doesn't break references
USAGE EXAMPLE IN MAIN SCRIPT:
local StateAndDataManager = require(script.StateAndDataManager)

-- Initialize
StateAndDataManager.initialize()

-- Access config
local gridRows = StateAndDataManager.Config.GRID_ROWS

-- Use grid functions
local canPlace = StateAndDataManager.canPlaceItem(2, 2, 1, 1, nil)
if canPlace then
    StateAndDataManager.placeItemInGrid("item_001", 2, 2, 1, 1)
end

-- Access state
local isDragging = StateAndDataManager.getState("isDragging")
StateAndDataManager.setState("isDragging", true)
MIGRATION NOTES:
Replace all Config. with StateAndDataManager.Config.
Replace all State. with StateAndDataManager.State. or use getState/setState
Replace all Data. with StateAndDataManager.Data.
Replace all grid utility calls with StateAndDataManager.functionName()
ROLLBACK PLAN:
If anything breaks:
Keep this module but don't use it
Revert to original State/Data/Config tables
Debug in isolation with test cases
Identify specific function causing issue
Fix that function only, test again
DO NOT PROCEED TO PROMPT 2 UNTIL:
✅ All validation tests pass
✅ Inventory drag-and-drop works identically
✅ Chest looting works identically
✅ No visual glitches or errors in console